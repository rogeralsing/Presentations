<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Akka</name>
    </assembly>
    <members>
        <member name="T:Akka.Actor.IActorState">
            <summary>
            This interface represents the parts of the internal actor state; the behavior stack, watched by, watching and termination queue
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorState.RemoveWatching(Akka.Actor.IActorRef)">
            <summary>
            Removes the provided <see cref="T:Akka.Actor.IActorRef"/> from the `Watching` set
            </summary>
            <param name="actor">The <see cref="T:Akka.Actor.IActorRef"/> to be removed</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.RemoveWatchedBy(Akka.Actor.IActorRef)">
            <summary>
            Removes the provided <see cref="T:Akka.Actor.IActorRef"/> from the `WatchedBy` set
            </summary>
            <param name="actor">The <see cref="T:Akka.Actor.IActorRef"/> to be removed</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.RemoveTerminated(Akka.Actor.IActorRef)">
            <summary>
            Removes the provided <see cref="T:Akka.Actor.IActorRef"/> from the `Termination queue` set
            </summary>
            <param name="actor">The <see cref="T:Akka.Actor.IActorRef"/> to be removed</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.AddWatching(Akka.Actor.IActorRef)">
            <summary>
            Adds the provided <see cref="T:Akka.Actor.IActorRef"/> to the `Watching` set
            </summary>
            <param name="actor">The <see cref="T:Akka.Actor.IActorRef"/> to be added</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.AddWatchedBy(Akka.Actor.IActorRef)">
            <summary>
            Adds the provided <see cref="T:Akka.Actor.IActorRef"/> to the `WatchedBy` set
            </summary>
            <param name="actor">The <see cref="T:Akka.Actor.IActorRef"/> to be added</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.AddTerminated(Akka.Actor.IActorRef)">
            <summary>
            Adds the provided <see cref="T:Akka.Actor.IActorRef"/> to the `Termination queue` set
            </summary>
            <param name="actor">The <see cref="T:Akka.Actor.IActorRef"/> to be added</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.ClearWatching">
            <summary>
            Clears the `Watching` set
            </summary>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.ClearTerminated">
            <summary>
            Clears the `Termination queue` set
            </summary>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.ClearBehaviorStack">
            <summary>
            Clears the `Behavior` stack
            </summary>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.Become(Akka.Actor.Receive)">
            <summary>
            Replaces the current receive behavior with a new behavior
            </summary>
            <param name="receive">The new behavior</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.BecomeStacked(Akka.Actor.Receive)">
            <summary>
            Pushes a new receive behavior onto the `Behavior` stack
            </summary>
            <param name="receive">The new top level behavior</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.UnbecomeStacked">
            <summary>
            Removes the top level receive behavior from the `Behavior` stack
            </summary>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.ContainsWatching(Akka.Actor.IActorRef)">
            <summary>
            Determines whether the provided <see cref="T:Akka.Actor.IActorRef"/> is present in the `Watching` set
            </summary>
            <param name="actor">The <see cref="T:Akka.Actor.IActorRef"/> to locate in the `Watching` set</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.ContainsWatchedBy(Akka.Actor.IActorRef)">
            <summary>
            Determines whether the provided <see cref="T:Akka.Actor.IActorRef"/> is present in the `WatchedBy` set
            </summary>
            <param name="actor">The <see cref="T:Akka.Actor.IActorRef"/> to locate in the `WatchedBy` set</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.ContainsTerminated(Akka.Actor.IActorRef)">
            <summary>
            Determines whether the provided <see cref="T:Akka.Actor.IActorRef"/> is present in the `Termination queue` set
            </summary>
            <param name="actor">The <see cref="T:Akka.Actor.IActorRef"/> to locate in the `Termination queue` set</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.GetWatching">
            <summary>
            Returns an <see cref="T:System.Collections.Generic.IEnumerable`1"/> over the `Watching` set
            </summary>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.GetWatchedBy">
            <summary>
            Returns an <see cref="T:System.Collections.Generic.IEnumerable`1"/> over the `WatchedBy` set
            </summary>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.Getterminated">
            <summary>
            Returns an <see cref="T:System.Collections.Generic.IEnumerable`1"/> over the `Termination queue` set
            </summary>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.IActorState.GetCurrentBehavior">
            <summary>
            Returns the top level receive behavior from the behavior stack
            </summary>
            <returns></returns>
        </member>
        <member name="T:Akka.Actor.DefaultActorState">
            <summary>
            Represents the default start up state for any actor.
            This state provides capacity for one `WatchedBy` and one `Receive` behavior
            As soon as this container is no longer enough to contain the current state
            The state container will escalate into a `FullActorState` instance
            </summary>
        </member>
        <member name="T:Akka.Actor.FullActorState">
            <summary>
            Represents the full state of an actor, this is used whenever an actor need more state than the `DefaultActorState` container can contain
            </summary>
        </member>
        <member name="T:Akka.Actor.ActorCell">
            <summary>
                Class ActorCell.
            </summary>
        </member>
        <member name="T:Akka.Actor.IUntypedActorContext">
            <summary>
            Interface IUntypedActorContext
            </summary>
        </member>
        <member name="T:Akka.Actor.IActorRefFactory">
            <summary>
            Interface IActorRefFactory
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorRefFactory.ActorOf(Akka.Actor.Props,System.String)">
            <summary>
            Create new actor as child of this context with the given name, which must
            not start with “$”. If the given name is already in use,
            and `InvalidActorNameException` is thrown.
            See <see cref="T:Akka.Actor.Props"/> for details on how to obtain a <see cref="T:Akka.Actor.Props"/> object.
            @throws akka.actor.InvalidActorNameException if the given name is
            invalid or already in use
            @throws akka.ConfigurationException if deployment, dispatcher
            or mailbox configuration is wrong
            </summary>
            <param name="props">The props.</param>
            <param name="name">The name.</param>
            <returns>InternalActorRef.</returns>
        </member>
        <member name="M:Akka.Actor.IActorRefFactory.ActorSelection(Akka.Actor.ActorPath)">
            <summary>
            Construct an <see cref="T:Akka.Actor.ActorSelection"/> from the given path, which is
            parsed for wildcards (these are replaced by regular expressions
            internally). No attempt is made to verify the existence of any part of
            the supplied path, it is recommended to send a message and gather the
            replies in order to resolve the matching set of actors.
            </summary>
            <param name="actorPath">The actor path.</param>
            <returns>ActorSelection.</returns>
        </member>
        <member name="M:Akka.Actor.IActorRefFactory.ActorSelection(System.String)">
            <summary>
            Construct an <see cref="T:Akka.Actor.ActorSelection"/> from the given path, which is
            parsed for wildcards (these are replaced by regular expressions
            internally). No attempt is made to verify the existence of any part of
            the supplied path, it is recommended to send a message and gather the
            replies in order to resolve the matching set of actors.
            </summary>
            <param name="actorPath">The actor path.</param>
            <returns>ActorSelection.</returns>
        </member>
        <member name="M:Akka.Actor.ICanWatch.Watch(Akka.Actor.IActorRef)">
            <summary>
            Monitors the specified actor for termination. When the <paramref name="subject"/> terminates
            the instance watching will receive a <see cref="T:Akka.Actor.Terminated"/> message.
            <remarks>Note that if the <see cref="T:Akka.Actor.Terminated"/> message isn't handled by the actor,
            by default the actor will crash by throwing a <see cref="T:Akka.Actor.DeathPactException"/>. To change
            the default behavior, override <see cref="M:Akka.Actor.ActorBase.Unhandled(System.Object)"/>.
            </remarks>
            </summary>
            <param name="subject">The actor to monitor for termination.</param>
            <returns>Returns the provided subject</returns>
        </member>
        <member name="M:Akka.Actor.ICanWatch.Unwatch(Akka.Actor.IActorRef)">
            <summary>
            Stops monitoring the <paramref name="subject"/> for termination.
            </summary>
            <param name="subject">The actor to stop monitor for termination.</param>
            <returns>Returns the provided subject</returns>
        </member>
        <member name="M:Akka.Actor.IActorContext.Become(Akka.Actor.Receive)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            </summary>
            <param name="receive">The new message handler.</param>
        </member>
        <member name="M:Akka.Actor.IActorContext.BecomeStacked(Akka.Actor.Receive)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            The current handler is stored on a stack, and you can revert to it by calling <see cref="M:Akka.Actor.IActorContext.UnbecomeStacked"/>
            <remarks>Please note, that in order to not leak memory, make sure every call to <see cref="M:Akka.Actor.IActorContext.BecomeStacked(Akka.Actor.Receive)"/>
            is matched with a call to <see cref="M:Akka.Actor.IActorContext.UnbecomeStacked"/>.</remarks>
            </summary>
            <param name="receive">The new message handler.</param>
        </member>
        <member name="M:Akka.Actor.IActorContext.UnbecomeStacked">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the previous one on the behavior stack.
            <remarks>In order to store an actor on the behavior stack, a call to <see cref="M:Akka.Actor.IActorContext.BecomeStacked(Akka.Actor.Receive)"/> must have been made
            prior to this call</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorContext.Child(System.String)">
            <summary>
            Retrieves a child actor with the specified name, if it exists.
            
            If the child with the given name cannot be found, 
            then <see cref="F:Akka.Actor.ActorRefs.Nobody"/> will be returned instead.
            </summary>
            <param name="name">
            The name of the child actor.
            
            e.g. "child1", "foo"
            
            Not the path, just the name of the child at the time it was created by this parent.
            </param>
            <returns>The <see cref="T:Akka.Actor.IActorRef"/> belonging to the child if found, <see cref="F:Akka.Actor.ActorRefs.Nobody"/> otherwise.</returns>
        </member>
        <member name="M:Akka.Actor.IActorContext.GetChildren">
            <summary>
            Gets all of the children that belong to this actor.
            
            If this actor has no children, 
            an empty collection of <see cref="T:Akka.Actor.IActorRef"/> is returned instead.
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorContext.SetReceiveTimeout(System.Nullable{System.TimeSpan})">
            <summary>
            <para>
            Defines the inactivity timeout after which the sending of a <see cref="T:Akka.Actor.ReceiveTimeout"/> message is triggered.
            When specified, the receive function should be able to handle a <see cref="T:Akka.Actor.ReceiveTimeout"/> message.
            </para>
            
            <para>
            Please note that the receive timeout might fire and enqueue the <see cref="T:Akka.Actor.ReceiveTimeout"/> message right after
            another message was enqueued; hence it is not guaranteed that upon reception of the receive
            timeout there must have been an idle period beforehand as configured via this method.
            </para>
            
            <para>
            Once set, the receive timeout stays in effect (i.e. continues firing repeatedly after inactivity
            periods). Pass in <c>null</c> to switch off this feature.
            </para>
            </summary>
            <param name="timeout">The timeout. Pass in <c>null</c> to switch off this feature.</param>
        </member>
        <member name="M:Akka.Actor.IActorContext.Stop(Akka.Actor.IActorRef)">
            <summary>
            Issues a stop command to the provided <see cref="T:Akka.Actor.IActorRef"/>, which will cause that actor
            to terminate.
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorContext.Self">
            <summary>
            Gets the <see cref="T:Akka.Actor.IActorRef"/> belonging to the current actor.
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorContext.Sender">
            <summary>
            Gets the <see cref="T:Akka.Actor.IActorRef"/> of the actor who sent the current message.
            
            If the message was not sent by an actor (i.e. some external non-actor code
            sent this actor a message) then this value will default to <see cref="F:Akka.Actor.ActorRefs.NoSender"/>.
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorContext.System">
            <summary>
            Gets a reference to the <see cref="T:Akka.Actor.ActorSystem"/> to which this actor belongs.
            
            <remarks>
            This property is how you can get access to the <see cref="!:Scheduler"/> and other parts
            of Akka.NET from within an actor instance.
            </remarks>
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorContext.Parent">
            <summary>
            Gets the <see cref="T:Akka.Actor.IActorRef"/> of the parent of the current actor.
            </summary>
        </member>
        <member name="M:Akka.Actor.IUntypedActorContext.Become(Akka.Actor.UntypedReceive)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            </summary>
            <param name="receive">The new message handler.</param>
        </member>
        <member name="M:Akka.Actor.IUntypedActorContext.BecomeStacked(Akka.Actor.UntypedReceive)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            The current handler is stored on a stack, and you can revert to it by calling <see cref="!:IUntypedActorContext.UnbecomeStacked"/>
            <remarks>Please note, that in order to not leak memory, make sure every call to <see cref="M:Akka.Actor.IUntypedActorContext.BecomeStacked(Akka.Actor.UntypedReceive)"/>
            is matched with a call to <see cref="!:IUntypedActorContext.UnbecomeStacked"/>.</remarks>
            </summary>
            <param name="receive">The new message handler.</param>
        </member>
        <member name="T:Akka.Actor.ICell">
            <summary>
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.ICell.Start">
            <summary>
            Start the cell: enqueued message must not be processed before this has
            been called. The usual action is to attach the mailbox to a dispatcher.
            </summary>
        </member>
        <member name="M:Akka.Actor.ICell.Suspend">
            <summary>Recursively suspend this actor and all its children. Is only allowed to throw fatal exceptions.</summary>
        </member>
        <member name="M:Akka.Actor.ICell.Resume(System.Exception)">
            <summary>Recursively resume this actor and all its children. Is only allowed to throw fatal exceptions.</summary>
        </member>
        <member name="M:Akka.Actor.ICell.Restart(System.Exception)">
            <summary>Restart this actor (will recursively restart or stop all children). Is only allowed to throw Fatal Throwables.</summary>
        </member>
        <member name="M:Akka.Actor.ICell.Stop">
            <summary>Recursively terminate this actor and all its children. Is only allowed to throw Fatal Throwables.</summary>
        </member>
        <member name="M:Akka.Actor.ICell.GetSingleChild(System.String)">
            <summary>
            Method for looking up a single child beneath this actor.
            It is racy if called from the outside.</summary>
        </member>
        <member name="M:Akka.Actor.ICell.TryGetChildStatsByName(System.String,Akka.Actor.Internal.IChildStats@)">
            <summary>
            Tries to get the stats for the child with the specified name. The stats can be either <see cref="T:Akka.Actor.Internal.ChildNameReserved"/> 
            indicating that only a name has been reserved for the child, or a <see cref="T:Akka.Actor.Internal.ChildRestartStats"/> for a child that 
            has been initialized/created.
            </summary>
        </member>
        <member name="P:Akka.Actor.ICell.Self">
            <summary>Gets the “self” reference which this Cell is attached to.</summary>
        </member>
        <member name="P:Akka.Actor.ICell.System">
            <summary>The system within which this Cell lives.</summary>
        </member>
        <member name="P:Akka.Actor.ICell.SystemImpl">
            <summary>The system internals within which this Cell lives.</summary>
        </member>
        <member name="P:Akka.Actor.ICell.Parent">
            <summary>The supervisor of this actor.</summary>
        </member>
        <member name="P:Akka.Actor.ICell.IsLocal">
            <summary>Returns true if the actor is local.</summary>
        </member>
        <member name="P:Akka.Actor.ICell.Props">
            <summary>The props for this actor cell.</summary>
        </member>
        <member name="P:Akka.Actor.ICell.HasMessages">
            <summary>
            If the actor isLocal, returns whether "user messages" are currently queued,
            <c>false</c>otherwise.
            </summary>
        </member>
        <member name="P:Akka.Actor.ICell.NumberOfMessages">
            <summary>
            If the actor isLocal, returns the number of "user messages" currently queued,
            which may be a costly operation, 0 otherwise.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.WatchedActorTerminated(Akka.Actor.IActorRef,System.Boolean,System.Boolean)">
            <summary>
            When this actor is watching the subject of <see cref="T:Akka.Actor.Terminated"/> message
            it will be propagated to user's receive.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.MaintainAddressTerminatedSubscription(System.Action,Akka.Actor.IActorRef)">
            <summary>
            Starts subscription to AddressTerminated if not already subscribing and the
            block adds a non-local ref to watching or watchedBy.
            Ends subscription to AddressTerminated if subscribing and the
            block removes the last non-local ref from watching and watchedBy.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.FaultRecreate(System.Exception)">
            <summary>Re-create the actor in response to a failure.</summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.FaultSuspend">
            <summary>
            Suspends the actor in response to a failure of a parent (i.e. the "recursive suspend" feature).
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.FaultResume(System.Exception)">
            <summary>
            Resumes the actor in response to a failure
            </summary>
            <param name="causedByFailure">The exception that caused the failure. signifies if it was our own failure 
            which prompted this action.</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.FaultCreate">
            <summary>
            Create the actor in response to a failure
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.Terminate">
            <summary>Terminates this instance.</summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.HandleNonFatalOrInterruptedException(System.Action)">
            <summary>
                Handles the non fatal or interrupted exception.
            </summary>
            <param name="action">The action.</param>
        </member>
        <member name="F:Akka.Actor.ActorCell._self">
            <summary>NOTE! Only constructor and ClearActorFields is allowed to update this</summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.Invoke(Akka.Actor.Envelope)">
            <summary>
                Invokes the specified envelope.
            </summary>
            <param name="envelope">The envelope.</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.ReceiveMessageForTest(Akka.Actor.Envelope)">
            <summary>
            This is only intended to be called from TestKit's TestActorRef
            </summary>
            <param name="envelope"></param>
        </member>
        <member name="M:Akka.Actor.ActorCell.ReceiveSelection(Akka.Actor.ActorSelectionMessage)">
            <summary>   
                Receives the selection.
            </summary>
            <param name="m">The m.</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.SystemInvoke(Akka.Actor.Envelope)">
            <summary>
                Systems the invoke.
            </summary>
            <param name="envelope">The envelope.</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.Publish(Akka.Event.LogEvent)">
            <summary>
                Publishes the specified event.
            </summary>
            <param name="event">The event.</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.HandleIdentity(Akka.Actor.Identify)">
            <summary>
                Handles the identity.
            </summary>
            <param name="m">The m.</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.HandlePoisonPill">
            <summary>
                Handles the poison pill.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.Restart(System.Exception)">
            <summary>
                Restarts the specified cause.
            </summary>
            <param name="cause">The cause.</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.Start">
            <summary>
                Starts this instance.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.PreStart">
            <summary>
            Allow extra pre-start initialization in derived classes
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.Resume(System.Exception)">
            <summary>
                Resumes the specified caused by failure.
            </summary>
            <param name="causedByFailure">The caused by failure.</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.Stop">
            <summary>
                Async stop this actor
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.Suspend">
            <summary>
                Suspends this instance.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.Kill">
            <summary>
                Kills this instance.
            </summary>
            <exception cref="T:Akka.Actor.ActorKilledException">Kill</exception>
        </member>
        <member name="M:Akka.Actor.ActorCell.Stop(Akka.Actor.IActorRef)">
            <summary>
                Stops the specified child.
            </summary>
            <param name="child">The child.</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.UpdateChildrenRefs``1(System.Func{Akka.Actor.Internal.IChildrenContainer,System.Tuple{System.Boolean,Akka.Actor.Internal.IChildrenContainer,``0}})">
            <summary>
            Swaps out the children container, by calling <paramref name="updater"/>  to produce the new container.
            If the underlying container has been updated while <paramref name="updater"/> was called,
            <paramref name="updater"/> will be called again with the new container. This will repeat until the 
            container can be swapped out, or until <see cref="P:System.Tuple`3.Item1"/> contains <c>false</c>.
            <para>The returned tuple should contain:</para>
            <para>Item1: <c>true</c> if the container should be updated; <c>false</c> to not update and return Item3</para>
            <para>Item2: The new container (will only be used if Item1=<c>true</c>)</para>
            <para>Item3: The return value</para>
            </summary>
            <param name="updater">A function that returns a new container.</param>
            <returns>The third value of the tuple that <paramref name="updater"/> returned.</returns>
        </member>
        <member name="M:Akka.Actor.ActorCell.UpdateChildrenRefs(System.Func{Akka.Actor.Internal.IChildrenContainer,Akka.Actor.Internal.IChildrenContainer})">
            <summary>
            Swaps out the children container, by calling <paramref name="updater"/>  to produce the new container.
            If the underlying container has been updated while <paramref name="updater"/> was called,
            <paramref name="updater"/> will be called again with the new container. This will repeat until the
            container can be swapped out.
            </summary>
            <param name="updater">A function that returns a new container.</param>
            <returns>The new updated <see cref="P:Akka.Actor.ActorCell.ChildrenContainer"/></returns>
        </member>
        <member name="M:Akka.Actor.ActorCell.InitChild(Akka.Actor.IInternalActorRef)">
            <summary>This should only be used privately or when creating the root actor. </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.SuspendChildren(System.Collections.Generic.List{Akka.Actor.IActorRef})">
            <summary>
                Suspends the children.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.ResumeChildren(System.Exception,Akka.Actor.IActorRef)">
            <summary>
                Resumes the children.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.TryGetChildStatsByName(System.String,Akka.Actor.Internal.IChildStats@)">
            <summary>
            Tries to get the stats for the child with the specified name. The stats can be either <see cref="T:Akka.Actor.Internal.ChildNameReserved"/> 
            indicating that only a name has been reserved for the child, or a <see cref="T:Akka.Actor.Internal.ChildRestartStats"/> for a child that 
            has been initialized/created.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.TryGetChildRestartStatsByName(System.String,Akka.Actor.Internal.ChildRestartStats@)">
            <summary>
            Tries to get the stats for the child with the specified name. This ignores children for whom only names have been reserved.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.TryGetChildStatsByRef(Akka.Actor.IActorRef,Akka.Actor.Internal.ChildRestartStats@)">
            <summary>
            Tries to get the stats for the specified child.
            <remarks>Since the child exists <see cref="T:Akka.Actor.Internal.ChildRestartStats"/> is the only valid <see cref="T:Akka.Actor.Internal.IChildStats"/>.</remarks>
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorCell.ActorType">
            <summary>
                Gets the type of the actor.
            </summary>
            <value>The type of the actor.</value>
        </member>
        <member name="T:Akka.Actor.IActorRefScope">
            <summary>
            All ActorRefs have a scope which describes where they live. Since it is often
            necessary to distinguish between local and non-local references, this is the only
            method provided on the scope.
            INTERNAL
            </summary>
        </member>
        <member name="M:Akka.Actor.IInternalActorRef.GetChild(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Obtain a child given the paths element to that actor, by possibly traversing the actor tree or 
            looking it up at some provider-specific location. 
            A path element of ".." signifies the parent, a trailing "" element must be disregarded. 
            If the requested path does not exist, returns <see cref="T:Akka.Actor.Nobody"/>.
            </summary>
            <param name="name">The path elements.</param>
            <returns>The <see cref="T:Akka.Actor.IActorRef"/>, or if the requested path does not exist, returns <see cref="T:Akka.Actor.Nobody"/>.</returns>
        </member>
        <member name="M:Akka.Actor.InternalActorRefBase.GetChild(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Obtain a child given the paths element to that actor, by possibly traversing the actor tree or 
            looking it up at some provider-specific location. 
            A path element of ".." signifies the parent, a trailing "" element must be disregarded. 
            If the requested path does not exist, returns <see cref="T:Akka.Actor.Nobody"/>.
            </summary>
            <param name="name">The path elements.</param>
            <returns>The <see cref="T:Akka.Actor.IActorRef"/>, or if the requested path does not exist, returns <see cref="T:Akka.Actor.Nobody"/>.</returns>
        </member>
        <member name="T:Akka.Actor.ILocalRef">
            <summary>
            Marker interface for Actors that are deployed within local scope, 
            i.e. <see cref="P:Akka.Actor.IActorRefScope.IsLocal"/> always returns <c>true</c>.
            </summary>
        </member>
        <member name="T:Akka.Actor.IActorProducerPlugin">
            <summary>
            Plugin interface used to define
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorProducerPlugin.CanBeAppliedTo(System.Type)">
            <summary>
            Determines if current plugin can be applied to provided actor based on it's type.
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorProducerPlugin.AfterIncarnated(Akka.Actor.ActorBase,Akka.Actor.IActorContext)">
            <summary>
            Plugin behavior applied to underlying <paramref name="actor"/> instance when the new one is being created.
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorProducerPlugin.BeforeIncarnated(Akka.Actor.ActorBase,Akka.Actor.IActorContext)">
            <summary>
            Plugin behavior applied to underlying <paramref name="actor"/> instance before the actor is being recycled.
            </summary>
        </member>
        <member name="T:Akka.Actor.ActorProducerPluginBase">
            <summary>
            Base actor producer pipeline plugin class.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorProducerPluginBase.CanBeAppliedTo(System.Type)">
            <summary>
            By default derivatives of this plugin will be applied to all actors.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorProducerPluginBase.AfterIncarnated(Akka.Actor.ActorBase,Akka.Actor.IActorContext)">
            <summary>
            Plugin behavior applied to <paramref name="actor"/> instance when the new one is being created.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorProducerPluginBase.BeforeIncarnated(Akka.Actor.ActorBase,Akka.Actor.IActorContext)">
            <summary>
            Plugin behavior applied to <paramref name="actor"/> instance before the actor is being recycled.
            </summary>
        </member>
        <member name="T:Akka.Actor.ActorProducerPluginBase`1">
            <summary>
            Base generic actor producer pipeline plugin class.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorProducerPluginBase`1.CanBeAppliedTo(System.Type)">
            <summary>
            By default derivatives of this plugin will be applied to all actors inheriting from <typeparam name="TActor">actor generic type</typeparam>.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorProducerPluginBase`1.AfterIncarnated(`0,Akka.Actor.IActorContext)">
            <summary>
            Plugin behavior applied to <paramref name="actor"/> instance when the new one is being created.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorProducerPluginBase`1.BeforeIncarnated(`0,Akka.Actor.IActorContext)">
            <summary>
            Plugin behavior applied to <paramref name="actor"/> instance before the actor is being recycled.
            </summary>
        </member>
        <member name="T:Akka.Actor.ActorProducerPipelineResolver">
            <summary>
            Class used to resolving actor producer pipelines depending on actor type.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorProducerPipelineResolver.Register(Akka.Actor.IActorProducerPlugin)">
            <summary>
            Register target <paramref name="plugin"/> at the end of producer pipeline.
            </summary>
            <returns>True if plugin was registered (it has not been found in pipeline already). False otherwise. </returns>
        </member>
        <member name="M:Akka.Actor.ActorProducerPipelineResolver.Insert(System.Int32,Akka.Actor.IActorProducerPlugin)">
            <summary>
            Register target <paramref name="plugin"/> inside producer pipeline at specified <paramref name="index"/>.
            </summary>
            <returns>True if plugin was registered (it has not been found in pipeline already). False otherwise. </returns>
        </member>
        <member name="M:Akka.Actor.ActorProducerPipelineResolver.Unregister(Akka.Actor.IActorProducerPlugin)">
            <summary>
            Unregisters plugin from producer pipeline, returning false if plugin was not found.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorProducerPipelineResolver.IsRegistered(Akka.Actor.IActorProducerPlugin)">
            <summary>
            Returns true if current actor producer pipeline already has registered provided plugin type.
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorProducerPipelineResolver.TotalPluginCount">
            <summary>
            Gets total number of unique plugins registered inside current resolver.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorProducerPipeline.AfterActorIncarnated(Akka.Actor.ActorBase,Akka.Actor.IActorContext)">
            <summary>
            Resolves and applies all plugins valid to specified underlying <paramref name="actor"/> 
            registered in current producer pipeline to newly created actor.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorProducerPipeline.BeforeActorIncarnated(Akka.Actor.ActorBase,Akka.Actor.IActorContext)">
            <summary>
            Resolves and applies all plugins valid to specified underlying <paramref name="actor"/> 
            registered in current producer pipeline before old actor would be recycled.
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.ChildRestartStats">
            <summary>
            ChildRestartStats is the statistics kept by every parent Actor for every child Actor
            and is used for SupervisorStrategies to know how to deal with problems that occur for the children.
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.EmptyChildrenContainer">
            <summary>
            This is the empty container, shared among all leaf actors.
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.NormalChildrenContainer">
            <summary>
            Normal children container: we do have at least one child, but none of our
            children are currently terminating (which is the time period between calling
            context.stop(child) and processing the ChildTerminated() system message).
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.SuspendReason">
            <summary>
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.SuspendReason.IWaitingForChildren">
            <summary>
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.SuspendReason.Creation">
            <summary>
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.SuspendReason.Recreation">
            <summary>
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.SuspendReason.Termination">
            <summary>
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.SuspendReason.UserRequest">
            <summary>
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.TerminatedChildrenContainer">
            <summary>
            This is the empty container which is installed after the last child has
            terminated while stopping; it is necessary to distinguish from the normal
            empty state while calling handleChildTerminated() for the last time.
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.TerminatingChildrenContainer">
            <summary>
            Waiting state: there are outstanding termination requests (i.e. context.stop(child)
            was called but the corresponding ChildTerminated() system message has not yet been
            processed). There could be no specific reason (UserRequested), we could be Restarting
            or Terminating.
            Removing the last child which was supposed to be terminating will return a different
            type of container, depending on whether or not children are left and whether or not
            the reason was “Terminating”.
            </summary>
        </member>
        <member name="T:Akka.Actor.AlreadyCanceledCancelable">
            <summary>
            A <see cref="T:Akka.Actor.ICancelable"/> that is already canceled.
            </summary>
        </member>
        <member name="T:Akka.Actor.ICancelable">
            <summary>
            Signifies something that can be canceled
            </summary>
        </member>
        <member name="M:Akka.Actor.ICancelable.Cancel">
            <summary>
            Communicates a request for cancellation.
            </summary>
            <remarks>The associated cancelable will be notified of the cancellation and will transition to a state where 
            <see cref="P:Akka.Actor.ICancelable.IsCancellationRequested"/> returns <c>true</c>.
            Any callbacks or cancelable operations registered with the cancelable will be executed.
            Cancelable operations and callbacks registered with the token should not throw exceptions.
            However, this overload of Cancel will aggregate any exceptions thrown into an 
            <see cref="T:System.AggregateException"/>, such that one callback throwing an exception will not 
            prevent other registered callbacks from being executed.
            The <see cref="T:System.Threading.ExecutionContext"/> that was captured when each callback was registered will 
            be reestablished when the callback is invoked.</remarks>
        </member>
        <member name="M:Akka.Actor.ICancelable.CancelAfter(System.TimeSpan)">
            <summary>
            Schedules a cancel operation on this cancelable after the specified delay.
            </summary>
            <param name="delay">The delay before this instance is canceled.</param>
        </member>
        <member name="M:Akka.Actor.ICancelable.CancelAfter(System.Int32)">
            <summary>
            Schedules a cancel operation on this cancelable after the specified number of milliseconds.
            </summary>
            <param name="millisecondsDelay">The delay in milliseconds before this instance is canceled.</param>
        </member>
        <member name="M:Akka.Actor.ICancelable.Cancel(System.Boolean)">
            <summary>
            Communicates a request for cancellation, and specifies whether remaining callbacks and cancelable operations should be processed.
            </summary>
            <param name="throwOnFirstException"><c>true</c> if exceptions should immediately propagate; otherwise, <c>false</c>.</param>
            <remarks>The associated cancelable will be notified of the cancellation and will transition to a state where 
            <see cref="P:Akka.Actor.ICancelable.IsCancellationRequested"/> returns <c>true</c>.
            Any callbacks or cancelable operations registered with the cancelable will be executed.
            Cancelable operations and callbacks registered with the token should not throw exceptions.
            If <paramref name="throwOnFirstException"/> is <c>true</c>, an exception will immediately propagate out of 
            the call to Cancel, preventing the remaining callbacks and cancelable operations from being processed.
            If <paramref name="throwOnFirstException"/> is <c>false</c>, this overload will aggregate any exceptions 
            thrown into an <see cref="T:System.AggregateException"/>, such that one callback throwing an exception will not 
            prevent other registered callbacks from being executed.
            The <see cref="T:System.Threading.ExecutionContext"/> that was captured when each callback was registered will be reestablished when the callback is invoked.</remarks>
        </member>
        <member name="P:Akka.Actor.ICancelable.IsCancellationRequested">
            <summary>
            Gets a value indicating whether cancellation has been requested
            </summary>
        </member>
        <member name="M:Akka.Actor.CancelableExtensions.CancelIfNotNull(Akka.Actor.ICancelable)">
            <summary>
            If <paramref name="cancelable"/> is not <c>null</c> it's canceled.
            </summary>
            <param name="cancelable">The cancelable. Will be canceled if it's not <c>null</c></param>
        </member>
        <member name="T:Akka.Actor.Cancelable">
            <summary>
            A <see cref="T:Akka.Actor.ICancelable"/> that wraps a <see cref="T:System.Threading.CancellationTokenSource"/>. 
            When canceling this instance the underlying <see cref="T:System.Threading.CancellationTokenSource"/> is canceled as well.
            </summary>
        </member>
        <member name="M:Akka.Actor.Cancelable.#ctor(Akka.Actor.IActionScheduler,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Cancelable"/> class that will be cancelled after the specified amount of time.
            </summary>
            <param name="scheduler">The scheduler.</param>
            <param name="delay">The delay before the cancelable is canceled.</param>
        </member>
        <member name="M:Akka.Actor.Cancelable.#ctor(Akka.Actor.IScheduler,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Cancelable"/> class that will be cancelled after the specified amount of time.
            </summary>
            <param name="scheduler">The scheduler.</param>
            <param name="delay">The delay before the cancelable is canceled.</param>
        </member>
        <member name="M:Akka.Actor.Cancelable.#ctor(Akka.Actor.IScheduler,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Cancelable"/> class that will be cancelled after the specified amount of milliseconds.
            </summary>
            <param name="scheduler">The scheduler.</param>
            <param name="millisecondsDelay">The delay in milliseconds.</param>
        </member>
        <member name="M:Akka.Actor.Cancelable.#ctor(Akka.Actor.IScheduler)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Cancelable"/> class.
            </summary>
            <param name="scheduler"></param>
        </member>
        <member name="M:Akka.Actor.Cancelable.#ctor(Akka.Actor.IActionScheduler)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Cancelable"/> class.
            </summary>
            <param name="scheduler"></param>
        </member>
        <member name="M:Akka.Actor.Cancelable.CreateCanceled">
            <summary>
            Returns a <see cref="T:Akka.Actor.ICancelable"/> that has already been canceled.
            </summary>
        </member>
        <member name="M:Akka.Actor.Cancelable.CreateLinkedCancelable(Akka.Actor.IScheduler,Akka.Actor.ICancelable[])">
            <summary>
            Creates a <see cref="T:Akka.Actor.ICancelable"/> that will be in the canceled state
            when any of the source cancelables are in the canceled state. 
            </summary>
            <param name="scheduler">The scheduler</param>
            <param name="cancelables">The cancelables instances to observe.</param>
            <returns>A new <see cref="T:Akka.Actor.ICancelable"/> that is linked to the source .</returns>
        </member>
        <member name="M:Akka.Actor.Cancelable.CreateLinkedCancelable(Akka.Actor.IActionScheduler,Akka.Actor.ICancelable[])">
            <summary>
            Creates a <see cref="T:Akka.Actor.ICancelable"/> that will be in the canceled state
            when any of the source cancelables are in the canceled state. 
            </summary>
            <param name="scheduler">The scheduler</param>
            <param name="cancelables">The cancelables instances to observe.</param>
            <returns>A new <see cref="T:Akka.Actor.ICancelable"/> that is linked to the source .</returns>
        </member>
        <member name="M:Akka.Actor.Cancelable.Dispose">
            <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
        </member>
        <member name="M:Akka.Actor.Cancelable.Dispose(System.Boolean)">
            <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
            <param name="disposing">if set to <c>true</c> the method has been called directly or indirectly by a 
            user's code. Managed and unmanaged resources will be disposed.<br />
            if set to <c>false</c> the method has been called by the runtime from inside the finalizer and only 
            unmanaged resources can be disposed.</param>
        </member>
        <member name="M:Akka.Actor.Dsl.IActorDsl.Become(System.Action{System.Object,Akka.Actor.IActorContext})">
            <summary>
            Changes the actor's behavior and replaces the current handler with the specified handler.
            </summary>
        </member>
        <member name="M:Akka.Actor.Dsl.IActorDsl.BecomeStacked(System.Action{System.Object,Akka.Actor.IActorContext})">
            <summary>
            Changes the actor's behavior and replaces the current handler with the specified handler without discarding the current.
            The current handler is stored on a stack, and you can revert to it by calling <see cref="M:Akka.Actor.Dsl.IActorDsl.UnbecomeStacked"/>
            <remarks>Please note, that in order to not leak memory, make sure every call to <see cref="M:Akka.Actor.Dsl.IActorDsl.BecomeStacked(System.Action{System.Object,Akka.Actor.IActorContext})"/>
            is matched with a call to <see cref="M:Akka.Actor.Dsl.IActorDsl.UnbecomeStacked"/>.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.Dsl.IActorDsl.UnbecomeStacked">
            <summary>
            Changes the actor's behavior and replaces the current handler with the previous one on the behavior stack.
            <remarks>In order to store an actor on the behavior stack, a call to <see cref="M:Akka.Actor.Dsl.IActorDsl.BecomeStacked(System.Action{System.Object,Akka.Actor.IActorContext})"/> must have been made
            prior to this call</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.UntypedActor">
            <summary>
            Class UntypedActor.
            </summary>
        </member>
        <member name="T:Akka.Actor.ActorBase">
            <summary>
                Class ActorBase.
            </summary>
            <summary>
                Class ActorBase.
            </summary>
        </member>
        <member name="T:Akka.Actor.IInternalActor">
            <summary>
            Contains things needed by the framework
            </summary>
        </member>
        <member name="P:Akka.Actor.IInternalActor.ActorContext">
            <summary>Gets the context for this instance.</summary>
            <value>The context.</value>
            <exception cref="T:System.NotSupportedException">
            There is no active Context, this is most likely due to use of async
            operations from within this actor.
            </exception>
        </member>
        <member name="M:Akka.Actor.ActorBase.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.ActorBase"/> class.
            </summary>
            <exception cref="T:System.Exception">Do not create actors using 'new', always create them using an ActorContext/System</exception>
        </member>
        <member name="M:Akka.Actor.ActorBase.Receive(System.Object)">
            <summary>
                Processor for user defined messages.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Akka.Actor.ActorBase.Unhandled(System.Object)">
            <summary>
            Is called when a message isn't handled by the current behavior of the actor
            by default it fails with either a <see cref="T:Akka.Actor.DeathPactException"/> (in
            case of an unhandled <see cref="T:Akka.Actor.Terminated"/> message) or publishes an <see cref="T:Akka.Event.UnhandledMessage"/>
            to the actor's system's <see cref="T:Akka.Event.EventStream"/>
            </summary>
            <param name="message">The unhandled message.</param>
        </member>
        <member name="M:Akka.Actor.ActorBase.Become(Akka.Actor.Receive)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            </summary>
            <param name="receive">The new message handler.</param>
        </member>
        <member name="M:Akka.Actor.ActorBase.BecomeStacked(Akka.Actor.Receive)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            The current handler is stored on a stack, and you can revert to it by calling <see cref="M:Akka.Actor.IActorContext.UnbecomeStacked"/>
            <remarks>Please note, that in order to not leak memory, make sure every call to <see cref="M:Akka.Actor.ActorBase.BecomeStacked(Akka.Actor.Receive)"/>
            is matched with a call to <see cref="M:Akka.Actor.IActorContext.UnbecomeStacked"/>.</remarks>
            </summary>
            <param name="receive">The new message handler.</param>
        </member>
        <member name="M:Akka.Actor.ActorBase.UnbecomeStacked">
            <summary>
            Reverts the Actor behavior to the previous one on the behavior stack.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorBase.SetReceiveTimeout(System.Nullable{System.TimeSpan})">
            <summary>
            <para>
            Defines the inactivity timeout after which the sending of a <see cref="T:Akka.Actor.ReceiveTimeout"/> message is triggered.
            When specified, the receive function should be able to handle a <see cref="T:Akka.Actor.ReceiveTimeout"/> message.
            </para>
            
            <para>
            Please note that the receive timeout might fire and enqueue the <see cref="T:Akka.Actor.ReceiveTimeout"/> message right after
            another message was enqueued; hence it is not guaranteed that upon reception of the receive
            timeout there must have been an idle period beforehand as configured via this method.
            </para>
            
            <para>
            Once set, the receive timeout stays in effect (i.e. continues firing repeatedly after inactivity
            periods). Pass in <c>null</c> to switch off this feature.
            </para>
            </summary>
            <param name="timeout">The timeout. Pass in <c>null</c> to switch off this feature.</param>
        </member>
        <member name="M:Akka.Actor.ActorBase.AroundPreRestart(System.Exception,System.Object)">
            <summary>
                Can be overridden to intercept calls to `preRestart`. Calls `preRestart` by default.
            </summary>
            <param name="cause">The cause.</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:Akka.Actor.ActorBase.AroundPreStart">
            <summary>
                Can be overridden to intercept calls to `preStart`. Calls `preStart` by default.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorBase.PreStart">
            <summary>
                User overridable callback.
                <p />
                Is called when an Actor is started.
                Actors are automatically started asynchronously when created.
                Empty default implementation.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorBase.AroundPostRestart(System.Exception,System.Object)">
            <summary>
                Can be overridden to intercept calls to `postRestart`. Calls `postRestart` by default.
            </summary>
            <param name="cause">The cause.</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:Akka.Actor.ActorBase.PreRestart(System.Exception,System.Object)">
            <summary>
                User overridable callback: '''By default it disposes of all children and then calls `postStop()`.'''
                <p />
                Is called on a crashed Actor right BEFORE it is restarted to allow clean
                up of resources before Actor is terminated.
            </summary>
            <param name="reason">the Exception that caused the restart to happen.</param>
            <param name="message">optionally the current message the actor processed when failing, if applicable.</param>
        </member>
        <member name="M:Akka.Actor.ActorBase.PostRestart(System.Exception)">
            <summary>
                User overridable callback: By default it calls `preStart()`.
                <p />
                Is called right AFTER restart on the newly created Actor to allow reinitialization after an Actor crash.
            </summary>
            <param name="reason">the Exception that caused the restart to happen.</param>
        </member>
        <member name="M:Akka.Actor.ActorBase.AroundPostStop">
            <summary>
                Can be overridden to intercept calls to `postStop`. Calls `postStop` by default..
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorBase.PostStop">
            <summary>
                User overridable callback.
                <p />
                Is called asynchronously after 'actor.stop()' is invoked.
                Empty default implementation.
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorBase.Sender">
            <summary>
                Gets the sending ActorRef of the current message
            </summary>
            <value>The sender ActorRef</value>
        </member>
        <member name="P:Akka.Actor.ActorBase.Self">
            <summary>
                Gets the self ActorRef
            </summary>
            <value>Self ActorRef</value>
        </member>
        <member name="P:Akka.Actor.ActorBase.Akka#Actor#IInternalActor#ActorContext">
            <summary>
                Gets the context.
            </summary>
            <value>The context.</value>
            <exception cref="T:System.NotSupportedException">
                There is no active ActorContext, this is most likely due to use of async
                operations from within this actor.
            </exception>
        </member>
        <member name="P:Akka.Actor.ActorBase.Context">
            <summary>
                Gets the context.
            </summary>
            <value>The context.</value>
            <exception cref="T:System.NotSupportedException">
                There is no active Context, this is most likely due to use of async
                operations from within this actor.
            </exception>
        </member>
        <member name="P:Akka.Actor.ActorBase.EmptyReceive">
            <summary>
            EmptyReceive is a Receive-delegate that matches no messages at all, ever.
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorBase.SupervisorStrategyInternal">
            <summary>
            Gets or sets a <see cref="M:Akka.Actor.ActorBase.SupervisorStrategy"/>.
            When getting, if a previously <see cref="M:Akka.Actor.ActorBase.SupervisorStrategy"/> has been set it's returned; otherwise calls
            <see cref="M:Akka.Actor.ActorBase.SupervisorStrategy">SupervisorStrategy()</see>, stores and returns it.
            </summary>
        </member>
        <member name="M:Akka.Actor.UntypedActor.OnReceive(System.Object)">
            <summary>
            To be implemented by concrete UntypedActor, this defines the behavior of the UntypedActor.
            This method is called for every message received by the actor.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Akka.Actor.UntypedActor.Become(Akka.Actor.UntypedReceive)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            </summary>
            <param name="receive">The new message handler.</param>
        </member>
        <member name="M:Akka.Actor.UntypedActor.BecomeStacked(Akka.Actor.UntypedReceive)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            The current handler is stored on a stack, and you can revert to it by calling <see cref="!:IUntypedActorContext.UnbecomeStacked"/>
            <remarks>Please note, that in order to not leak memory, make sure every call to <see cref="M:Akka.Actor.UntypedActor.BecomeStacked(Akka.Actor.UntypedReceive)"/>
            is matched with a call to <see cref="!:IUntypedActorContext.UnbecomeStacked"/>.</remarks>
            </summary>
            <param name="receive">The new message handler.</param>
        </member>
        <member name="T:Akka.Actor.Internals.IInitializableActor">
            <summary>
            Marks that the actor needs to be initialized directly after it has been created.
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.PrepareConfigureMessageHandlers">
            <summary>
            Creates and pushes a new MatchBuilder
            </summary>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.Become(System.Action)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            </summary>
            <param name="configure">Configures the new handler by calling the different Receive overloads.</param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            The current handler is stored on a stack, and you can revert to it by calling <see cref="M:Akka.Actor.ActorBase.UnbecomeStacked"/>
            <remarks>Please note, that in order to not leak memory, make sure every call to <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>
            is matched with a call to <see cref="M:Akka.Actor.ActorBase.UnbecomeStacked"/>.</remarks>
            </summary>
            <param name="configure">Configures the new handler by calling the different Receive overloads.</param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.Receive``1(System.Action{``0},System.Predicate{``0})">
            <summary>
            Registers a handler for incoming messages of the specified type <typeparamref name="T"/>.
            If <paramref name="shouldHandle"/>!=<c>null</c> then it must return true before a message is passed to <paramref name="handler"/>.        
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <typeparam name="T">The type of the message</typeparam>
            <param name="handler">The message handler that is invoked for incoming messages of the specified type <typeparamref name="T"/></param>
            <param name="shouldHandle">When not <c>null</c> it is used to determine if the message matches.</param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.Receive``1(System.Predicate{``0},System.Action{``0})">
            <summary>
            Registers a handler for incoming messages of the specified type <typeparamref name="T"/>.
            If <paramref name="shouldHandle"/>!=<c>null</c> then it must return true before a message is passed to <paramref name="handler"/>.        
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <typeparam name="T">The type of the message</typeparam>
            <param name="handler">The message handler that is invoked for incoming messages of the specified type <typeparamref name="T"/></param>
            <param name="shouldHandle">When not <c>null</c> it is used to determine if the message matches.</param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.Receive(System.Type,System.Action{System.Object},System.Predicate{System.Object})">
            <summary>
            Registers a handler for incoming messages of the specified <see cref="!:messageType"/>.
            If <paramref name="shouldHandle"/>!=<c>null</c> then it must return true before a message is passed to <paramref name="handler"/>.        
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <param name="messageType">The type of the message</param>
            <param name="handler">The message handler that is invoked for incoming messages of the specified <see cref="!:messageType"/></param>
            <param name="shouldHandle">When not <c>null</c> it is used to determine if the message matches.</param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.Receive(System.Type,System.Predicate{System.Object},System.Action{System.Object})">
            <summary>
            Registers a handler for incoming messages of the specified <see cref="!:messageType"/>.
            If <paramref name="shouldHandle"/>!=<c>null</c> then it must return true before a message is passed to <paramref name="handler"/>.        
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <param name="messageType">The type of the message</param>
            <param name="handler">The message handler that is invoked for incoming messages of the specified <see cref="!:messageType"/></param>
            <param name="shouldHandle">When not <c>null</c> it is used to determine if the message matches.</param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.Receive``1(System.Func{``0,System.Boolean})">
            <summary>
            Registers a handler for incoming messages of the specified type <typeparamref name="T"/>.
            The handler should return <c>true</c> if it has handled the message. 
            If the handler returns true no more handlers will be tried; otherwise the next registered handler will be tried.
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <typeparam name="T">The type of the message</typeparam>
            <param name="handler">The message handler that is invoked for incoming messages of the 
            specified type <typeparamref name="T"/>. It should return <c>true</c>if it handled/matched 
            the message; <c>false</c> otherwise.</param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.Receive(System.Type,System.Func{System.Object,System.Boolean})">
            <summary>
            Registers a handler for incoming messages of the specified <see cref="!:messageType"/>.
            The handler should return <c>true</c> if it has handled the message. 
            If the handler returns true no more handlers will be tried; otherwise the next registered handler will be tried.
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <param name="messageType">The type of the message</param>
            <param name="handler">The message handler that is invoked for incoming messages of the 
            specified type <see cref="!:messageType"/>. It should return <c>true</c>if it handled/matched 
            the message; <c>false</c> otherwise.</param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.ReceiveAny(System.Action{System.Object})">
            <summary>
            Registers a handler for incoming messages of any type.
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <param name="handler">The message handler that is invoked for all</param>
        </member>
        <member name="T:Akka.Actor.Internal.InternalCurrentActorCellKeeper">
            <summary>INTERNAL!
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="P:Akka.Actor.Internal.InternalCurrentActorCellKeeper.Current">
            <summary>INTERNAL!
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.IInternalSupportsTestFSMRef`2">
            <summary>
            INTERNAL API. Used for testing.
            This is used to let TestFSMRef in TestKit access to internal methods.
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.IInternalSupportsTestFSMRef`2.ApplyState(Akka.Actor.FSMBase.State{`0,`1})">
            <summary>
            INTERNAL API. Used for testing.
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="P:Akka.Actor.Internal.IInternalSupportsTestFSMRef`2.IsStateTimerActive">
            <summary>
            INTERNAL API. Used for testing.
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.InternalActivateFsmLogging">
            <summary>
            INTERNAL API. Used for testing.
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="P:Akka.Actor.Internal.InternalActivateFsmLogging.Instance">
            <summary>
            INTERNAL API. Used for testing.
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="P:Akka.Actor.ITimeProvider.Now">
            <summary>
            Gets the scheduler's notion of current time.
            </summary>
        </member>
        <member name="T:Akka.Actor.IDateTimeOffsetNowTimeProvider">
            <summary>
            Marks that an <see cref="T:Akka.Actor.ITimeProvider"/> uses <see cref="P:System.DateTimeOffset.UtcNow"/>, 
            i.e. system time, to provide <see cref="P:Akka.Actor.ITimeProvider.Now"/>.
            </summary>
        </member>
        <member name="T:Akka.Actor.IActionScheduler">
            <summary>
            A scheduler able of scheduling actions
            </summary>
        </member>
        <member name="M:Akka.Actor.IActionScheduler.ScheduleOnce(System.TimeSpan,System.Action,Akka.Actor.ICancelable)">
            <summary>
            Schedules an action to be invoked after an delay.
            The action will be wrapped so that it completes inside the currently active actor if it is called from within an actor.
            <remarks>Note! It's considered bad practice to use concurrency inside actors, and very easy to get wrong so usage is discouraged.</remarks>
            </summary>
            <param name="delay">The time period that has to pass before the action is invoked.</param>
            <param name="action">The action to perform.</param>
            <param name="cancelable">A cancelable that can be used to cancel the action from being executed</param>
        </member>
        <member name="M:Akka.Actor.IActionScheduler.ScheduleOnce(System.TimeSpan,System.Action)">
            <summary>
            Schedules an action to be invoked after an delay.
            The action will be wrapped so that it completes inside the currently active actor if it is called from within an actor.
            <remarks>Note! It's considered bad practice to use concurrency inside actors, and very easy to get wrong so usage is discouraged.</remarks>
            </summary>
            <param name="delay">The time period that has to pass before the action is invoked.</param>
            <param name="action">The action to perform.</param>
        </member>
        <member name="M:Akka.Actor.IActionScheduler.ScheduleRepeatedly(System.TimeSpan,System.TimeSpan,System.Action,Akka.Actor.ICancelable)">
            <summary>
            Schedules an action to be invoked after an initial delay and then repeatedly.
            The action will be wrapped so that it completes inside the currently active actor if it is called from within an actor
            <remarks>Note! It's considered bad practice to use concurrency inside actors, and very easy to get wrong so usage is discouraged.</remarks>
            </summary>
            <param name="initialDelay">The time period that has to pass before first invocation.</param>
            <param name="interval">The interval, i.e. the time period that has to pass between the action is invoked.</param>
            <param name="action">The action to perform.</param>
            <param name="cancelable">A cancelable that can be used to cancel the action from being executed</param>
        </member>
        <member name="M:Akka.Actor.IActionScheduler.ScheduleRepeatedly(System.TimeSpan,System.TimeSpan,System.Action)">
            <summary>
            Schedules an action to be invoked after an initial delay and then repeatedly.
            The action will be wrapped so that it completes inside the currently active actor if it is called from within an actor
            <remarks>Note! It's considered bad practice to use concurrency inside actors, and very easy to get wrong so usage is discouraged.</remarks>
            </summary>
            <param name="initialDelay">The time period that has to pass before first invocation.</param>
            <param name="interval">The interval, i.e. the time period that has to pass between the action is invoked.</param>
            <param name="action">The action to perform.</param>
        </member>
        <member name="T:Akka.Actor.ITellScheduler">
            <summary>
            A scheduler that's able to schedule sending messages.
            </summary>
        </member>
        <member name="M:Akka.Actor.ITellScheduler.ScheduleTellOnce(System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef)">
            <summary>Schedules to send a message once after a specified period of time.</summary>
            <param name="delay">The time period that has to pass before the message is sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
        </member>
        <member name="M:Akka.Actor.ITellScheduler.ScheduleTellOnce(System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef,Akka.Actor.ICancelable)">
            <summary>Schedules to send a message once after a specified period of time.</summary>
            <param name="delay">The time period that has to pass before the message is sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <param name="cancelable">An <see cref="T:Akka.Actor.ICancelable"/> that can be used to cancel sending of the message. Once the message has been sent, it cannot be canceled.</param>
        </member>
        <member name="M:Akka.Actor.ITellScheduler.ScheduleTellRepeatedly(System.TimeSpan,System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef)">
            <summary>Schedules to send a message repeatedly. The first message will be sent after the specified initial delay and there after at the rate specified.</summary>
            <param name="initialDelay">The time period that has to pass before the first message is sent.</param>
            <param name="interval">The interval, i.e. the time period that has to pass between messages are being sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
        </member>
        <member name="M:Akka.Actor.ITellScheduler.ScheduleTellRepeatedly(System.TimeSpan,System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef,Akka.Actor.ICancelable)">
            <summary>Schedules to send a message repeatedly. The first message will be sent after the specified initial delay and there after at the rate specified.</summary>
            <param name="initialDelay">The time period that has to pass before the first message is sent.</param>
            <param name="interval">The interval, i.e. the time period that has to pass between messages are being sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <param name="cancelable">An <see cref="T:Akka.Actor.ICancelable"/> that can be used to cancel sending of the message. Once the message has been sent, it cannot be canceled.</param>
        </member>
        <member name="P:Akka.Actor.IScheduler.Advanced">
            <summary>
            Gets the advanced scheduler which will allow you to schedule actions. 
            <remarks>Note! It's considered bad practice to use concurrency inside actors and very easy to get wrong so usage is discouraged.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.Status">
            <summary>
            Classes for passing status back to the sender.
            Used for internal ACKing protocol, but also exposed as a utility class for user-specific ACKing if needed.
            </summary>
        </member>
        <member name="T:Akka.Actor.Status.Success">
            <summary>
            Indicates the success of some operation which has been performed
            </summary>
        </member>
        <member name="T:Akka.Actor.Status.Failure">
            <summary>
            Indicates the failure of some operation that was requested and includes an
            <see cref="T:System.Exception"/> describing the underlying cause of the problem.
            </summary>
        </member>
        <member name="T:Akka.Actor.ILogReceive">
            <summary>
                Interface ILogReceive
            </summary>
        </member>
        <member name="T:Akka.Actor.IActorLogging">
            <summary>
            Interface used on Actors that have an explicit requirement for a logger
            </summary>
        </member>
        <member name="T:Akka.Actor.ActorPath">
            <summary>
            Actor path is a unique path to an actor that shows the creation path
            up through the actor tree to the root actor.
            ActorPath defines a natural ordering (so that ActorRefs can be put into
            collections with this requirement); this ordering is intended to be as fast
            as possible, which owing to the bottom-up recursive nature of ActorPath
            is sorted by path elements FROM RIGHT TO LEFT, where RootActorPath >
            ChildActorPath in case the number of elements is different.
            Two actor paths are compared equal when they have the same name and parent
            elements, including the root address information. That does not necessarily
            mean that they point to the same incarnation of the actor if the actor is
            re-created with the same path. In other words, in contrast to how actor
            references are compared the unique id of the actor is not taken into account
            when comparing actor paths.
            </summary>
        </member>
        <member name="F:Akka.Actor.ActorPath.ValidSymbols">
            INTERNAL API 
        </member>
        <member name="M:Akka.Actor.ActorPath.IsValidPathElement(System.String)">
            <summary> 
            Method that checks if actor name conforms to RFC 2396, http://www.ietf.org/rfc/rfc2396.txt
            Note that AKKA JVM does not allow parenthesis ( ) but, according to RFC 2396 those are allowed, and 
            since we use URL Encode to create valid actor names, we must allow them.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorPath.#ctor(Akka.Actor.Address,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorPath"/> class.
            </summary>
            <param name="address"> The address. </param>
            <param name="name"> The name. </param>
        </member>
        <member name="M:Akka.Actor.ActorPath.#ctor(Akka.Actor.ActorPath,System.String,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorPath"/> class.
            </summary>
            <param name="parentPath"> The parent path. </param>
            <param name="name"> The name. </param>
            <param name="uid"> The uid. </param>
        </member>
        <member name="M:Akka.Actor.ActorPath.Equals(Akka.Actor.ActorPath)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other"> An object to compare with this object. </param>
            <returns> true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false. </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.WithUid(System.Int64)">
            <summary>
            Withes the uid.
            </summary>
            <param name="uid"> The uid. </param>
            <returns> ActorPath. </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.op_Division(Akka.Actor.ActorPath,System.String)">
            <summary>
            Create a new child actor path.
            </summary>
            <param name="path"> The path. </param>
            <param name="name"> The name. </param>
            <returns> The result of the operator. </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.op_Division(Akka.Actor.ActorPath,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Recursively create a descendant’s path by appending all child names.
            </summary>
            <param name="path"> The path. </param>
            <param name="name"> The name. </param>
            <returns> The result of the operator. </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.TryParse(System.String,Akka.Actor.ActorPath@)">
            <summary>
            Tries to parse the uri, which should be a full uri, i.e containing protocol.
            For example "akka://System/user/my-actor"
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorPath.Join">
            <summary>
            Joins this instance.
            </summary>
            <returns> System.String. </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.ToStringWithoutAddress">
            <summary>
            String representation of the path elements, excluding the address
            information. The elements are separated with "/" and starts with "/",
            e.g. "/user/a/b".
            </summary>
            <returns> System.String. </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns> A <see cref="T:System.String"/> that represents this instance. </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.ToStringWithUid">
            <summary>
            Returns a string representation of this instance including uid.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.Child(System.String)">
            <summary>
            Creates a child with the specified name
            </summary>
            <param name="childName"> Name of the child. </param>
            <returns> ActorPath. </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns> A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj"> The object to compare with the current object. </param>
            <returns>
            <c> true </c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise,
            <c> false </c>.
            </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.ToStringWithAddress">
            <summary>
            Generate String representation, with the address in the RootActorPath.
            </summary>
            <returns> System.String. </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.ToStringWithAddress(Akka.Actor.Address)">
            <summary>
            Generate String representation, replacing the Address in the RootActorPath
            with the given one unless this path’s address includes host and port
            information.
            </summary>
            <param name="address"> The address. </param>
            <returns> System.String. </returns>
        </member>
        <member name="P:Akka.Actor.ActorPath.Uid">
            <summary>
            Gets the uid.
            </summary>
            <value> The uid. </value>
        </member>
        <member name="P:Akka.Actor.ActorPath.Elements">
            <summary>
            Gets the elements.
            </summary>
            <value> The elements. </value>
        </member>
        <member name="P:Akka.Actor.ActorPath.Name">
            <summary>
            Gets the name.
            </summary>
            <value> The name. </value>
        </member>
        <member name="P:Akka.Actor.ActorPath.Address">
            <summary>
            The Address under which this path can be reached; walks up the tree to
            the RootActorPath.
            </summary>
            <value> The address. </value>
        </member>
        <member name="T:Akka.Actor.RootActorPath">
            <summary>
            Class RootActorPath.
            </summary>
        </member>
        <member name="M:Akka.Actor.RootActorPath.#ctor(Akka.Actor.Address,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.RootActorPath"/> class.
            </summary>
            <param name="address"> The address. </param>
            <param name="name"> The name. </param>
        </member>
        <member name="M:Akka.Actor.RootActorPath.WithUid(System.Int64)">
            <summary>
            Withes the uid.
            </summary>
            <param name="uid"> The uid. </param>
            <returns> ActorPath. </returns>
            <exception cref="T:System.NotSupportedException"> RootActorPath must have undefinedUid </exception>
        </member>
        <member name="T:Akka.Actor.ChildActorPath">
            <summary>
            Class ChildActorPath.
            </summary>
        </member>
        <member name="M:Akka.Actor.ChildActorPath.#ctor(Akka.Actor.ActorPath,System.String,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ChildActorPath"/> class.
            </summary>
            <param name="parentPath"> The parent path. </param>
            <param name="name"> The name. </param>
            <param name="uid"> The uid. </param>
        </member>
        <member name="M:Akka.Actor.ChildActorPath.WithUid(System.Int64)">
            <summary>
            Creates a copy of the given ActorPath and applies a new Uid
            </summary>
            <param name="uid"> The uid. </param>
            <returns> ActorPath. </returns>
        </member>
        <member name="T:Akka.Actor.IRepointableRef">
            <summary>
            RepointableActorRef (and potentially others) may change their locality at
            runtime, meaning that isLocal might not be stable. RepointableActorRef has
            the feature that it starts out “not fully started” (but you can send to it),
            which is why <see cref="!:IsSt"/> features here; it is not improbable that cluster
            actor refs will have the same behavior.
            INTERNAL
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorRefImplicitSenderExtensions.Forward(Akka.Actor.IActorRef,System.Object)">
            <summary>
            Forwards the message using the current Sender
            </summary>
            <param name="receiver">The actor that receives the forward</param>
            <param name="message">The message to forward</param>
        </member>
        <member name="T:Akka.Actor.Nobody">
            <summary> This is an internal look-up failure token, not useful for anything else.</summary>
        </member>
        <member name="T:Akka.Actor.VirtualPathContainer.Enumerable`1">
            <summary>
            An enumerable that continues where the supplied enumerator is positioned
            </summary>
        </member>
        <member name="T:Akka.Actor.ActorRefExtensions">
            <summary>
                An extension method class for working with ActorRefs
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorRefExtensions.IsNobody(Akka.Actor.IActorRef)">
            <summary>
                If we call a method such as <code>Context.Child(name)</code>
                and don't receive a valid result in return, this method will indicate
                whether or not the actor we received is valid.
            </summary>
        </member>
        <member name="T:Akka.Actor.ActorRefFactoryShared">
            <summary>
            This class contains implementations originally found in Akka´s trait ActorRefFactory in ActorRefProvider.scala
            https://github.com/akka/akka/blob/master/akka-actor/src/main/scala/akka/actor/ActorRefProvider.scala#L180
            <see cref="T:Akka.Actor.IActorRefFactory"/> corresponds to that trait, but since it is an interface it
            cannot contain any code, hence this class.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorRefFactoryShared.ActorSelection(Akka.Actor.ActorPath,Akka.Actor.ActorSystem)">
            <summary>
                Construct an <see cref="T:Akka.Actor.ActorSelection"/> from the given path, which is
                parsed for wildcards (these are replaced by regular expressions
                internally). No attempt is made to verify the existence of any part of
                the supplied path, it is recommended to send a message and gather the
                replies in order to resolve the matching set of actors.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorRefFactoryShared.ActorSelection(System.String,Akka.Actor.ActorSystem,Akka.Actor.IActorRef)">
            <summary>
                Construct an <see cref="T:Akka.Actor.ActorSelection"/> from the given path, which is
                parsed for wildcards (these are replaced by regular expressions
                internally). No attempt is made to verify the existence of any part of
                the supplied path, it is recommended to send a message and gather the
                replies in order to resolve the matching set of actors.
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorRefProvider.RootGuardianAt(Akka.Actor.Address)">
            <summary>Reference to the supervisor of guardian and systemGuardian at the specified address;
            this is exposed so that the ActorRefFactory can use it as lookupRoot, i.e.
            for anchoring absolute actor selections.
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorRefProvider.Init(Akka.Actor.Internals.ActorSystemImpl)">
            <summary>
            Initialization of an ActorRefProvider happens in two steps: first
            construction of the object with settings, eventStream, etc.
            and then—when the ActorSystem is constructed—the second phase during
            which actors may be created (e.g. the guardians).
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorRefProvider.TempPath">
            <summary>Generates and returns a unique actor path below "/temp".</summary>
        </member>
        <member name="M:Akka.Actor.IActorRefProvider.RegisterTempActor(Akka.Actor.IInternalActorRef,Akka.Actor.ActorPath)">
            <summary>Registers an actorRef at a path returned by <see cref="M:Akka.Actor.IActorRefProvider.TempPath"/>; do NOT pass in any other path.</summary>
            <param name="actorRef">The actor reference.</param>
            <param name="path">A path returned by <see cref="M:Akka.Actor.IActorRefProvider.TempPath"/>. Do NOT pass in any other path!</param>
        </member>
        <member name="M:Akka.Actor.IActorRefProvider.UnregisterTempActor(Akka.Actor.ActorPath)">
            <summary>Unregister a temporary actor (i.e. obtained from <see cref="M:Akka.Actor.IActorRefProvider.TempPath"/>); do NOT pass in any other path.</summary>
            <param name="path">A path returned by <see cref="M:Akka.Actor.IActorRefProvider.TempPath"/>. Do NOT pass in any other path!</param>
        </member>
        <member name="M:Akka.Actor.IActorRefProvider.ActorOf(Akka.Actor.Internals.ActorSystemImpl,Akka.Actor.Props,Akka.Actor.IInternalActorRef,Akka.Actor.ActorPath,System.Boolean,Akka.Actor.Deploy,System.Boolean,System.Boolean)">
            <summary>
            Actor factory with create-only semantics: will create an actor as
            described by <paramref name="props"/> with the given <paramref name="supervisor"/> and <paramref name="path"/> (may be different
            in case of remote supervision). If <paramref name="systemService"/> is true, deployment is
            bypassed (local-only). If a value for<paramref name="deploy"/> is passed in, it should be
            regarded as taking precedence over the nominally applicable settings,
            but it should be overridable from external configuration; the lookup of
            the latter can be suppressed by setting "lookupDeploy" to "false".
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorRefProvider.ResolveActorRef(System.String)">
            <summary>Get the actor reference for a specified path. If no such actor exists, it will be (equivalent to) a dead letter reference.</summary>
        </member>
        <member name="M:Akka.Actor.IActorRefProvider.ResolveActorRef(Akka.Actor.ActorPath)">
            <summary>Get the actor reference for a specified path. If no such actor exists, it will be (equivalent to) a dead letter reference.</summary>
        </member>
        <member name="M:Akka.Actor.IActorRefProvider.GetExternalAddressFor(Akka.Actor.Address)">
            <summary>
            Obtain the address which is to be used within sender references when
            sending to the given other address or none if the other address cannot be
            reached from this system (i.e. no means of communication known; no
            attempt is made to verify actual reachability).
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.RootGuardian">
            <summary>
            Reference to the supervisor of guardian and systemGuardian; this is
            exposed so that the ActorSystemImpl can use it as lookupRoot, i.e.
            for anchoring absolute actor look-ups.
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.Guardian">
            <summary> Gets the supervisor used for all top-level user actors.</summary>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.SystemGuardian">
            <summary>Gets the supervisor used for all top-level system actors.</summary>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.DeadLetters">
            <summary>Gets the dead letters.</summary>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.RootPath">
            <summary>
            Gets the root path for all actors within this actor system, not including any remote address information.
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.Settings">
            <summary>Gets the settings.</summary>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.Deployer">
            <summary>Gets the deployer.</summary>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.TempContainer">
            <summary>Returns the actor reference representing the "/temp" path.</summary>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.TerminationTask">
            <summary>
            This Future is completed upon termination of this <see cref="T:Akka.Actor.IActorRefProvider"/>, which
            is usually initiated by stopping the guardian via <see cref="M:Akka.Actor.ActorSystem.Stop(Akka.Actor.IActorRef)"/>.
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.DefaultAddress">
            <summary>Gets the external address of the default transport. </summary>
        </member>
        <member name="T:Akka.Actor.LocalActorRefProvider">
            <summary>
                Class LocalActorRefProvider. This class cannot be inherited.
            </summary>
        </member>
        <member name="M:Akka.Actor.LocalActorRefProvider.RegisterExtraName(System.String,Akka.Actor.IInternalActorRef)">
            <summary>
            Higher-level providers (or extensions) might want to register new synthetic
            top-level paths for doing special stuff. This is the way to do just that.
            Just be careful to complete all this before <see cref="!:ActorSystem.Start"/> finishes,
            or before you start your own auto-spawned actors.
            </summary>
        </member>
        <member name="M:Akka.Actor.LocalActorRefProvider.ResolveActorRef(Akka.Actor.ActorPath)">
            <summary>
                Resolves the actor reference.
            </summary>
            <param name="path">The actor path.</param>
            <returns>ActorRef.</returns>
            <exception cref="T:System.NotSupportedException">The provided actor path is not valid in the LocalActorRefProvider</exception>
        </member>
        <member name="T:Akka.Actor.ActorSelection">
            <summary>
                Class ActorSelection.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSelection.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.ActorSelection"/> class.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSelection.#ctor(Akka.Actor.IActorRef,Akka.Actor.SelectionPathElement[])">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.ActorSelection"/> class.
            </summary>
            <param name="anchor">The anchor.</param>
            <param name="path">The path.</param>
        </member>
        <member name="M:Akka.Actor.ActorSelection.#ctor(Akka.Actor.IActorRef,System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.ActorSelection"/> class.
            </summary>
            <param name="anchor">The anchor.</param>
            <param name="path">The path.</param>
        </member>
        <member name="M:Akka.Actor.ActorSelection.#ctor(Akka.Actor.IActorRef,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.ActorSelection"/> class.
            </summary>
            <param name="anchor">The anchor.</param>
            <param name="elements">The elements.</param>
        </member>
        <member name="M:Akka.Actor.ActorSelection.Tell(System.Object,Akka.Actor.IActorRef)">
            <summary>
                Posts a message to this ActorSelection.
            </summary>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
        </member>
        <member name="M:Akka.Actor.ActorSelection.Tell(System.Object)">
            <summary>
                Posts a message to this ActorSelection.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Akka.Actor.ActorSelection.Deliver(System.Object,Akka.Actor.IActorRef,System.Int32,Akka.Actor.IActorRef)">
            <summary>
                Delivers the specified message.
            </summary>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <param name="pathIndex">Index of the path.</param>
            <param name="current">The current.</param>
        </member>
        <member name="M:Akka.Actor.ActorSelection.DeliverSelection(Akka.Actor.IInternalActorRef,Akka.Actor.IActorRef,Akka.Actor.ActorSelectionMessage)">
            <summary>
                INTERNAL API
                Convenience method used by remoting when receiving <see cref="T:Akka.Actor.ActorSelectionMessage"/> from a remote
                actor.
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorSelection.Anchor">
            <summary>
                Gets the anchor.
            </summary>
            <value>The anchor.</value>
        </member>
        <member name="P:Akka.Actor.ActorSelection.Elements">
            <summary>
                Gets or sets the elements.
            </summary>
            <value>The elements.</value>
        </member>
        <member name="P:Akka.Actor.ActorSelection.PathString">
            <summary>
            <see cref="T:System.String"/> representation of all of the elements in the <see cref="T:Akka.Actor.ActorSelection"/> path.
            </summary>
        </member>
        <member name="T:Akka.Actor.ActorSelectionMessage">
            <summary>
                Class ActorSelectionMessage.
            </summary>
        </member>
        <member name="T:Akka.Actor.INoSerializationVerificationNeeded">
            <summary>
                Marker Interface INoSerializationVerificationNeeded, this interface prevents
                implementing message types from being serialized if configuration setting 'akka.actor.serialize-messages' is "on"
            </summary>
        </member>
        <member name="T:Akka.Actor.IPossiblyHarmful">
            <summary>
            Marker interface to indicate that a message might be potentially harmful;
            this is used to block messages coming in over remoting.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSelectionMessage.#ctor(System.Object,Akka.Actor.SelectionPathElement[],System.Boolean)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.ActorSelectionMessage"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="elements">The elements.</param>
            <param name="wildCardFanOut"></param>
        </member>
        <member name="P:Akka.Actor.ActorSelectionMessage.Message">
            <summary>
                The message that should be delivered to this ActorSelection.
            </summary>
            <value>The message.</value>
        </member>
        <member name="P:Akka.Actor.ActorSelectionMessage.Elements">
            <summary>
                The elements, e.g. "foo/bar/baz".
            </summary>
            <value>The elements.</value>
        </member>
        <member name="T:Akka.Actor.SelectionPathElement">
            <summary>
                Class SelectionPathElement.
            </summary>
        </member>
        <member name="T:Akka.Actor.SelectChildName">
            <summary>
                Class SelectChildName.
            </summary>
        </member>
        <member name="M:Akka.Actor.SelectChildName.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.SelectChildName"/> class.
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="M:Akka.Actor.SelectChildName.ToString">
            <summary>
                Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>A <see cref="T:System.String"/> that represents this instance.</returns>
        </member>
        <member name="P:Akka.Actor.SelectChildName.Name">
            <summary>
                Gets or sets the actor name.
            </summary>
            <value>The name.</value>
        </member>
        <member name="T:Akka.Actor.SelectChildPattern">
            <summary>
                Class SelectChildPattern.
            </summary>
        </member>
        <member name="M:Akka.Actor.SelectChildPattern.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.SelectChildPattern"/> class.
            </summary>
            <param name="patternStr">The pattern string.</param>
        </member>
        <member name="M:Akka.Actor.SelectChildPattern.ToString">
            <summary>
                Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>A <see cref="T:System.String"/> that represents this instance.</returns>
        </member>
        <member name="P:Akka.Actor.SelectChildPattern.PatternStr">
            <summary>
                Gets the pattern string.
            </summary>
            <value>The pattern string.</value>
        </member>
        <member name="T:Akka.Actor.SelectParent">
            <summary>
                Class SelectParent.
            </summary>
        </member>
        <member name="M:Akka.Actor.SelectParent.ToString">
            <summary>
                Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>A <see cref="T:System.String"/> that represents this instance.</returns>
        </member>
        <member name="T:Akka.Actor.ActorSystem">
            <summary>
                An actor system is a hierarchical group of actors which share common
                configuration, e.g. dispatchers, deployments, remote capabilities and
                addresses. It is also the entry point for creating or looking up actors.
                There are several possibilities for creating actors (see [[Akka.Actor.Props]]
                for details on `props`):
                <code>
            system.ActorOf(props, "name");
            system.ActorOf(props);
            system.ActorOf(Props.Create(typeof(MyActor)), "name");
            system.ActorOf(Props.Create(() =&gt; new MyActor(arg1, arg2), "name");
            </code>
                Where no name is given explicitly, one will be automatically generated.
                <b>
                    <i>Important Notice:</i>
                </b>
                This class is not meant to be extended by user code.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSystem.Create(System.String,Akka.Configuration.Config)">
            <summary>
                Creates a new ActorSystem with the specified name, and the specified Config
            </summary>
            <param name="name">Name of the ActorSystem
            <remarks>Must contain only word characters (i.e. [a-zA-Z0-9] plus non-leading '-'</remarks>
            </param>
            <param name="config">Configuration of the ActorSystem</param>
            <returns>ActorSystem.</returns>
        </member>
        <member name="M:Akka.Actor.ActorSystem.Create(System.String)">
            <summary>
                Creates the specified name.
            </summary>
            <param name="name">The name. The name must be uri friendly.
            <remarks>Must contain only word characters (i.e. [a-zA-Z0-9] plus non-leading '-'</remarks>
            </param>
            <returns>ActorSystem.</returns>
        </member>
        <member name="M:Akka.Actor.ActorSystem.GetExtension(Akka.Actor.IExtensionId)">
            <summary>
            Returns an extension registered to this ActorSystem
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSystem.GetExtension``1">
            <summary>
            Returns an extension registered to this ActorSystem
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSystem.HasExtension(System.Type)">
            <summary>
            Determines whether this instance has the specified extension.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSystem.HasExtension``1">
            <summary>
            Determines whether this instance has the specified extension.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSystem.TryGetExtension(System.Type,System.Object@)">
            <summary>
            Tries to the get the extension of specified type.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSystem.TryGetExtension``1(``0@)">
            <summary>
            Tries to the get the extension of specified type.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSystem.Shutdown">
            <summary>
                Stop this actor system. This will stop the guardian actor, which in turn
                will recursively stop all its child actors, then the system guardian
                (below which the logging actors reside) and the execute all registered
                termination handlers (<see cref="!:ActorSystem.RegisterOnTermination"/>).
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSystem.AwaitTermination">
            <summary>
            Block current thread until the system has been shutdown.
            This will block until after all on termination callbacks have been run.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSystem.AwaitTermination(System.TimeSpan)">
            <summary>
            Block current thread until the system has been shutdown, or the specified
            timeout has elapsed. 
            This will block until after all on termination callbacks have been run.
            <para>Returns <c>true</c> if the system was shutdown during the specified time;
            <c>false</c> if it timed out.</para>
            </summary>
            <param name="timeout">The timeout.</param>
            <returns>Returns <c>true</c> if the system was shutdown during the specified time;
            <c>false</c> if it timed out.</returns>
        </member>
        <member name="M:Akka.Actor.ActorSystem.AwaitTermination(System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Block current thread until the system has been shutdown, or the specified
            timeout has elapsed, or the cancellationToken was canceled. 
            This will block until after all on termination callbacks have been run.
            <para>Returns <c>true</c> if the system was shutdown during the specified time;
            <c>false</c> if it timed out, or the cancellationToken was canceled. </para>
            </summary>
            <param name="timeout">The timeout.</param>
            <param name="cancellationToken">A cancellation token that cancels the wait operation.</param>
            <returns>Returns <c>true</c> if the system was shutdown during the specified time;
            <c>false</c> if it timed out, or the cancellationToken was canceled. </returns>
        </member>
        <member name="M:Akka.Actor.ActorSystem.Dispose">
            <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
        </member>
        <member name="M:Akka.Actor.ActorSystem.Dispose(System.Boolean)">
            <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
            <param name="disposing">if set to <c>true</c> the method has been called directly or indirectly by a 
            user's code. Managed and unmanaged resources will be disposed.<br />
            if set to <c>false</c> the method has been called by the runtime from inside the finalizer and only 
            unmanaged resources can be disposed.</param>
        </member>
        <member name="M:Akka.Actor.ActorSystem.WaitForShutdown">
            <summary>
            Block and prevent the main application thread from exiting unless
            the actor system is shut down.
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorSystem.Settings">
            <summary>Gets the settings.</summary>
            <value>The settings.</value>
        </member>
        <member name="P:Akka.Actor.ActorSystem.Name">
            <summary>Gets the name of this system.</summary>
            <value>The name.</value>
        </member>
        <member name="P:Akka.Actor.ActorSystem.Serialization">
            <summary>Gets the serialization.</summary>
            <value>The serialization.</value>
        </member>
        <member name="P:Akka.Actor.ActorSystem.EventStream">
            <summary>Gets the event stream.</summary>
            <value>The event stream.</value>
        </member>
        <member name="P:Akka.Actor.ActorSystem.DeadLetters">
            <summary>
                Gets the dead letters.
            </summary>
            <value>The dead letters.</value>
        </member>
        <member name="P:Akka.Actor.ActorSystem.Dispatchers">
            <summary>Gets the dispatchers.</summary>
            <value>The dispatchers.</value>
        </member>
        <member name="P:Akka.Actor.ActorSystem.Mailboxes">
            <summary>Gets the mailboxes.</summary>
            <value>The mailboxes.</value>
        </member>
        <member name="P:Akka.Actor.ActorSystem.Scheduler">
            <summary>Gets the scheduler.</summary>
            <value>The scheduler.</value>
        </member>
        <member name="P:Akka.Actor.ActorSystem.Log">
            <summary>Gets the log</summary>
        </member>
        <member name="P:Akka.Actor.ActorSystem.TerminationTask">
            <summary>
            Returns a task that will be completed when the system has terminated.
            </summary>
        </member>
        <member name="T:Akka.Actor.Address">
            <summary>
             The address specifies the physical location under which an Actor can be
             reached. Examples are local addresses, identified by the <see cref="T:Akka.Actor.ActorSystem"/>'s
            name, and remote addresses, identified by protocol, host and port.
             
            This class is sealed to allow use as a case class (copy method etc.); if
            for example a remote transport would want to associate additional
            information with an address, then this must be done externally.
            </summary>
        </member>
        <member name="F:Akka.Actor.Address.AllSystems">
            <summary>
            Pseudo address for all systems
            </summary>
        </member>
        <member name="M:Akka.Actor.Address.Parse(System.String)">
            <summary>
            Parses a new <see cref="T:Akka.Actor.Address"/> from a given string
            </summary>
            <param name="address">The address to parse</param>
            <returns>A populated <see cref="T:Akka.Actor.Address"/> object with host and port included, if available</returns>
            <exception cref="T:System.UriFormatException">Thrown if the address is not able to be parsed</exception>
        </member>
        <member name="T:Akka.Actor.RelativeActorPath">
            <summary>
            Extractor class for so-called "relative actor paths" - as in "relative URI", not
            "relative to some other actors."
            
            Examples:
            
             * "grand/child"
             * "/user/hello/world"
            </summary>
        </member>
        <member name="T:Akka.Dispatch.Mailbox">
            <summary>
            Mailbox base class
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.DebugPrint(System.String,System.Object[])">
            <summary>
            Prints a message tosStandard out if the Compile symbol "MAILBOXDEBUG" has been set.
            If the symbol is not set all invocations to this method will be removed by the compiler.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.SetActor(Akka.Actor.ActorCell)">
            <summary>
                Attaches an ActorCell to the Mailbox.
            </summary>
            <param name="actorCell"></param>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.Dispose">
            <summary>
                Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged and - optionally - managed resources.
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.Post(Akka.Actor.IActorRef,Akka.Actor.Envelope)">
            <summary>
                Posts the specified envelope to the mailbox.
            </summary>
            <param name="receiver"></param>
            <param name="envelope">The envelope.</param>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.BecomeClosed">
            <summary>
                Stops this instance.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.Setup(Akka.Dispatch.MessageDispatcher)">
            <summary>
                Attaches a MessageDispatcher to the Mailbox.
            </summary>
            <param name="dispatcher">The dispatcher.</param>
        </member>
        <member name="F:Akka.Dispatch.Mailbox.hasUnscheduledMessages">
            <summary>
                The has unscheduled messages
            </summary>
        </member>
        <member name="F:Akka.Dispatch.Mailbox.status">
            <summary>
                The mailbox status (busy or idle)
            </summary>
        </member>
        <member name="T:Akka.Dispatch.Mailbox.MailboxStatus">
            <summary>
                Class MailboxStatus.
            </summary>
        </member>
        <member name="F:Akka.Dispatch.Mailbox.MailboxStatus.Idle">
            <summary>
                The idle
            </summary>
        </member>
        <member name="F:Akka.Dispatch.Mailbox.MailboxStatus.Busy">
            <summary>
                The busy
            </summary>
        </member>
        <member name="T:Akka.Actor.ExtendedActorSystem">
            <summary>
            More powerful interface to the actor system’s implementation which is presented to 
            extensions (see <see cref="T:Akka.Actor.IExtension"/>).
            <remarks>Important Notice:<para>
            This class is not meant to be extended by user code. If you want to
            actually roll your own Akka, beware that you are completely on your own in
            that case!</para></remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.ExtendedActorSystem.SystemActorOf(Akka.Actor.Props,System.String)">
            <summary>Creates a new system actor in the "/system" namespace. This actor 
            will be shut down during system shutdown only after all user actors have
            terminated.</summary>
        </member>
        <member name="M:Akka.Actor.ExtendedActorSystem.SystemActorOf``1(System.String)">
            <summary>Creates a new system actor in the "/system" namespace. This actor 
            will be shut down during system shutdown only after all user actors have
            terminated.</summary>
        </member>
        <member name="P:Akka.Actor.ExtendedActorSystem.Provider">
            <summary>Gets the provider.</summary>
            <value>The provider.</value>
        </member>
        <member name="P:Akka.Actor.ExtendedActorSystem.Guardian">
            <summary>
            Gets the top-level supervisor of all user actors created using 
            <see cref="M:Akka.Actor.ActorSystem.ActorOf(Akka.Actor.Props,System.String)">system.ActorOf(...)</see>
            </summary>
        </member>
        <member name="P:Akka.Actor.ExtendedActorSystem.SystemGuardian">
            <summary>
            Gets the top-level supervisor of all system-internal services like logging.
            </summary>
        </member>
        <member name="P:Akka.Actor.ExtendedActorSystem.ActorPipelineResolver">
            <summary>
            Gets the actor producer pipeline resolver for current actor system. It may be used by
            Akka plugins to inject custom behavior directly into actor creation chain.
            </summary>
        </member>
        <member name="T:Akka.Actor.Futures">
            <summary>
                Extension method class designed to create Ask support for
                non-ActorRef objects such as <see cref="T:Akka.Actor.ActorSelection"/>.
            </summary>
        </member>
        <member name="T:Akka.Actor.PromiseActorRef">
            <summary>
            Akka private optimized representation of the temporary actor spawned to
            receive the reply to an "ask" operation.
            
            INTERNAL API
            </summary>
        </member>
        <member name="F:Akka.Actor.PromiseActorRef._mcn">
            <summary>
            This is necessary for weaving the PromiseActorRef into the asked message, i.e. the replyTo pattern.
            </summary>
        </member>
        <member name="F:Akka.Actor.PromiseActorRef._stateDoNotCallMeDirectly">
             As an optimization for the common (local) case we only register this PromiseActorRef
             with the provider when the `path` member is actually queried, which happens during
             serialization (but also during a simple call to `ToString`, `Equals` or `GetHashCode`!).
            
             Defined states:
             null                  => started, path not yet created
             Registering           => currently creating temp path and registering it
             path: ActorPath       => path is available and was registered
             StoppedWithPath(path) => stopped, path available
             Stopped               => stopped, path not yet created
        </member>
        <member name="M:Akka.Actor.PromiseActorRef.AddWatcher(Akka.Actor.IActorRef)">
            <summary>
            Returns false if the <see cref="F:Akka.Actor.PromiseActorRef.Result"/> is already completed.
            </summary>
        </member>
        <member name="M:Akka.Actor.PromiseActorRef.GetPath">
            <summary>
             Contract of this method:
             Must always return the same ActorPath, which must have
             been registered if we haven't been stopped yet.
            </summary>
        </member>
        <member name="T:Akka.Actor.PoisonPill">
            <summary>
            Sending a <see cref="T:Akka.Actor.PoisonPill"/> to an will stop the actor when the message 
            is processed. <see cref="T:Akka.Actor.PoisonPill"/> is enqueued as ordinary messages and will be handled after 
            messages that were already queued in the mailbox.
            <para>See also <see cref="T:Akka.Actor.Kill"/> which causes the actor to throw an  <see cref="T:Akka.Actor.ActorKilledException"/> when 
            it processes the message, which gets handled using the normal supervisor mechanism, and
            <see cref="M:Akka.Actor.IActorContext.Stop(Akka.Actor.IActorRef)"/> which causes the actor to stop without processing any more messages. </para>
            </summary>
        </member>
        <member name="T:Akka.Actor.Kill">
            <summary>
            Sending an <see cref="T:Akka.Actor.Kill"/> message to an actor causes the actor to throw an 
            <see cref="T:Akka.Actor.ActorKilledException"/> when it processes the message, which gets handled using the normal supervisor mechanism.
            <para>See also <see cref="T:Akka.Actor.PoisonPill"/> which causes the actor to stop when the <see cref="T:Akka.Actor.PoisonPill"/>
            is processed, without throwing an exception, and 
            <see cref="M:Akka.Actor.IActorContext.Stop(Akka.Actor.IActorRef)"/> which causes the actor to stop without processing any more messages. </para>
            </summary>
        </member>
        <member name="T:Akka.Actor.AddressTerminated">
            <summary>
            INTERNAL API
            
            Used for remote death watch. Failure detectors publish this to the
            <see cref="T:Akka.Event.AddressTerminatedTopic"/> when a remote node is detected to be unreachable and / or decided
            to be removed.
            
            The watcher <see cref="!:DeathWatch"/> subscribes to the <see cref="T:Akka.Event.AddressTerminatedTopic"/> and translates this
            event to <see cref="T:Akka.Actor.Terminated"/>, which is sent to itself.
            </summary>
        </member>
        <member name="T:Akka.Actor.EventStreamActor">
            <summary>
                Class EventStreamActor.
            </summary>
        </member>
        <member name="M:Akka.Actor.EventStreamActor.Receive(System.Object)">
            <summary>
                Processor for user defined messages.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="T:Akka.Actor.GuardianActor">
            <summary>
                Class GuardianActor.
            </summary>
        </member>
        <member name="M:Akka.Actor.SystemGuardianActor.Receive(System.Object)">
            <summary>
            Processor for messages that are sent to the root system guardian
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:Akka.Actor.DeadLetterActorRef">
            <summary>
                Class DeadLetterActorRef.
            </summary>
        </member>
        <member name="T:Akka.Actor.IInboxable">
            <summary>
            <see cref="T:Akka.Actor.IInboxable"/> is an actor-like object to be listened by external objects.
            It can watch other actors lifecycle and contains inner actor, which could be passed
            as reference to other actors.
            </summary>
        </member>
        <member name="M:Akka.Actor.IInboxable.Receive">
            <summary>
            Receive a next message from current <see cref="T:Akka.Actor.IInboxable"/> with default timeout. This call will return immediately,
            if the internal actor previously received a message, or will block until it'll receive a message.
            </summary>
        </member>
        <member name="M:Akka.Actor.IInboxable.Receive(System.TimeSpan)">
            <summary>
            Receive a next message from current <see cref="T:Akka.Actor.IInboxable"/>. This call will return immediately,
            if the internal actor previously received a message, or will block for time specified by 
            <paramref name="timeout"/> until it'll receive a message.
            </summary>
        </member>
        <member name="M:Akka.Actor.IInboxable.ReceiveWhere(System.Predicate{System.Object})">
            <summary>
            Receive a next message satisfying specified <paramref name="predicate"/> under default timeout.
            </summary>
        </member>
        <member name="M:Akka.Actor.IInboxable.ReceiveWhere(System.Predicate{System.Object},System.TimeSpan)">
            <summary>
            Receive a next message satisfying specified <paramref name="predicate"/> under provided <paramref name="timeout"/>.
            </summary>
        </member>
        <member name="M:Akka.Actor.IInboxable.Send(Akka.Actor.IActorRef,System.Object)">
            <summary>
            Makes an internal actor act as a proxy of given <paramref name="message"/>, 
            which will be send to given <paramref cref="!:target"/> actor. It means, 
            that all <paramref name="target"/>'s replies will be sent to current inbox instead.
            </summary>
        </member>
        <member name="P:Akka.Actor.IInboxable.Receiver">
            <summary>
            Get a reference to internal actor. It may be for example registered in event stream.
            </summary>
        </member>
        <member name="M:Akka.Actor.Inbox.Watch(Akka.Actor.IActorRef)">
            <summary>
            Make the inbox’s actor watch the <paramref name="subject"/> actor such that 
            reception of the <see cref="T:Akka.Actor.Terminated"/> message can then be awaited.
            </summary>
        </member>
        <member name="M:Akka.Actor.Inbox.Receive">
            <summary>
            Receive a single message from <see cref="P:Akka.Actor.Inbox.Receiver"/> actor with default timeout. 
            NOTE: Timeout resolution depends on system's scheduler.
            </summary>
            <remarks>
            Don't use this method within actors, since it block current thread until a message is received.
            </remarks>
        </member>
        <member name="M:Akka.Actor.Inbox.Receive(System.TimeSpan)">
            <summary>
            Receive a single message from <see cref="P:Akka.Actor.Inbox.Receiver"/> actor. 
            Provided <paramref name="timeout"/> is used for cleanup purposes.
            NOTE: <paramref name="timeout"/> resolution depends on system's scheduler.
            </summary>
            <remarks>
            Don't use this method within actors, since it block current thread until a message is received.
            </remarks>
        </member>
        <member name="T:Akka.Actor.Internals.ActorSystemImpl">
            <summary>
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.Internals.ActorSystemImpl.SystemActorOf(Akka.Actor.Props,System.String)">
            <summary>Creates a new system actor.</summary>
        </member>
        <member name="M:Akka.Actor.Internals.ActorSystemImpl.SystemActorOf``1(System.String)">
            <summary>Creates a new system actor.</summary>
        </member>
        <member name="M:Akka.Actor.Internals.ActorSystemImpl.Start">
            <summary>Starts this system</summary>
        </member>
        <member name="M:Akka.Actor.Internals.ActorSystemImpl.LoadExtensions">
            <summary>
            Load all of the extensions registered in the <see cref="P:Akka.Actor.ActorSystem.Settings"/>
            </summary>
        </member>
        <member name="M:Akka.Actor.Internals.ActorSystemImpl.ConfigureSettings(Akka.Configuration.Config)">
            <summary>
                Configures the settings.
            </summary>
            <param name="config">The configuration.</param>
        </member>
        <member name="M:Akka.Actor.Internals.ActorSystemImpl.ConfigureEventStream">
            <summary>
                Configures the event stream.
            </summary>
        </member>
        <member name="M:Akka.Actor.Internals.ActorSystemImpl.ConfigureSerialization">
            <summary>
                Configures the serialization.
            </summary>
        </member>
        <member name="M:Akka.Actor.Internals.ActorSystemImpl.ConfigureMailboxes">
            <summary>
                Configures the mailboxes.
            </summary>
        </member>
        <member name="M:Akka.Actor.Internals.ActorSystemImpl.ConfigureProvider">
            <summary>
                Configures the provider.
            </summary>
        </member>
        <member name="M:Akka.Actor.Internals.ActorSystemImpl.ConfigureLoggers">
            <summary>
            Extensions depends on loggers being configured before Start() is called
            </summary>
        </member>
        <member name="M:Akka.Actor.Internals.ActorSystemImpl.ConfigureDispatchers">
            <summary>
                Configures the dispatchers.
            </summary>
        </member>
        <member name="M:Akka.Actor.Internals.ActorSystemImpl.ConfigureActorProducerPipeline">
            <summary>
            Configures the actor producer pipeline.
            </summary>
        </member>
        <member name="M:Akka.Actor.Internals.ActorSystemImpl.Shutdown">
            <summary>
                Stop this actor system. This will stop the guardian actor, which in turn
                will recursively stop all its child actors, then the system guardian
                (below which the logging actors reside) and the execute all registered
                termination handlers (<see cref="!:ActorSystem.RegisterOnTermination"/>).
            </summary>
        </member>
        <member name="T:Akka.Actor.LocalScope">
            <summary>
            Used to deploy actors in local scope
            </summary>
        </member>
        <member name="T:Akka.Actor.Scope">
            <summary>
            Defines the scope of a <see cref="T:Akka.Actor.Deploy"/>
            
            Valid values are:
            
            * Local - this actor will be deployed locally in this process
            * Remote - this actor will be deployed remotely on another system
            * Cluster - this actor will be deployed into a cluster of remote processes
            </summary>
        </member>
        <member name="T:Akka.Actor.ReceiveTimeout">
            <summary>
            This message is sent to an actor that has set a receive timeout, either by calling 
            <see cref="M:Akka.Actor.IActorContext.SetReceiveTimeout(System.Nullable{System.TimeSpan})">Context.SetReceiveTimeout</see> or
            <see cref="M:Akka.Actor.ActorBase.SetReceiveTimeout(System.Nullable{System.TimeSpan})">SetReceiveTimeout</see>
            and no message has been sent to the actor during the specified amount of time.
            </summary>
        </member>
        <member name="P:Akka.Actor.ReceiveTimeout.Instance">
            <summary>
            Gets the <see cref="T:Akka.Actor.ReceiveTimeout"/> singleton instance.
            </summary>
        </member>
        <member name="T:Akka.Actor.RemoteScope">
            <summary>
            Used to deploy actors on remote nodes at the specified <see cref="P:Akka.Actor.RemoteScope.Address"/>.
            </summary>
        </member>
        <member name="M:Akka.Actor.RepointableActorRef.Initialize(System.Boolean)">
            <summary>
            Initialize: make a dummy cell which holds just a mailbox, then tell our
            supervisor that we exist so that he can create the real Cell in
            handleSupervise().
            Call twice on your own peril!
            This is protected so that others can have different initialization.
             </summary>
        </member>
        <member name="M:Akka.Actor.RepointableActorRef.Point">
            <summary>
            This method is supposed to be called by the supervisor in HandleSupervise()
            to replace the UnstartedCell with the real one. It assumes no concurrent
            modification of the `underlying` field, though it is safe to send messages
            at any time.
             </summary>
        </member>
        <member name="M:Akka.Actor.LocalActorRef.#ctor(Akka.Actor.ActorSystem,Akka.Actor.Props,Akka.Dispatch.MessageDispatcher,System.Func{Akka.Dispatch.Mailbox},Akka.Actor.IInternalActorRef,Akka.Actor.ActorPath,System.Func{Akka.Actor.LocalActorRef,Akka.Actor.ActorCell})">
            <summary>
            Inheritors should only call this constructor
            </summary>
        </member>
        <member name="T:Akka.Actor.RootGuardianSupervisor">
            <summary>
            Top-level anchor for the supervision hierarchy of this actor system.
            Note: This class is called theOneWhoWalksTheBubblesOfSpaceTime in Akka
            </summary>
        </member>
        <member name="T:Akka.Actor.IExtension">
            <summary>
            Marker interface used to identify an object as ActorSystem extension
            </summary>
        </member>
        <member name="T:Akka.Actor.IExtensionId">
            <summary>
            Non-generic version of interface, mostly to avoid issues with generic casting
            </summary>
        </member>
        <member name="M:Akka.Actor.IExtensionId.Apply(Akka.Actor.ActorSystem)">
            <summary>
            Returns an instance of the extension identified by this ExtensionId instance
            </summary>
        </member>
        <member name="M:Akka.Actor.IExtensionId.Get(Akka.Actor.ActorSystem)">
            <summary>
            Returns an instance of the extension identified by this <see cref="T:Akka.Actor.IExtensionId`1"/> instance
            </summary>
        </member>
        <member name="M:Akka.Actor.IExtensionId.CreateExtension(Akka.Actor.ExtendedActorSystem)">
            <summary>
            Is used by Akka to instantiate the <see cref="T:Akka.Actor.IExtension"/> identified by this ExtensionId.
            Internal use only.
            </summary>
        </member>
        <member name="P:Akka.Actor.IExtensionId.ExtensionType">
            <summary>
            Returns the underlying type for this extension
            </summary>
        </member>
        <member name="T:Akka.Actor.IExtensionId`1">
            <summary>
            Marker interface used to distinguish a unique ActorSystem extensions
            </summary>
        </member>
        <member name="M:Akka.Actor.IExtensionId`1.Apply(Akka.Actor.ActorSystem)">
            <summary>
            Returns an instance of the extension identified by this ExtensionId instance
            </summary>
        </member>
        <member name="M:Akka.Actor.IExtensionId`1.Get(Akka.Actor.ActorSystem)">
            <summary>
            Returns an instance of the extension identified by this <see cref="T:Akka.Actor.IExtensionId`1"/> instance
            </summary>
        </member>
        <member name="M:Akka.Actor.IExtensionId`1.CreateExtension(Akka.Actor.ExtendedActorSystem)">
            <summary>
            Is used by Akka to instantiate the <see cref="T:Akka.Actor.IExtension"/> identified by this ExtensionId.
            Internal use only.
            </summary>
        </member>
        <member name="T:Akka.Actor.ActorSystemWithExtensions">
            <summary>
            Static helper class used for resolving extensions
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSystemWithExtensions.WithExtension``1(Akka.Actor.ActorSystem)">
            <summary>
            Loads the extension and casts it to the expected type if it's already registered
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSystemWithExtensions.WithExtension``1(Akka.Actor.ActorSystem,System.Type)">
            <summary>
            Registers a type and returns it if one doesn't yet exist
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSystemWithExtensions.WithExtension``2(Akka.Actor.ActorSystem)">
            <summary>
            Registers a type and returns it if one doesn't yet exist
            </summary>
        </member>
        <member name="T:Akka.Actor.ExtensionIdProvider`1">
            <summary>
                Class ExtensionBase.
            </summary>
        </member>
        <member name="T:Akka.Actor.FSMBase.CurrentState`1">
            <summary>
            Message type which is sent directly to the subscriber Actor in <see cref="T:Akka.Actor.FSMBase.SubscribeTransitionCallBack"/>
            before sending any <see cref="T:Akka.Actor.FSMBase.Transition`1"/> messages.
            </summary>
            <typeparam name="TS">The type of the state being used in this finite state machine.</typeparam>
        </member>
        <member name="T:Akka.Actor.FSMBase.Transition`1">
            <summary>
            Message type which is used to communicate transitions between states to all subscribed listeners
            (use <see cref="T:Akka.Actor.FSMBase.SubscribeTransitionCallBack"/>)
            </summary>
            <typeparam name="TS">The type of state used</typeparam>
        </member>
        <member name="T:Akka.Actor.FSMBase.SubscribeTransitionCallBack">
            <summary>
            Send this to an <see cref="T:Akka.Actor.FSMBase.SubscribeTransitionCallBack"/> to request first the <see cref="T:Akka.Actor.FSMBase.UnsubscribeTransitionCallBack"/>
            followed by a series of <see cref="T:Akka.Actor.FSMBase.Transition`1"/> updates. Cancel the subscription using
            <see cref="T:Akka.Actor.FSMBase.CurrentState`1"/>.
            </summary>
        </member>
        <member name="T:Akka.Actor.FSMBase.UnsubscribeTransitionCallBack">
            <summary>
            Unsubscribe from <see cref="T:Akka.Actor.FSMBase.SubscribeTransitionCallBack"/> notifications which were
            initialized by sending the corresponding <see cref="T:Akka.Actor.FSMBase.Transition`1"/>.
            </summary>
        </member>
        <member name="T:Akka.Actor.FSMBase.Reason">
            <summary>
            Reason why this <see cref="T:Akka.Actor.FSM`2"/> is shutting down
            </summary>
        </member>
        <member name="T:Akka.Actor.FSMBase.Normal">
            <summary>
            Default <see cref="T:Akka.Actor.FSMBase.Reason"/> if calling Stop().
            </summary>
        </member>
        <member name="T:Akka.Actor.FSMBase.Shutdown">
            <summary>
            Reason given when someone as calling <see cref="T:Akka.Dispatch.SysMsg.Stop"/> from outside;
            also applies to <see cref="T:Akka.Actor.ActorSystem"/> supervision directive.
            </summary>
        </member>
        <member name="T:Akka.Actor.FSMBase.Failure">
            <summary>
            Signifies that the <see cref="T:Akka.Actor.FSM`2"/> is shutting itself down because of an error,
            e.g. if the state to transition into does not exist. You can use this to communicate a more
            precise cause to the <see cref="M:Akka.Actor.FSM`2.OnTermination(System.Action{Akka.Actor.FSMBase.StopEvent{`0,`1}})"/> block.
            </summary>
        </member>
        <member name="T:Akka.Actor.FSMBase.StateTimeout">
            <summary>
            Used in the event of a timeout between transitions
            </summary>
        </member>
        <member name="T:Akka.Actor.FSMBase.LogEntry`2">
            <summary>
            Log entry of the <see cref="T:Akka.Actor.ILoggingFSM"/> - can be obtained by calling <see cref="!:GetLog"/>
            </summary>
            <typeparam name="TS">The name of the state</typeparam>
            <typeparam name="TD">The data of the state</typeparam>
        </member>
        <member name="T:Akka.Actor.FSMBase.State`2">
            <summary>
            This captures all of the managed state of the <see cref="T:Akka.Actor.FSM`2"/>: the state name,
            the state data, possibly custom timeout, stop reason, and replies accumulated while
            processing the last message.
            </summary>
            <typeparam name="TS">The name of the state</typeparam>
            <typeparam name="TD">The data of the state</typeparam>
        </member>
        <member name="M:Akka.Actor.FSMBase.State`2.ForMax(System.TimeSpan)">
            <summary>
            Modify the state transition descriptor to include a state timeout for the 
            next state. This timeout overrides any default timeout set for the next state.
            <remarks>Use <see cref="F:System.TimeSpan.MaxValue"/> to cancel a timeout.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.FSMBase.State`2.Replying(System.Object)">
            <summary>
            Send reply to sender of the current message, if available.
            </summary>
            <param name="replyValue"></param>
            <returns></returns>
        </member>
        <member name="M:Akka.Actor.FSMBase.State`2.Using(`1)">
            <summary>
            Modify state transition descriptor with new state data. The data will be set
            when transitioning to the new state.
            </summary>
        </member>
        <member name="M:Akka.Actor.FSMBase.State`2.WithStopReason(Akka.Actor.FSMBase.Reason)">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Actor.FSMBase.Event`1">
            <summary>
            All messages sent to the <see cref="T:Akka.Actor.FSM`2"/> will be wrapped inside an <see cref="T:Akka.Actor.FSMBase.Event`1"/>,
            which allows pattern matching to extract both state and data.
            </summary>
            <typeparam name="TD">The state data for this event</typeparam>
        </member>
        <member name="T:Akka.Actor.FSMBase.StopEvent`2">
            <summary>
            Class representing the state of the <see cref="T:Akka.Actor.FSM`2"/> within the OnTermination block.
            </summary>
        </member>
        <member name="T:Akka.Actor.FSM`2">
            <summary>
            Finite state machine (FSM) actor.
            </summary>
            <typeparam name="TState">The state name type</typeparam>
            <typeparam name="TData">The state data type</typeparam>
        </member>
        <member name="T:Akka.Routing.IListeners">
            <summary>
            IListeners is a generic interface to implement listening capabilities on an Actor.
            
            <remarks>Use the <see cref="M:Akka.Routing.ListenerSupport.Gossip(System.Object)"/> method to send a message to the listeners</remarks>.
            <remarks>Send <code>Listen(Self)</code> to another Actor to start listening.</remarks>
            <remarks>Send <code>Deafen(Self)</code> to another Actor to stop listening.</remarks>
            <remarks>Send <code>WithListeners(delegate)</code> to traverse the current listeners.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.FSM`2.When(`0,Akka.Actor.FSM{`0,`1}.StateFunction,System.Nullable{System.TimeSpan})">
            <summary>
            Insert a new <see cref="T:Akka.Actor.FSM`2.StateFunction"/> at the end of the processing chain for the
            given state. If the stateTimeout parameter is set, entering this state without a
            differing explicit timeout setting will trigger a <see cref="T:Akka.Actor.FSMBase.StateTimeout"/>.
            </summary>
            <param name="stateName">designator for the state</param>
            <param name="func">delegate describing this state's response to input</param>
            <param name="timeout">default timeout for this state</param>
        </member>
        <member name="M:Akka.Actor.FSM`2.StartWith(`0,`1,System.Nullable{System.TimeSpan})">
            <summary>
            Sets the initial state for this FSM. Call this method from the constructor before the <see cref="M:Akka.Actor.FSM`2.Initialize"/> method.
            If different state is needed after a restart this method, followed by <see cref="M:Akka.Actor.FSM`2.Initialize"/>, can be used in the actor
            life cycle hooks <see cref="M:Akka.Actor.ActorBase.PreStart"/> and <see cref="M:Akka.Actor.ActorBase.PostRestart(System.Exception)"/>.
            </summary>
            <param name="stateName">Initial state designator.</param>
            <param name="stateData">Initial state data.</param>
            <param name="timeout">State timeout for the initial state, overriding the default timeout for that state.</param>
        </member>
        <member name="M:Akka.Actor.FSM`2.GoTo(`0)">
            <summary>
            Produce transition to other state. Return this from a state function
            in order to effect the transition.
            </summary>
            <param name="nextStateName">State designator for the next state</param>
            <returns>State transition descriptor</returns>
        </member>
        <member name="M:Akka.Actor.FSM`2.GoTo(`0,`1)">
            <summary>
            Produce transition to other state. Return this from a state function
            in order to effect the transition.
            </summary>
            <param name="nextStateName">State designator for the next state</param>
            <param name="stateData">Data for next state</param>
            <returns>State transition descriptor</returns>
        </member>
        <member name="M:Akka.Actor.FSM`2.Stay">
            <summary>
            Produce "empty" transition descriptor. Return this from a state function
            when no state change is to be effected.
            </summary>
            <returns>Descriptor for staying in the current state.</returns>
        </member>
        <member name="M:Akka.Actor.FSM`2.Stop">
            <summary>
            Produce change descriptor to stop this FSM actor with <see cref="T:Akka.Actor.FSMBase.Reason"/> <see cref="T:Akka.Actor.FSMBase.Normal"/>
            </summary>
        </member>
        <member name="M:Akka.Actor.FSM`2.Stop(Akka.Actor.FSMBase.Reason)">
            <summary>
            Produce change descriptor to stop this FSM actor with the specified <see cref="T:Akka.Actor.FSMBase.Reason"/>.
            </summary>
        </member>
        <member name="M:Akka.Actor.FSM`2.SetTimer(System.String,System.Object,System.TimeSpan,System.Boolean)">
            <summary>
            Schedule named timer to deliver message after given delay, possibly repeating.
            Any existing timer with the same name will automatically be canceled before adding
            the new timer.
            </summary>
            <param name="name">identifier to be used with <see cref="M:Akka.Actor.FSM`2.CancelTimer(System.String)"/>.</param>
            <param name="msg">message to be delivered</param>
            <param name="timeout">delay of first message delivery and between subsequent messages.</param>
            <param name="repeat">send once if false, scheduleAtFixedRate if true</param>
        </member>
        <member name="M:Akka.Actor.FSM`2.CancelTimer(System.String)">
            <summary>
            Cancel a named <see cref="T:System.Threading.Timer"/>, ensuring that the message is not subsequently delivered (no race.)
            </summary>
            <param name="name">The name of the timer to cancel.</param>
        </member>
        <member name="M:Akka.Actor.FSM`2.IsTimerActive(System.String)">
            <summary>
            Determines whether the named timer is still active. Returns true 
            unless the timer does not exist, has previously been cancelled, or
            if it was a single-shot timer whose message was already received.
            </summary>
        </member>
        <member name="M:Akka.Actor.FSM`2.SetStateTimeout(`0,System.Nullable{System.TimeSpan})">
            <summary>
            Set the state timeout explicitly. This method can be safely used from
            within a state handler.
            </summary>
        </member>
        <member name="M:Akka.Actor.FSM`2.OnTransition(Akka.Actor.FSM{`0,`1}.TransitionHandler)">
            <summary>
            Set handler which is called upon each state transition, i.e. not when
            staying in the same state. 
            </summary>
        </member>
        <member name="M:Akka.Actor.FSM`2.OnTermination(System.Action{Akka.Actor.FSMBase.StopEvent{`0,`1}})">
            <summary>
            Set the handler which is called upon termination of this FSM actor. Calling this
            method again will overwrite the previous contents.
            </summary>
        </member>
        <member name="M:Akka.Actor.FSM`2.WhenUnhandled(Akka.Actor.FSM{`0,`1}.StateFunction)">
            <summary>
            Set handler which is called upon reception of unhandled FSM messages. Calling
            this method again will overwrite the previous contents.
            </summary>
            <param name="stateFunction"></param>
        </member>
        <member name="M:Akka.Actor.FSM`2.Initialize">
            <summary>
            Verify the existence of initial state and setup timers. This should be the
            last call within the constructor or <see cref="M:Akka.Actor.ActorBase.PreStart"/> and
            <see cref="M:Akka.Actor.ActorBase.PostRestart(System.Exception)"/>.
            </summary>
        </member>
        <member name="F:Akka.Actor.FSM`2.DebugEvent">
            <summary>
            Can be set to enable debugging on certain actions taken by the FSM
            </summary>
        </member>
        <member name="F:Akka.Actor.FSM`2._currentState">
            <summary>
            FSM state data and current timeout handling
            </summary>
        </member>
        <member name="F:Akka.Actor.FSM`2._timers">
            <summary>
            Timer handling
            </summary>
        </member>
        <member name="F:Akka.Actor.FSM`2._stateFunctions">
            <summary>
            State definitions
            </summary>
        </member>
        <member name="F:Akka.Actor.FSM`2._terminateEvent">
            <summary>
            Termination handling
            </summary>
        </member>
        <member name="F:Akka.Actor.FSM`2._transitionEvent">
            <summary>
            Transition handling
            </summary>
        </member>
        <member name="M:Akka.Actor.FSM`2.OrElse(Akka.Actor.FSM{`0,`1}.StateFunction,Akka.Actor.FSM{`0,`1}.StateFunction)">
            <summary>
            C# port of Scala's orElse method for partial function chaining.
            
            See http://scalachina.com/api/scala/PartialFunction.html
            </summary>
            <param name="original">The original <see cref="T:Akka.Actor.FSM`2.StateFunction"/> to be called</param>
            <param name="fallback">The <see cref="T:Akka.Actor.FSM`2.StateFunction"/> to be called if <see cref="!:original"/> returns null</param>
            <returns>A <see cref="T:Akka.Actor.FSM`2.StateFunction"/> which combines both the results of <see cref="!:original"/> and <see cref="!:fallback"/></returns>
        </member>
        <member name="M:Akka.Actor.FSM`2.Receive(System.Object)">
            <summary>
            Main actor receive method
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Akka.Actor.FSM`2.PostStop">
            <summary>
            Call the <see cref="M:Akka.Actor.FSM`2.OnTermination(System.Action{Akka.Actor.FSMBase.StopEvent{`0,`1}})"/> hook if you want to retain this behavior.
            When overriding make sure to call base.PostStop();
            
            Please note that this method is called by default from <see cref="M:Akka.Actor.ActorBase.PreRestart(System.Exception,System.Object)"/> so
            override that one if <see cref="M:Akka.Actor.FSM`2.OnTermination(System.Action{Akka.Actor.FSMBase.StopEvent{`0,`1}})"/> shall not be called during restart.
            </summary>
        </member>
        <member name="M:Akka.Actor.FSM`2.LogTermination(Akka.Actor.FSMBase.Reason)">
            <summary>
            By default, <see cref="T:Akka.Actor.Failure"/> is logged at error level and other
            reason types are not logged. It is possible to override this behavior.
            </summary>
            <param name="reason"></param>
        </member>
        <member name="P:Akka.Actor.FSM`2.StateName">
            <summary>
            Current state name
            </summary>
        </member>
        <member name="P:Akka.Actor.FSM`2.StateData">
            <summary>
            Current state data
            </summary>
        </member>
        <member name="P:Akka.Actor.FSM`2.NextStateData">
            <summary>
            Return next state data (available in <see cref="M:Akka.Actor.FSM`2.OnTransition(Akka.Actor.FSM{`0,`1}.TransitionHandler)"/> handlers)
            </summary>
        </member>
        <member name="P:Akka.Actor.FSM`2.HandleEventDefault">
            <summary>
            Unhandled event handler
            </summary>
        </member>
        <member name="T:Akka.Actor.ILoggingFSM">
            <summary>
            Marker interface to let the setting "akka.actor.debug.fsm" control if logging should occur in <see cref="T:Akka.Actor.FSM`2"/>
            </summary>
        </member>
        <member name="T:Akka.Actor.GracefulStopSupport">
            <summary>
            Returns a <see cref="T:System.Threading.Tasks.Task"/> that will be completed with success when existing messages
            of the target actor have been processed and the actor has been terminated.
            
            Useful when you need to wait for termination or compose ordered termination of several actors,
            which should only be done outside of the <see cref="T:Akka.Actor.ActorSystem"/> as blocking inside <see cref="T:Akka.Actor.ActorBase"/> is discouraged.
            
            <remarks><c>IMPORTANT:</c> the actor being terminated and its supervisor being informed of the availability of the deceased actor's name
            are two distinct operations, which do not obey any reliable ordering.</remarks>
            
            If the target actor isn't terminated within the timeout the <see cref="T:System.Threading.Tasks.Task"/> is completed with failure.
            
            If you want to invoke specialized stopping logic on your target actor instead of <see cref="T:Akka.Actor.PoisonPill"/>, you can pass your stop command as a parameter:
            <code>
                GracefulStop(someChild, timeout, MyStopGracefullyMessage).ContinueWith(r =&gt; {
                    // Do something after someChild starts being stopped.
                });
            </code>
            </summary>
        </member>
        <member name="T:Akka.Actor.PipeToSupport">
            <summary>
            Creates the PipeTo pattern for automatically sending the results of completed tasks
            into the inbox of a designated Actor
            </summary>
        </member>
        <member name="M:Akka.Actor.PipeToSupport.PipeTo``1(System.Threading.Tasks.Task{``0},Akka.Actor.ICanTell,Akka.Actor.IActorRef)">
            <summary>
            Pipes the output of a Task directly to the <see cref="!:recipient"/>'s mailbox once
            the task completes
            </summary>
        </member>
        <member name="T:Akka.Actor.Receive">
            <summary>
                Delegate Receive
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleTellOnce(Akka.Actor.ITellScheduler,System.Int32,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef,Akka.Actor.ICancelable)">
            <summary>Schedules to send a message once after a specified period of time.</summary>
            <param name="scheduler">The scheduler</param>
            <param name="millisecondsDelay">The time in milliseconds that has to pass before the message is sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <param name="cancelable">OPTIONAL. An <see cref="T:Akka.Actor.ICancelable"/> that can be used to cancel sending of the message. Note that once the message has been sent, it cannot be canceled.</param>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleTellRepeatedly(Akka.Actor.ITellScheduler,System.Int32,System.Int32,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef,Akka.Actor.ICancelable)">
            <summary>Schedules to send a message repeatedly. The first message will be sent after the specified initial delay and there after at the rate specified.</summary>
            <param name="scheduler">The scheduler</param>
            <param name="initialMillisecondsDelay">The time in milliseconds that has to pass before the first message is sent.</param>
            <param name="millisecondsInterval">The interval, i.e. the time in milliseconds that has to pass between messages are being sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <param name="cancelable">OPTIONAL. An <see cref="T:Akka.Actor.ICancelable"/> that can be used to cancel sending of the message. Note that once the message has been sent, it cannot be canceled.</param>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleOnce(Akka.Actor.IActionScheduler,System.Int32,System.Action,Akka.Actor.ICancelable)">
            <summary>
            Schedules an action to be invoked after an delay.
            The action will be wrapped so that it completes inside the currently active actor if it is called from within an actor.
            <remarks>Note! It's considered bad practice to use concurrency inside actors, and very easy to get wrong so usage is discouraged.</remarks>
            </summary>
            <param name="scheduler">The scheduler</param>
            <param name="millisecondsDelay">The time in milliseconds that has to pass before the action is invoked.</param>
            <param name="action">The action to perform.</param>
            <param name="cancelable">OPTIONAL. A cancelable that can be used to cancel the action from being executed. Defaults to <c>null</c></param>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleRepeatedly(Akka.Actor.IActionScheduler,System.Int32,System.Int32,System.Action,Akka.Actor.ICancelable)">
            <summary>
            Schedules an action to be invoked after an initial delay and then repeatedly.
            The action will be wrapped so that it completes inside the currently active actor if it is called from within an actor
            <remarks>Note! It's considered bad practice to use concurrency inside actors, and very easy to get wrong so usage is discouraged.</remarks>
            </summary>
            <param name="scheduler">The scheduler</param>
            <param name="initialMillisecondsDelay">The time in milliseconds that has to pass before first invocation.</param>
            <param name="millisecondsInterval">The interval, i.e. the time in milliseconds that has to pass before the action is invoked again.</param>
            <param name="action">The action to perform.</param>
            <param name="cancelable">OPTIONAL. A cancelable that can be used to cancel the action from being executed. Defaults to <c>null</c></param>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleTellOnceCancelable(Akka.Actor.IScheduler,System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef)">
            <summary>Schedules to send a message once after a specified period of time.</summary>
            <param name="scheduler">The scheduler</param>
            <param name="delay">The time period that has to pass before the message is sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <returns>An <see cref="T:Akka.Actor.ICancelable"/> that can be used to cancel sending of the message. Once the message already has been sent, it cannot be cancelled.</returns>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleTellOnceCancelable(Akka.Actor.IScheduler,System.Int32,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef)">
            <summary>Schedules to send a message once after a specified period of time.</summary>
            <param name="scheduler">The scheduler</param>
            <param name="millisecondsDelay">The time in milliseconds that has to pass before the message is sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <returns>An <see cref="T:Akka.Actor.ICancelable"/> that can be used to cancel sending of the message. Once the message already has been sent, it cannot be cancelled.</returns>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleTellRepeatedlyCancelable(Akka.Actor.IScheduler,System.TimeSpan,System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef)">
            <summary>Schedules to send a message repeatedly. The first message will be sent after the specified initial delay and there after at the rate specified.</summary>
            <param name="scheduler">The scheduler</param>
            <param name="initialDelay">The time period that has to pass before the first message is sent.</param>
            <param name="interval">The interval, i.e. the time period that has to pass between messages are being sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <returns>An <see cref="T:Akka.Actor.ICancelable"/> that can be used to cancel sending of the message. Once the message already has been sent, it cannot be cancelled.</returns>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleTellRepeatedlyCancelable(Akka.Actor.IScheduler,System.Int32,System.Int32,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef)">
            <summary>Schedules to send a message repeatedly. The first message will be sent after the specified initial delay and there after at the rate specified.</summary>
            <param name="scheduler">The scheduler</param>
            <param name="initialMillisecondsDelay">The time in milliseconds that has to pass before the first message is sent.</param>
            <param name="millisecondsInterval">The interval, i.e. the time in milliseconds that has to pass between messages are sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <returns>An <see cref="T:Akka.Actor.ICancelable"/> that can be used to cancel sending of the message. Once the message already has been sent, it cannot be cancelled.</returns>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleOnceCancelable(Akka.Actor.IActionScheduler,System.TimeSpan,System.Action)">
            <summary>
            Schedules an action to be invoked after an delay.
            </summary>
            <param name="scheduler">The scheduler</param>
            <param name="delay">The time period that has to pass before the action is invoked.</param>
            <param name="action">The action to perform.</param>
            <returns>A cancelable that can be used to cancel the action from being executed</returns>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleOnceCancelable(Akka.Actor.IActionScheduler,System.Int32,System.Action)">
            <summary>
            Schedules an action to be invoked after an delay.
            </summary>
            <param name="scheduler">The scheduler</param>
            <param name="millisecondsDelay">The time in milliseconds that has to pass before the action is invoked.</param>
            <param name="action">The action to perform.</param>
            <returns>A cancelable that can be used to cancel the action from being executed</returns>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleRepeatedlyCancelable(Akka.Actor.IActionScheduler,System.TimeSpan,System.TimeSpan,System.Action)">
            <summary>
            Schedules an action to be invoked after an initial delay and then repeatedly.
            </summary>
            <param name="scheduler">The scheduler</param>
            <param name="initialDelay">The time period that has to pass before first invocation.</param>
            <param name="interval">The interval, i.e. the time period that has to pass between the action is invoked.</param>
            <param name="action">The action to perform.</param>
            <returns>A cancelable that can be used to cancel the action from being executed</returns>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleRepeatedlyCancelable(Akka.Actor.IActionScheduler,System.Int32,System.Int32,System.Action)">
            <summary>
            Schedules an action to be invoked after an initial delay and then repeatedly.
            </summary>
            <param name="scheduler">The scheduler</param>
            <param name="initialMillisecondsDelay">The time in milliseconds that has to pass before first invocation.</param>
            <param name="millisecondsInterval">The interval, i.e. the time in milliseconds that has to pass between the action is invoked.</param>
            <param name="action">The action to perform.</param>
            <returns>A cancelable that can be used to cancel the action from being executed</returns>
        </member>
        <member name="T:Akka.Actor.NoScopeGiven">
            <summary>
            Place-holder for when a scope of this deployment has not been specified yet
            </summary>
        </member>
        <member name="T:Akka.Actor.Settings">
            <summary>
                Settings are the overall ActorSystem Settings which also provides a convenient access to the Config object.
                For more detailed information about the different possible configuration options, look in the Akka .NET
                Documentation under "Configuration"
            </summary>
        </member>
        <member name="M:Akka.Actor.Settings.RebuildConfig">
            <summary>
            Combines the user config and the fallback chain of configs
            </summary>
        </member>
        <member name="M:Akka.Actor.Settings.InjectTopLevelFallback(Akka.Configuration.Config)">
            <summary>
            Injects a system config at the top of the fallback chain
            </summary>
            <param name="config"></param>
        </member>
        <member name="M:Akka.Actor.Settings.#ctor(Akka.Actor.ActorSystem,Akka.Configuration.Config)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.Settings"/> class.
            </summary>
            <param name="system">The system.</param>
            <param name="config">The configuration.</param>
        </member>
        <member name="M:Akka.Actor.Settings.ToString">
            <summary>
                Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>A <see cref="T:System.String"/> that represents this instance.</returns>
        </member>
        <member name="P:Akka.Actor.Settings.System">
            <summary>
                Gets the system.
            </summary>
            <value>The system.</value>
        </member>
        <member name="P:Akka.Actor.Settings.Config">
            <summary>
                Gets the configuration.
            </summary>
            <value>The configuration.</value>
        </member>
        <member name="P:Akka.Actor.Settings.ConfigVersion">
            <summary>
                Gets the configuration version.
            </summary>
            <value>The configuration version.</value>
        </member>
        <member name="P:Akka.Actor.Settings.ProviderClass">
            <summary>
                Gets the provider class.
            </summary>
            <value>The provider class.</value>
        </member>
        <member name="P:Akka.Actor.Settings.SupervisorStrategyClass">
            <summary>
                Gets the supervisor strategy class.
            </summary>
            <value>The supervisor strategy class.</value>
        </member>
        <member name="P:Akka.Actor.Settings.SerializeAllMessages">
            <summary>
                Gets a value indicating whether [serialize all messages].
            </summary>
            <value><c>true</c> if [serialize all messages]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.SerializeAllCreators">
            <summary>
                Gets a value indicating whether [serialize all creators].
            </summary>
            <value><c>true</c> if [serialize all creators]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.CreationTimeout">
            <summary>
                Gets the creation timeout.
            </summary>
            <value>The creation timeout.</value>
        </member>
        <member name="P:Akka.Actor.Settings.UnstartedPushTimeout">
            <summary>
                Gets the unstarted push timeout.
            </summary>
            <value>The unstarted push timeout.</value>
        </member>
        <member name="P:Akka.Actor.Settings.LogLevel">
            <summary>
                Gets the log level.
            </summary>
            <value>The log level.</value>
        </member>
        <member name="P:Akka.Actor.Settings.StdoutLogLevel">
            <summary>
                Gets the stdout log level.
            </summary>
            <value>The stdout log level.</value>
        </member>
        <member name="P:Akka.Actor.Settings.Loggers">
            <summary>
                Gets the loggers.
            </summary>
            <value>The loggers.</value>
        </member>
        <member name="P:Akka.Actor.Settings.LoggerStartTimeout">
            <summary>
                Gets the logger start timeout.
            </summary>
            <value>The logger start timeout.</value>
        </member>
        <member name="P:Akka.Actor.Settings.LogConfigOnStart">
            <summary>
                Gets a value indicating whether [log configuration on start].
            </summary>
            <value><c>true</c> if [log configuration on start]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.LogDeadLetters">
            <summary>
                Gets the log dead letters.
            </summary>
            <value>The log dead letters.</value>
        </member>
        <member name="P:Akka.Actor.Settings.LogDeadLettersDuringShutdown">
            <summary>
                Gets a value indicating whether [log dead letters during shutdown].
            </summary>
            <value><c>true</c> if [log dead letters during shutdown]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.AddLoggingReceive">
            <summary>
                Gets a value indicating whether [add logging receive].
            </summary>
            <value><c>true</c> if [add logging receive]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.DebugAutoReceive">
            <summary>
                Gets a value indicating whether [debug automatic receive].
            </summary>
            <value><c>true</c> if [debug automatic receive]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.DebugEventStream">
            <summary>
                Gets a value indicating whether [debug event stream].
            </summary>
            <value><c>true</c> if [debug event stream]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.DebugUnhandledMessage">
            <summary>
                Gets a value indicating whether [debug unhandled message].
            </summary>
            <value><c>true</c> if [debug unhandled message]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.DebugRouterMisconfiguration">
            <summary>
                Gets a value indicating whether [debug router misconfiguration].
            </summary>
            <value><c>true</c> if [debug router misconfiguration]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.Home">
            <summary>
                Gets the home.
            </summary>
            <value>The home.</value>
        </member>
        <member name="P:Akka.Actor.Settings.DebugLifecycle">
            <summary>
                Gets a value indicating whether [debug lifecycle].
            </summary>
            <value><c>true</c> if [debug lifecycle]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.DefaultVirtualNodesFactor">
            <summary>
            The number of default virtual nodes to use with <see cref="T:Akka.Routing.ConsistentHashingRoutingLogic"/>.
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.AbstractStash">
            <summary>INTERNAL
            Abstract base class for stash support
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.IStash">
            <summary>
            Public interface used to expose stash capabilities to user-level actors
            </summary>
        </member>
        <member name="M:Akka.Actor.IStash.Stash">
            <summary>
            Stashes the current message (the message that the actor received last)
            </summary>
        </member>
        <member name="M:Akka.Actor.IStash.Unstash">
            <summary>
            Unstash the oldest message in the stash and prepends it to the actor's mailbox.
            The message is removed from the stash.
            </summary>
        </member>
        <member name="M:Akka.Actor.IStash.UnstashAll">
            <summary>
            Unstashes all messages by prepending them to the actor's mailbox.
            The stash is guaranteed to be empty afterwards.
            </summary>
        </member>
        <member name="M:Akka.Actor.IStash.UnstashAll(System.Func{Akka.Actor.Envelope,System.Boolean})">
            <summary>
            Unstashes all messages selected by the predicate function. Other messages are discarded.
            The stash is guaranteed to be empty afterwards.
            </summary>
        </member>
        <member name="M:Akka.Actor.IStash.ClearStash">
            <summary>
            Returns all messages and clears the stash.
            The stash is guaranteed to be empty afterwards.
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.AbstractStash.#ctor(Akka.Actor.IActorContext,System.Int32)">
            <summary>INTERNAL
            Abstract base class for stash support
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.AbstractStash.Stash">
            <summary>
            Stashes the current message in the actor's state.
            </summary>
            <exception cref="T:Akka.Actor.IllegalActorStateException">Thrown if we attempt to stash the same message more than once.</exception>
            <exception cref="T:Akka.Actor.StashOverflowException">Thrown in the event that we're using a <see cref="T:Akka.Dispatch.MessageQueues.BoundedMessageQueue"/> 
            for the <see cref="T:Akka.Actor.IStash"/> and we've exceeded capacity.</exception>
        </member>
        <member name="M:Akka.Actor.Internal.AbstractStash.Unstash">
            <summary>
            Unstash the most recently stashed message (top of the message stack.)
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.AbstractStash.UnstashAll">
            <summary>
            Unstash all of the <see cref="T:Akka.Actor.Envelope"/>s in the Stash.
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.AbstractStash.UnstashAll(System.Func{Akka.Actor.Envelope,System.Boolean})">
            <summary>
            Unstash all of the <see cref="T:Akka.Actor.Envelope"/>s in the Stash.
            </summary>
            <param name="predicate">A predicate function to determine which messages to select.</param>
        </member>
        <member name="M:Akka.Actor.Internal.AbstractStash.ClearStash">
            <summary>
            Eliminates the contents of the <see cref="T:Akka.Actor.IStash"/>, and returns
            the previous contents of the messages.
            </summary>
            <returns>Previously stashed messages.</returns>
        </member>
        <member name="M:Akka.Actor.Internal.AbstractStash.EnqueueFirst(Akka.Actor.Envelope)">
            <summary>
            Enqueues <paramref name="msg"/> at the first position in the mailbox. If the message contained in
            the envelope is a <see cref="T:Akka.Actor.Terminated"/> message, it will be ensured that it can be re-received
            by the actor.
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.BoundedStashImpl">
            <summary>INTERNAL
            A stash implementation that is bounded
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.BoundedStashImpl.#ctor(Akka.Actor.IActorContext,System.Int32)">
            <summary>INTERNAL
            A stash implementation that is bounded
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.IActorStash">
            <summary>
            Marker interface for adding stash support
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorStash.Stash">
            <summary>
            Gets or sets the stash. This will be automatically populated by the framework AFTER the constructor has been run.
            Implement this as an auto property.
            </summary>
            <value>
            The stash.
            </value>
        </member>
        <member name="M:Akka.Actor.ActorStashPlugin.CanBeAppliedTo(System.Type)">
            <summary>
            Stash plugin is applied to all actors implementing <see cref="T:Akka.Actor.IActorStash"/> interface.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorStashPlugin.AfterIncarnated(Akka.Actor.ActorBase,Akka.Actor.IActorContext)">
            <summary>
            Creates a new stash for specified <paramref name="actor"/> if it has not been initialized already.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorStashPlugin.BeforeIncarnated(Akka.Actor.ActorBase,Akka.Actor.IActorContext)">
            <summary>
            Ensures, that all stashed messages inside <paramref name="actor"/> stash have been unstashed.
            </summary>
        </member>
        <member name="T:Akka.Actor.UntypedActorWithBoundedStash">
            <summary>
            An UntypedActor with bounded Stash capabilities
            </summary>
        </member>
        <member name="T:Akka.Actor.IWithBoundedStash">
            <summary>
            Lets the <see cref="T:Akka.Actor.StashFactory"/> know that this Actor needs stash support
            with restricted storage capacity
            You need to add the property:
            <code>public IStash Stash { get; set; }</code>
            </summary>
        </member>
        <member name="M:Akka.Actor.UntypedActorWithBoundedStash.Stash">
            <summary>
            Stashes the current message
            </summary>
        </member>
        <member name="M:Akka.Actor.UntypedActorWithBoundedStash.Unstash">
            <summary>
            Unstash the oldest message in the stash
            </summary>
        </member>
        <member name="M:Akka.Actor.UntypedActorWithBoundedStash.UnstashAll">
            <summary>
            Unstashes all messages
            </summary>
        </member>
        <member name="M:Akka.Actor.UntypedActorWithBoundedStash.UnstashAll(System.Func{Akka.Actor.Envelope,System.Boolean})">
            <summary>
            Unstashes all messages selected by the predicate function
            </summary>
        </member>
        <member name="M:Akka.Actor.UntypedActorWithBoundedStash.PreRestart(System.Exception,System.Object)">
            <summary>
            Overridden callback. Prepends all messages in the stash to the mailbox,
            clears the stash, stops all children, and invokes the PostStop callback.
            </summary>
        </member>
        <member name="M:Akka.Actor.UntypedActorWithBoundedStash.PostStop">
            <summary>
            Overridden callback. Prepends all messages in the stash to the mailbox,
            clears the stash. Must be called when overriding this method; otherwise stashed messages won't be
            propagated to DeadLetters when actor stops.
            </summary>
        </member>
        <member name="P:Akka.Actor.UntypedActorWithBoundedStash.CurrentStash">
            <summary>
            The stash implementation available for this actor
            </summary>
        </member>
        <member name="T:Akka.Actor.StashFactory">
            <summary>
            Static factor used for creating Stash instances
            </summary>
        </member>
        <member name="T:Akka.Actor.StashOverflowException">
            <summary>
            Is thrown when the size of the Stash exceeds the capacity of the stash
            </summary>
        </member>
        <member name="T:Akka.Actor.AkkaException">
            <summary>
                Class AkkaException.
            </summary>
        </member>
        <member name="M:Akka.Actor.AkkaException.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.AkkaException"/> class.
            </summary>
        </member>
        <member name="M:Akka.Actor.AkkaException.#ctor(System.String,System.Exception)">
            <summary>
                Initializes a new instance of the <see cref="T:System.Exception" /> class with a specified error message.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="cause">An inner exception responsible for this error.</param>
        </member>
        <member name="T:Akka.Actor.Internal.UnboundedStashImpl">
            <summary>INTERNAL
            A stash implementation that is unbounded
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.UnboundedStashImpl.#ctor(Akka.Actor.IActorContext)">
            <summary>INTERNAL
            A stash implementation that is bounded
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.UntypedActorWithUnboundedStash">
            <summary>
            An UntypedActor with Unbounded Stash capabilities
            </summary>
        </member>
        <member name="T:Akka.Actor.IWithUnboundedStash">
            <summary>
            Lets the <see cref="T:Akka.Actor.StashFactory"/> know that this Actor needs stash support
            with unrestricted storage capacity.
            You need to add the property:
            <code>public IStash Stash { get; set; }</code>
            </summary>
        </member>
        <member name="M:Akka.Actor.UntypedActorWithUnboundedStash.Stash">
            <summary>
            Stashes the current message
            </summary>
        </member>
        <member name="M:Akka.Actor.UntypedActorWithUnboundedStash.Unstash">
            <summary>
            Unstash the oldest message in the stash
            </summary>
        </member>
        <member name="M:Akka.Actor.UntypedActorWithUnboundedStash.UnstashAll">
            <summary>
            Unstashes all messages
            </summary>
        </member>
        <member name="M:Akka.Actor.UntypedActorWithUnboundedStash.UnstashAll(System.Func{Akka.Actor.Envelope,System.Boolean})">
            <summary>
            Unstashes all messages selected by the predicate function
            </summary>
        </member>
        <member name="M:Akka.Actor.UntypedActorWithUnboundedStash.PreRestart(System.Exception,System.Object)">
            <summary>
            Overridden callback. Prepends all messages in the stash to the mailbox,
            clears the stash, stops all children, and invokes the PostStop callback.
            </summary>
        </member>
        <member name="M:Akka.Actor.UntypedActorWithUnboundedStash.PostStop">
            <summary>
            Overridden callback. Prepends all messages in the stash to the mailbox,
            clears the stash. Must be called when overriding this method; otherwise stashed messages won't be
            propagated to DeadLetters when actor stops.
            </summary>
        </member>
        <member name="P:Akka.Actor.UntypedActorWithUnboundedStash.CurrentStash">
            <summary>
            The stash implementation available for this actor
            </summary>
        </member>
        <member name="T:Akka.Actor.TaskBasedScheduler">
            <summary>
            Class Scheduler.
            </summary>
        </member>
        <member name="T:Akka.Configuration.ConfigurationFactory">
            <summary>
                Class ConfigurationFactory.
            </summary>
        </member>
        <member name="M:Akka.Configuration.ConfigurationFactory.ParseString(System.String)">
            <summary>
                Parses the string.
            </summary>
            <param name="hocon">The json.</param>
            <returns>Config.</returns>
        </member>
        <member name="M:Akka.Configuration.ConfigurationFactory.Load">
            <summary>
                Loads this instance.
            </summary>
            <returns>Config.</returns>
        </member>
        <member name="M:Akka.Configuration.ConfigurationFactory.Default">
            <summary>
                Defaults this instance.
            </summary>
            <returns>Config.</returns>
        </member>
        <member name="M:Akka.Configuration.ConfigurationFactory.FromResource(System.String)">
            <summary>
                Froms the resource.
            </summary>
            <param name="resourceName">Name of the resource.</param>
            <returns>Config.</returns>
        </member>
        <member name="P:Akka.Configuration.ConfigurationFactory.Empty">
            <summary>
                Gets the empty.
            </summary>
            <value>The empty.</value>
        </member>
        <member name="M:Akka.Configuration.Config.GetValue(System.String)">
            <summary>
            Return a <see cref="T:Akka.Configuration.Hocon.HoconValue"/> from a specific path.
            </summary>
            <param name="path">The path for which we're loading a value.</param>
            <returns>The <see cref="T:Akka.Configuration.Hocon.HoconValue"/> found at the location if one exists, otherwise <c>null</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.HasPath(System.String)">
            <summary>
            Determine if a HOCON configuration element exists at the specified location
            </summary>
            <param name="path">The location to check for a configuration value.</param>
            <returns><c>true</c> if a value was found, <c>false</c> otherwise.</returns>
        </member>
        <member name="P:Akka.Configuration.Config.IsEmpty">
            <summary>
                Lets the caller know if this root node contains any values
            </summary>
        </member>
        <member name="P:Akka.Configuration.Config.Root">
            <summary>
                Returns the root node of this configuration section
            </summary>
        </member>
        <member name="M:Akka.Configuration.ConfigExtensions.IsNullOrEmpty(Akka.Configuration.Config)">
            <summary>
                Convenience method for determining if <see cref="T:Akka.Configuration.Config"/> has any usable content period.
            </summary>
            <returns>true if the <see cref="T:Akka.Configuration.Config"/> is null or <see cref="P:Akka.Configuration.Config.IsEmpty"/> return true; false otherwise.</returns>
        </member>
        <member name="T:Akka.Configuration.Hocon.HoconArray">
            <summary>
                Class HoconArray.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconArray.IsString">
            <summary>
                Determines whether this instance is string.
            </summary>
            <returns><c>true</c> if this instance is string; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconArray.GetString">
            <summary>
                Gets the string.
            </summary>
            <returns>System.String.</returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconArray.IsArray">
            <summary>
                Determines whether this instance is array.
            </summary>
            <returns><c>true</c> if this instance is array; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconArray.GetArray">
            <summary>
                Gets the array.
            </summary>
            <returns>IList&lt;HoconValue&gt;.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconArray.ToString">
            <summary>
                Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>A <see cref="T:System.String"/> that represents this instance.</returns>
        </member>
        <member name="T:Akka.Configuration.Hocon.Parser">
            <summary>
                Class Parser.
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.Parser._substitutions">
            <summary>
                The substitutions
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.Parser._reader">
            <summary>
                The reader
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.Parser._root">
            <summary>
                The root
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.Parser.Parse(System.String)">
            <summary>
                Parses the specified text.
            </summary>
            <param name="text">The text.</param>
            <returns>HoconValue.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.Parser.ParseText(System.String)">
            <summary>
                Parses the text.
            </summary>
            <param name="text">The text.</param>
            <returns>HoconValue.</returns>
            <exception cref="T:System.Exception">Unresolved substitution: + sub.Path</exception>
        </member>
        <member name="M:Akka.Configuration.Hocon.Parser.ParseObject(Akka.Configuration.Hocon.HoconValue,System.Boolean)">
            <summary>
                Parses the object.
            </summary>
            <param name="owner">The owner.</param>
            <param name="root">if set to <c>true</c> [root].</param>
        </member>
        <member name="M:Akka.Configuration.Hocon.Parser.ParseKeyContent(Akka.Configuration.Hocon.HoconValue)">
            <summary>
                Parses the content of the key.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Akka.Configuration.Hocon.Parser.ParseValue(Akka.Configuration.Hocon.HoconValue)">
            <summary>
                Parses the value.
            </summary>
            <param name="owner">The owner.</param>
            <exception cref="T:System.Exception">End of file reached while trying to read a value</exception>
        </member>
        <member name="M:Akka.Configuration.Hocon.Parser.ParseTrailingWhitespace(Akka.Configuration.Hocon.HoconValue)">
            <summary>
                Parses the trailing whitespace.
            </summary>
            <param name="owner">The owner.</param>
        </member>
        <member name="M:Akka.Configuration.Hocon.Parser.ParseSubstitution(System.String)">
            <summary>
                Parses the substitution.
            </summary>
            <param name="value">The value.</param>
            <returns>HoconSubstitution.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.Parser.ParseArray">
            <summary>
                Parses the array.
            </summary>
            <returns>HoconArray.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.Parser.IgnoreComma">
            <summary>
                Ignores the comma.
            </summary>
        </member>
        <member name="T:Akka.Configuration.Hocon.HoconSubstitution">
            <summary>
                HOCON Substitution, e.g. $foo.bar
            </summary>
        </member>
        <member name="T:Akka.Configuration.Hocon.IMightBeAHoconObject">
            <summary>
                Marker interface to make it easier to retrieve Hocon objects for substitutions
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconSubstitution.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.HoconSubstitution"/> class.
            </summary>
            <param name="path">The path.</param>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconSubstitution.IsString">
            <summary>
                Determines whether this instance is string.
            </summary>
            <returns><c>true</c> if this instance is string; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconSubstitution.GetString">
            <summary>
                Returns the value of this instance as a string.
            </summary>
            <returns>System.String.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconSubstitution.IsArray">
            <summary>
                Determines whether this instance is array.
            </summary>
            <returns><c>true</c> if this instance is array; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconSubstitution.GetArray">
            <summary>
                Returns the value of this instance as an array.
            </summary>
            <returns>IList&lt;HoconValue&gt;.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconSubstitution.IsObject">
            <summary>
                Determines whether this instance is an HOCON object.
            </summary>
            <returns><c>true</c> if this instance is object; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconSubstitution.GetObject">
            <summary>
                Returns the value of this instance as an HOCON object.
            </summary>
            <returns>HoconObject.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconSubstitution.op_Implicit(Akka.Configuration.Hocon.HoconSubstitution)~Akka.Configuration.Hocon.HoconObject">
            <summary>
                Performs an implicit conversion from <see cref="T:Akka.Configuration.Hocon.HoconSubstitution"/> to <see cref="T:Akka.Configuration.Hocon.HoconObject"/>.
            </summary>
            <param name="substitution">The substitution.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="P:Akka.Configuration.Hocon.HoconSubstitution.Path">
            <summary>
                The full path to the value which should substitute this instance.
            </summary>
            <value>The path.</value>
        </member>
        <member name="P:Akka.Configuration.Hocon.HoconSubstitution.ResolvedValue">
            <summary>
                The evaluated value from the Path property
            </summary>
            <value>The resolved value.</value>
        </member>
        <member name="T:Akka.Configuration.Hocon.TokenType">
            <summary>
                Enum TokenType
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.Comment">
            <summary>
                The comment
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.Key">
            <summary>
                The key
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.LiteralValue">
            <summary>
                The literal value
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.Assign">
            <summary>
                The assign
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.ObjectStart">
            <summary>
                The object start
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.ObjectEnd">
            <summary>
                The object end
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.Dot">
            <summary>
                The dot
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.EoF">
            <summary>
                The eo f
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.ArrayStart">
            <summary>
                The array start
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.ArrayEnd">
            <summary>
                The array end
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.Comma">
            <summary>
                The comma
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.Substitute">
            <summary>
                The substitute
            </summary>
        </member>
        <member name="T:Akka.Configuration.Hocon.Token">
            <summary>
                Class Token.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.Token.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.Token"/> class.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.Token.#ctor(Akka.Configuration.Hocon.TokenType)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.Token"/> class.
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="M:Akka.Configuration.Hocon.Token.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.Token"/> class.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Akka.Configuration.Hocon.Token.Key(System.String)">
            <summary>
                Creates a Key token.
            </summary>
            <param name="key">The key.</param>
            <returns>Token.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.Token.Substitution(System.String)">
            <summary>
                Creates a Substitution token with a given Path
            </summary>
            <param name="path">The path.</param>
            <returns>Token.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.Token.LiteralValue(System.String)">
            <summary>
                Creates a string Literal token.
            </summary>
            <param name="value">The value.</param>
            <returns>Token.</returns>
        </member>
        <member name="P:Akka.Configuration.Hocon.Token.Value">
            <summary>
                If this instance is a LiteralValue, the Value property holds the string literal.
            </summary>
            <value>The value.</value>
        </member>
        <member name="P:Akka.Configuration.Hocon.Token.Type">
            <summary>
                The type of the token.
            </summary>
            <value>The type.</value>
        </member>
        <member name="T:Akka.Configuration.Hocon.Tokenizer">
            <summary>
                Class Tokenizer.
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.Tokenizer._text">
            <summary>
                The text
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.Tokenizer._index">
            <summary>
                The index
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.Tokenizer.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.Tokenizer"/> class.
            </summary>
            <param name="text">The text.</param>
        </member>
        <member name="M:Akka.Configuration.Hocon.Tokenizer.Matches(System.String)">
            <summary>
                Matches the specified pattern.
            </summary>
            <param name="pattern">The pattern.</param>
            <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.Tokenizer.Take(System.Int32)">
            <summary>
                Takes the specified length.
            </summary>
            <param name="length">The length.</param>
            <returns>System.String.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.Tokenizer.Matches(System.String[])">
            <summary>
                Matches the specified patterns.
            </summary>
            <param name="patterns">The patterns.</param>
            <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.Tokenizer.Peek">
            <summary>
                Peeks this instance.
            </summary>
            <returns>System.Char.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.Tokenizer.Take">
            <summary>
                Takes this instance.
            </summary>
            <returns>System.Char.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.Tokenizer.PullWhitespace">
            <summary>
                Pulls the whitespace.
            </summary>
        </member>
        <member name="P:Akka.Configuration.Hocon.Tokenizer.EoF">
            <summary>
                Gets a value indicating whether [eof].
            </summary>
            <value><c>true</c> if [eof]; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:Akka.Configuration.Hocon.HoconTokenizer">
            <summary>
                Class HoconTokenizer.
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.HoconTokenizer.NotInUnquotedKey">
            <summary>
                The not in unquoted key
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.HoconTokenizer.NotInUnquotedText">
            <summary>
                The not in unquoted text
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.HoconTokenizer"/> class.
            </summary>
            <param name="text">The text.</param>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullWhitespaceAndComments">
            <summary>
                Pulls the whitespace and comments.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullRestOfLine">
            <summary>
                Pulls the rest of line.
            </summary>
            <returns>System.String.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullNext">
            <summary>
                Pulls the next.
            </summary>
            <returns>Token.</returns>
            <exception cref="T:System.Exception">unknown token</exception>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsStartOfQuotedKey">
            <summary>
                Determines whether [is start of quoted key].
            </summary>
            <returns><c>true</c> if [is start of quoted key]; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullArrayEnd">
            <summary>
                Pulls the array end.
            </summary>
            <returns>Token.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsArrayEnd">
            <summary>
                Determines whether [is array end].
            </summary>
            <returns><c>true</c> if [is array end]; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsArrayStart">
            <summary>
                Determines whether [is array start].
            </summary>
            <returns><c>true</c> if [is array start]; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullArrayStart">
            <summary>
                Pulls the array start.
            </summary>
            <returns>Token.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullDot">
            <summary>
                Pulls the dot.
            </summary>
            <returns>Token.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullComma">
            <summary>
                Pulls the comma.
            </summary>
            <returns>Token.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullStartOfObject">
            <summary>
                Pulls the start of object.
            </summary>
            <returns>Token.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullEndOfObject">
            <summary>
                Pulls the end of object.
            </summary>
            <returns>Token.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullAssignment">
            <summary>
                Pulls the assignment.
            </summary>
            <returns>Token.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsComma">
            <summary>
                Determines whether this instance is comma.
            </summary>
            <returns><c>true</c> if this instance is comma; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsDot">
            <summary>
                Determines whether this instance is dot.
            </summary>
            <returns><c>true</c> if this instance is dot; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsObjectStart">
            <summary>
                Determines whether [is object start].
            </summary>
            <returns><c>true</c> if [is object start]; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsEndOfObject">
            <summary>
                Determines whether [is end of object].
            </summary>
            <returns><c>true</c> if [is end of object]; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsAssignment">
            <summary>
                Determines whether this instance is assignment.
            </summary>
            <returns><c>true</c> if this instance is assignment; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsStartOfQuotedText">
            <summary>
                Determines whether [is start of quoted text].
            </summary>
            <returns><c>true</c> if [is start of quoted text]; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsStartOfTripleQuotedText">
            <summary>
                Determines whether [is start of triple quoted text].
            </summary>
            <returns><c>true</c> if [is start of triple quoted text]; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullComment">
            <summary>
                Pulls the comment.
            </summary>
            <returns>Token.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullUnquotedKey">
            <summary>
                Pulls the unquoted key.
            </summary>
            <returns>Token.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsUnquotedKey">
            <summary>
                Determines whether [is unquoted key].
            </summary>
            <returns><c>true</c> if [is unquoted key]; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsUnquotedKeyStart">
            <summary>
                Determines whether [is unquoted key start].
            </summary>
            <returns><c>true</c> if [is unquoted key start]; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsWhitespace">
            <summary>
                Determines whether this instance is whitespace.
            </summary>
            <returns><c>true</c> if this instance is whitespace; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullTripleQuotedText">
            <summary>
                Pulls the triple quoted text.
            </summary>
            <returns>Token.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullQuotedText">
            <summary>
                Pulls the quoted text.
            </summary>
            <returns>Token.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullQuotedKey">
            <summary>
                Pulls the quoted key.
            </summary>
            <returns>Token.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullEscapeSequence">
            <summary>
                Pulls the escape sequence.
            </summary>
            <returns>System.String.</returns>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsStartOfComment">
            <summary>
                Determines whether [is start of comment].
            </summary>
            <returns><c>true</c> if [is start of comment]; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullValue">
            <summary>
                Pulls the value.
            </summary>
            <returns>Token.</returns>
            <exception cref="T:System.Exception">
                Expected value: Null literal, Array, Number, Boolean, Quoted Text, Unquoted Text,
                Triple quoted Text, Object or End of array
            </exception>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsSubstitutionStart">
            <summary>
                Determines whether [is substitution start].
            </summary>
            <returns><c>true</c> if [is substitution start]; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullSubstitution">
            <summary>
                Pulls the substitution.
            </summary>
            <returns>Token.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsSpaceOrTab">
            <summary>
                Determines whether [is space or tab].
            </summary>
            <returns><c>true</c> if [is space or tab]; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsStartSimpleValue">
            <summary>
                Determines whether [is start simple value].
            </summary>
            <returns><c>true</c> if [is start simple value]; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullSpaceOrTab">
            <summary>
                Pulls the space or tab.
            </summary>
            <returns>Token.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullUnquotedText">
            <summary>
                Pulls the unquoted text.
            </summary>
            <returns>Token.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsUnquotedText">
            <summary>
                Determines whether [is unquoted text].
            </summary>
            <returns><c>true</c> if [is unquoted text]; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullSimpleValue">
            <summary>
                Pulls the simple value.
            </summary>
            <returns>Token.</returns>
            <exception cref="T:System.Exception">No simple value found</exception>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsValue">
            <summary>
                Determines whether this instance is value.
            </summary>
            <returns><c>true</c> if this instance is value; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:Akka.Configuration.Hocon.HoconValue">
            <summary>
            Root type of HOCON configuration object
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.AtKey(System.String)">
            <summary>
            Wraps this <see cref="T:Akka.Configuration.Hocon.HoconValue"/> into a new <see cref="T:Akka.Configuration.Config"/> object at the specified key.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.IsObject">
            <summary>
            Determines if this <see cref="T:Akka.Configuration.Hocon.HoconValue"/> is a <see cref="T:Akka.Configuration.Hocon.HoconObject"/>
            </summary>
            <returns><c>true</c> if this value is a HOCON object, <c>false</c> otherwise.</returns>
        </member>
        <member name="P:Akka.Configuration.Hocon.HoconValue.IsEmpty">
            <summary>
            Returns true if this HOCON value doesn't contain any elements
            </summary>
        </member>
        <member name="P:Akka.Configuration.Hocon.HoconValue.Values">
            <summary>
            The list of elements inside this HOCON value
            </summary>
        </member>
        <member name="T:Akka.Dispatch.IDispatcherPrerequisites">
            <summary>
            Contextual information that's useful for dispatchers
            </summary>
        </member>
        <member name="P:Akka.Dispatch.IDispatcherPrerequisites.EventStream">
            <summary>
            The <see cref="P:Akka.Dispatch.IDispatcherPrerequisites.EventStream"/> that belongs to the current <see cref="T:Akka.Actor.ActorSystem"/>.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.IDispatcherPrerequisites.Scheduler">
            <summary>
            The <see cref="T:Akka.Actor.IScheduler"/> that belongs to the current <see cref="T:Akka.Actor.ActorSystem"/>.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.IDispatcherPrerequisites.Settings">
            <summary>
            The <see cref="P:Akka.Dispatch.IDispatcherPrerequisites.Settings"/> for the current <see cref="T:Akka.Actor.ActorSystem"/>.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.IDispatcherPrerequisites.Mailboxes">
            <summary>
            The list of registered <see cref="P:Akka.Dispatch.IDispatcherPrerequisites.Mailboxes"/> for the current <see cref="T:Akka.Actor.ActorSystem"/>.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.DefaultDispatcherPrerequisites">
            <summary>
            The default set of contextual data needed for <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/>s
            </summary>
        </member>
        <member name="M:Akka.Dispatch.DefaultDispatcherPrerequisites.#ctor(Akka.Event.EventStream,Akka.Actor.IScheduler,Akka.Actor.Settings,Akka.Dispatch.Mailboxes)">
            <summary>
            Default constructor...
            </summary>
        </member>
        <member name="T:Akka.Dispatch.MessageDispatcherConfigurator">
            <summary>
            Base class used for hooking new <see cref="T:Akka.Dispatch.MessageDispatcher"/> types into <see cref="T:Akka.Dispatch.Dispatchers"/>
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcherConfigurator.#ctor(Akka.Configuration.Config,Akka.Dispatch.IDispatcherPrerequisites)">
            <summary>
            Takes a <see cref="P:Akka.Dispatch.MessageDispatcherConfigurator.Config"/> object, usually passed in via <see cref="P:Akka.Actor.Settings.Config"/>
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcherConfigurator.Dispatcher">
            <summary>
            Returns a <see cref="M:Akka.Dispatch.MessageDispatcherConfigurator.Dispatcher"/> instance.
            
            Whether or not this <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/> returns a new instance 
            or returns a reference to an existing instance is an implementation detail of the
            underlying implementation.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Akka.Dispatch.MessageDispatcherConfigurator.Config">
            <summary>
            System-wide configuration
            </summary>
        </member>
        <member name="P:Akka.Dispatch.MessageDispatcherConfigurator.Prerequisites">
            <summary>
            The system prerequisites needed for this dispatcher to do its job
            </summary>
        </member>
        <member name="T:Akka.Dispatch.ThreadPoolDispatcherConfigurator">
            <summary>
            Used to create instances of the <see cref="T:Akka.Dispatch.ThreadPoolDispatcher"/>.
            
            <remarks>
            Always returns the same instance, since the <see cref="T:System.Threading.ThreadPool"/> is global.
            This is also the default dispatcher for all actors.
            </remarks>
            </summary>
        </member>
        <member name="T:Akka.Dispatch.TaskDispatcherConfigurator">
            <summary>
            Used to create instances of the <see cref="T:Akka.Dispatch.TaskDispatcher"/>.
            
            <remarks>
            Always returns the same instance.
            </remarks>
            </summary>
        </member>
        <member name="T:Akka.Dispatch.CurrentSynchronizationContextDispatcherConfigurator">
            <summary>
            Used to create instances of the <see cref="T:Akka.Dispatch.CurrentSynchronizationContextDispatcher"/>.
            
            <remarks>
            Always returns the a new instance.
            </remarks>
            </summary>
        </member>
        <member name="T:Akka.Dispatch.MessageDispatcher">
            <summary>
            Class responsible for pushing messages from an actor's mailbox into its
            receive methods. Comes in many different flavors.
            </summary>
        </member>
        <member name="F:Akka.Dispatch.MessageDispatcher.DefaultThroughput">
            <summary>
                The default throughput
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.#ctor(Akka.Dispatch.MessageDispatcherConfigurator)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.MessageDispatcher"/> class.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.Schedule(System.Action)">
            <summary>
                Schedules the specified run.
            </summary>
            <param name="run">The run.</param>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.Dispatch(Akka.Actor.ActorCell,Akka.Actor.Envelope)">
            <summary>
            Dispatches a user-defined message from a mailbox to an <see cref="T:Akka.Actor.ActorCell"/>        
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.SystemDispatch(Akka.Actor.ActorCell,Akka.Actor.Envelope)">
            <summary>
            Dispatches a <see cref="T:Akka.Dispatch.SysMsg.ISystemMessage"/> from a mailbox to an <see cref="T:Akka.Actor.ActorCell"/>        
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.Attach(Akka.Actor.ActorCell)">
            <summary>
            Attaches the dispatcher to the <see cref="T:Akka.Actor.ActorCell"/>
            
            <remarks>
            Practically, doesn't do very much right now - dispatchers aren't responsible for creating
            mailboxes in Akka.NET
            </remarks>
            </summary>
            <param name="cell">The ActorCell belonging to the actor who's attaching to this dispatcher.</param>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.Detach(Akka.Actor.ActorCell)">
            <summary>
            Detaches the dispatcher to the <see cref="T:Akka.Actor.ActorCell"/>
            
            <remarks>
            Only really used in dispatchers with 1:1 relationship with dispatcher.
            </remarks>
            </summary>
            <param name="cell">The ActorCell belonging to the actor who's deatching from this dispatcher.</param>
        </member>
        <member name="P:Akka.Dispatch.MessageDispatcher.Configurator">
            <summary>
            The configurator used to configure this message dispatcher.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.MessageDispatcher.Id">
            <summary>
            The ID for this dispatcher.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.MessageDispatcher.ThroughputDeadlineTime">
            <summary>
                Gets or sets the throughput deadline time.
            </summary>
            <value>The throughput deadline time.</value>
        </member>
        <member name="P:Akka.Dispatch.MessageDispatcher.Throughput">
            <summary>
                Gets or sets the throughput.
            </summary>
            <value>The throughput.</value>
        </member>
        <member name="T:Akka.Dispatch.BoundedDequeBasedMailbox">
            <summary>
            Mailbox with support for EnqueueFirst
            </summary>
        </member>
        <member name="T:Akka.Dispatch.Mailbox`2">
            <summary>
            Class Mailbox of TSys,TUser.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox`2.Schedule">
            <summary>
            Schedules this instance.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox`2.Post(Akka.Actor.IActorRef,Akka.Actor.Envelope)">
            <summary>
            Posts the specified envelope.
            </summary>
            <param name="receiver"></param>
            <param name="envelope"> The envelope. </param>
        </member>
        <member name="M:Akka.Dispatch.Mailbox`2.BecomeClosed">
            <summary>
            Stops this instance.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox`2.Dispose(System.Boolean)">
            <summary>
            Disposes this instance.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.IDequeBasedMailbox">
            <summary>
            Used for <see cref="!:MessageQueue"/> instances that support double-ended queues.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.IDequeBasedMailbox.EnqueueFirst(Akka.Actor.Envelope)">
            <summary>
            Enqueues an <see cref="T:Akka.Actor.Envelope"/> to the front of
            the <see cref="!:MessageQueue"/>. Typically called during
            a <see cref="M:Akka.Actor.IStash.Unstash"/> or <see cref="M:Akka.Actor.IStash.UnstashAll"/>operation.
            </summary>
            <param name="envelope">The message that will be prepended to the queue.</param>
        </member>
        <member name="M:Akka.Dispatch.IDequeBasedMailbox.Post(Akka.Actor.IActorRef,Akka.Actor.Envelope)">
            <summary>
            Posts a message to the back of the <see cref="!:MessageQueue"/>
            </summary>
            <param name="receiver">The intended recipient of the message.</param>
            <param name="envelope">The message that will be appended to the queue.</param>
        </member>
        <member name="T:Akka.Dispatch.CachingConfig">
            <summary>
            INTERNAL API
            
            A <see cref="T:Akka.Dispatch.CachingConfig"/> is a <see cref="T:Akka.Configuration.Config"/> that wraps another <see cref="T:Akka.Configuration.Config"/> and is used to
            cache path lookup and string retrieval, which we happen to do in some critical paths of the actor creation
            and mailbox selection code.
            
            All other <see cref="T:Akka.Configuration.Config"/> operations are delegated to the wrapped <see cref="T:Akka.Configuration.Config"/>.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.ConcurrentQueueMailbox">
            <summary>
            Class ConcurrentQueueMailbox.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.ConcurrentQueueMailbox.Schedule">
            <summary>
            Schedules this instance.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.ConcurrentQueueMailbox.Post(Akka.Actor.IActorRef,Akka.Actor.Envelope)">
            <summary>
            Posts the specified envelope.
            </summary>
            <param name="receiver"></param>
            <param name="envelope"> The envelope. </param>
        </member>
        <member name="M:Akka.Dispatch.ConcurrentQueueMailbox.BecomeClosed">
            <summary>
            Stops this instance.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.ConcurrentQueueMailbox.Dispose(System.Boolean)">
            <summary>
            Disposes this instance.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.ForkJoinDispatcherConfigurator">
            <summary>
            <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/> for the <see cref="T:Akka.Dispatch.ForkJoinDispatcher"/>.
            
            Creates a single <see cref="T:Akka.Dispatch.ForkJoinDispatcher"/> instance and returns the same instance
            each time <see cref="M:Akka.Dispatch.ForkJoinDispatcherConfigurator.Dispatcher"/> is called.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.ForkJoinDispatcher">
            <summary>
            ForkJoinDispatcher - custom multi-threaded dispatcher that runs on top of a 
            <see cref="T:Helios.Concurrency.DedicatedThreadPool"/>, designed to be used for mission-critical actors
            that can't afford <see cref="T:System.Threading.ThreadPool"/> starvation.
            
            Relevant configuration options:
            <code>
                my-forkjoin-dispatcher{
                        type = ForkJoinDispatcher
                        throughput = 100
                        dedicated-thread-pool{ #settings for Helios.DedicatedThreadPool
            	            thread-count = 3 #number of threads
            	            #deadlock-timeout = 3s #optional timeout for deadlock detection
            	            threadtype = background #values can be "background" or "foreground"
                        }
                }
            </code>
            </summary>
        </member>
        <member name="M:Akka.Dispatch.DispatcherExtensions.ScheduleAsync``1(Akka.Dispatch.MessageDispatcher,System.Func{``0})">
            <summary>
            Schedules the specified run and returns a continuation task.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.ThreadPoolDispatcher">
            <summary>
                Class ThreadPoolDispatcher.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.ThreadPoolDispatcher.#ctor(Akka.Dispatch.MessageDispatcherConfigurator)">
            <summary>
            Takes a <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/>
            </summary>
        </member>
        <member name="M:Akka.Dispatch.ThreadPoolDispatcher.Schedule(System.Action)">
            <summary>
                Schedules the specified run.
            </summary>
            <param name="run">The run.</param>
        </member>
        <member name="T:Akka.Dispatch.CurrentSynchronizationContextDispatcher">
            <summary>
                Dispatcher that dispatches messages on the current synchronization context, e.g. WinForms or WPF GUI thread
            </summary>
        </member>
        <member name="F:Akka.Dispatch.CurrentSynchronizationContextDispatcher._scheduler">
            <summary>
                The scheduler
            </summary>
        </member>
        <member name="M:Akka.Dispatch.CurrentSynchronizationContextDispatcher.#ctor(Akka.Dispatch.MessageDispatcherConfigurator)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.CurrentSynchronizationContextDispatcher"/> class.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.CurrentSynchronizationContextDispatcher.Schedule(System.Action)">
            <summary>
                Schedules the specified run.
            </summary>
            <param name="run">The run.</param>
        </member>
        <member name="T:Akka.Dispatch.Dispatchers">
            <summary>
            The registry of all <see cref="T:Akka.Dispatch.MessageDispatcher"/> instances available to this <see cref="T:Akka.Actor.ActorSystem"/>.
            </summary>
        </member>
        <member name="F:Akka.Dispatch.Dispatchers.DefaultDispatcherId">
            <summary>
                The default dispatcher identifier, also the full key of the configuration of the default dispatcher.
            </summary>
        </member>
        <member name="F:Akka.Dispatch.Dispatchers._dispatcherConfigurators">
            <summary>
            The list of all configurators used to create <see cref="T:Akka.Dispatch.MessageDispatcher"/> instances.
            
            Has to be thread-safe, as this collection can be accessed concurrently by many actors.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Dispatchers.#ctor(Akka.Actor.ActorSystem,Akka.Dispatch.IDispatcherPrerequisites)">
            <summary>Initializes a new instance of the <see cref="T:Akka.Dispatch.Dispatchers"/> class.</summary>
            <param name="system">The system.</param>
            <param name="prerequisites">The prerequisites required for some <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/> instances.</param>
        </member>
        <member name="M:Akka.Dispatch.Dispatchers.ReloadPrerequisites(Akka.Dispatch.IDispatcherPrerequisites)">
            <summary>
            INTERNAL API
            
            Used when a plugin like Akka.Persistence needs to be able to load dispatcher configurations to the chain.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Dispatchers.Lookup(System.String)">
            <summary>
            Returns a dispatcher as specified in configuration. Please note that this method _MAY_
            create and return a new dispatcher on _EVERY_ call.
            </summary>
            <exception cref="T:Akka.Configuration.ConfigurationException">If the specified dispatcher cannot be found in configuration.</exception>
        </member>
        <member name="M:Akka.Dispatch.Dispatchers.HasDispatcher(System.String)">
            <summary>
            Checks that configuration provides a section for the given dispatcher.
            This does not guarantee that no <see cref="T:Akka.Configuration.ConfigurationException"/> will be thrown
            when using the dispatcher, because the details can only be checked by trying to
            instantiate it, which might be undesirable when just checking.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Dispatchers.From(Akka.Configuration.Config)">
            <summary>
            INTERNAL API
            
            Creates a dispatcher from a <see cref="T:Akka.Configuration.Config"/>. Internal test purpose only.
            <code>
            From(Config.GetConfig(id));
            </code>
            
            The Config must also contain an `id` property, which is the identifier of the dispatcher.
            </summary>
            <param name="cfg">The provided configuration section.</param>
            <returns>An instance of the <see cref="T:Akka.Dispatch.MessageDispatcher"/>, if valid.</returns>
            <exception cref="T:Akka.Configuration.ConfigurationException">if the `id` property is missing from <see cref="!:cfg"/></exception>
            <exception cref="T:System.NotSupportedException">thrown if the dispatcher path or type cannot be resolved.</exception>
        </member>
        <member name="M:Akka.Dispatch.Dispatchers.RegisterConfigurator(System.String,Akka.Dispatch.MessageDispatcherConfigurator)">
            <summary>
            Register a <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/> that will be used by <see cref="M:Akka.Dispatch.Dispatchers.Lookup(System.String)"/>
            and <see cref="M:Akka.Dispatch.Dispatchers.HasDispatcher(System.String)"/> instead of looking up the configurator from the system
            configuration.
            
            This enables dynamic addition of dispatchers.
            
            <remarks>
            A <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/> for a certain id can only be registered once,
            i.e. it can not be replaced. It is safe to call this method multiple times, but only the
            first registration will be used.
            </remarks>
            </summary>
            <returns>This method returns <c>true</c> if the specified configurator was successfully registered.</returns>
        </member>
        <member name="M:Akka.Dispatch.Dispatchers.Config(System.String)">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="P:Akka.Dispatch.Dispatchers.DefaultGlobalDispatcher">
            <summary>Gets the one and only default dispatcher.</summary>
        </member>
        <member name="P:Akka.Dispatch.Dispatchers.DefaultDispatcherConfig">
            <summary>
            The <see cref="T:Akka.Configuration.Config"/> for the default dispatcher.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.Dispatchers.Prerequisites">
            <summary>
            The prerequisites required for some <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/> instances.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.DispatcherConfigurator">
            <summary>
            The cached <see cref="T:Akka.Dispatch.MessageDispatcher"/> factory that gets looked up via configuration
            inside <see cref="T:Akka.Dispatch.Dispatchers"/>
            </summary>
        </member>
        <member name="T:Akka.Actor.InvalidActorNameException">
            <summary>
            An InvalidActorNameException is thrown when the actor name is invalid
            </summary>
        </member>
        <member name="T:Akka.Actor.AskTimeoutException">
            <summary>
            Thrown when an Ask operation times out
            </summary>
        </member>
        <member name="T:Akka.Actor.ActorInitializationException">
            <summary>
            </summary>
        </member>
        <member name="T:Akka.Actor.LoggerInitializationException">
            <summary>
                Class LoggerInitializationException is thrown to indicate that there was a problem initializing a logger.
            </summary>
        </member>
        <member name="T:Akka.Actor.ActorKilledException">
            <summary>
            Thrown when a <see cref="T:Akka.Actor.Kill"/> message has been sent to an actor. <see cref="M:Akka.Actor.SupervisorStrategy.DefaultDecider(System.Exception)"/> will by default stop the actor.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorKilledException.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.ActorKilledException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="T:Akka.Actor.IllegalActorStateException">
            <summary>
            IllegalActorStateException is thrown when a core invariant in the Actor implementation has been violated.
            For instance, if you try to create an Actor that doesn't inherit from <see cref="T:Akka.Actor.ActorBase"/>.
            </summary>
        </member>
        <member name="T:Akka.Actor.IllegalActorNameException">
            <summary>
            IllegalActorNameException is thrown when an Actor with an invalid name is deployed our bound.
            </summary>
        </member>
        <member name="T:Akka.Actor.DeathPactException">
            <summary>
            A DeathPactException is thrown by an Actor that receives a Terminated(someActor) message
            that it doesn't handle itself, effectively crashing the Actor and escalating to the supervisor.
            </summary>
        </member>
        <member name="T:Akka.Actor.PreRestartException">
            <summary>
                Class PreRestartException.
            </summary>
        </member>
        <member name="T:Akka.Actor.PostRestartException">
            <summary>
            A PostRestartException is thrown when constructor or postRestart() method
            fails during a restart attempt.
            <para><see cref="!:PostRestartException.Actor"/>: actor is the actor whose constructor or postRestart() hook failed.</para>
            <para><see cref="!:PostRestartException.Cause"/>: cause is the exception thrown by that actor within preRestart()</para>
            <para><see cref="P:Akka.Actor.PostRestartException.OriginalCause"/>: originalCause is the exception which caused the restart in the first place</para>
            </summary>
        </member>
        <member name="M:Akka.Actor.PostRestartException.#ctor(Akka.Actor.IActorRef,System.Exception,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.PostRestartException"/> class.
            </summary>
            <param name="actor">The actor whose constructor or postRestart() hook failed.</param>
            <param name="cause">Cause is the exception thrown by that actor within preRestart().</param>
            <param name="originalCause">The original cause is the exception which caused the restart in the first place.</param>
        </member>
        <member name="T:Akka.Actor.ActorNotFoundException">
            <summary>
            Class ActorNotFoundException.
            </summary>
        </member>
        <member name="T:Akka.Actor.InvalidMessageException">
            <summary>
            InvalidMessageException is thrown when an invalid message is sent to an Actor.
            Currently only <c>null</c> is an invalid message.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.MessageQueues.BlockingMessageQueue">
            <summary> 
            Base class for blocking message queues. Allows non thread safe data structures to be used as message queues. 
            </summary>
        </member>
        <member name="T:Akka.Dispatch.MessageQueues.IMessageQueue">
            <summary> 
            Interface to be implemented by all mailbox message queues 
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.IMessageQueue.Enqueue(Akka.Actor.Envelope)">
            <summary> 
            Enqueues an mailbox envelope onto the message queue 
            </summary>
            <param name="envelope"> The envelope to enqueue </param>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.IMessageQueue.TryDequeue(Akka.Actor.Envelope@)">
            <summary> 
            Tries to pull an envelope of the message queue 
            </summary>
            <param name="envelope"> The envelope that was dequeued </param>
            <returns> </returns>
        </member>
        <member name="P:Akka.Dispatch.MessageQueues.IMessageQueue.HasMessages">
            <summary> 
            Tests if the message queue contains any messages 
            </summary>
        </member>
        <member name="P:Akka.Dispatch.MessageQueues.IMessageQueue.Count">
            <summary> 
            Returns the count of messages currently in the message queue 
            </summary>
        </member>
        <member name="T:Akka.Dispatch.IBlockingMessageQueueSemantics">
            <summary> 
            Semantics for message queues that are blocking 
            </summary>
        </member>
        <member name="T:Akka.Dispatch.IMultipleConsumerSemantics">
            <summary> 
            Semantics for message queues that support multiple consumers 
            </summary>
        </member>
        <member name="T:Akka.Dispatch.ISemantics">
            <summary>
            
            </summary>
        </member>
        <member name="P:Akka.Dispatch.IBlockingMessageQueueSemantics.BlockTimeOut">
            <summary> 
            The time to wait on a lock before throwing an timeout exception. 
            </summary>
        </member>
        <member name="T:Akka.Dispatch.MessageQueues.BoundedMessageQueue">
            <summary>An Bounded mailbox message queue.</summary>
        </member>
        <member name="T:Akka.Dispatch.IBoundedMessageQueueSemantics">
            <summary> 
            Semantics for message queues that have a bounded size 
            </summary>
        </member>
        <member name="P:Akka.Dispatch.IBoundedMessageQueueSemantics.PushTimeOut">
            <summary> 
            The enqueue time to wait until message is dropped to deadletters if the message queue is full 
            </summary>
        </member>
        <member name="T:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue">
            <summary>
            Message queue for supporting <see cref="T:Akka.Dispatch.IDequeBasedMessageQueueSemantics"/> within <see cref="T:Akka.Dispatch.Mailbox"/> instances.
            
            Uses a <see cref="T:System.Collections.Generic.Stack`1"/> internally - each individual <see cref="M:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue.EnqueueFirst(Akka.Actor.Envelope)"/>
            </summary>
        </member>
        <member name="T:Akka.Dispatch.IDequeBasedMessageQueueSemantics">
            <summary>
            Semantics for message queues that are Double-Ended.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue.#ctor(Akka.Dispatch.MessageQueues.IMessageQueue)">
            <summary>
            Takes another <see cref="!:MessageQueue"/> as an argument - wraps <see cref="!:messageQueue"/>
            in order to provide it with prepend (<see cref="M:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue.EnqueueFirst(Akka.Actor.Envelope)"/>) semantics.
            </summary>
            <param name="messageQueue"></param>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue.Enqueue(Akka.Actor.Envelope)">
            <summary>
            Enqueue a message to the back of the <see cref="!:MessageQueue"/>
            </summary>
            <param name="envelope"></param>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue.TryDequeue(Akka.Actor.Envelope@)">
            <summary>
            Attempt to dequeue a message from the front of the prepend buffer.
            
            If the prepend buffer is empty, dequeue a message from the normal
            <see cref="!:MessageQueue"/> wrapped but this wrapper.
            </summary>
            <param name="envelope">The message to return, if any</param>
            <returns><c>true</c> if a message was available, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue.EnqueueFirst(Akka.Actor.Envelope)">
            <summary>
            Add a message to the front of the queue via the prepend buffer.
            </summary>
            <param name="envelope">The message we wish to append to the front of the queue.</param>
        </member>
        <member name="P:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue.HasMessages">
            <summary>
            Returns true if there are any messages inside the queue.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue.Count">
            <summary>
            Returns the number of messages in both the internal message queue
            and the prepend buffer.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.IUnboundedMessageQueueSemantics">
            <summary> 
            Semantics for message queues that have an unbounded size 
            </summary>
        </member>
        <member name="T:Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics">
            <summary>
            Semantics for message queues that are Double-Ended and unbounded
            </summary>
        </member>
        <member name="T:Akka.Dispatch.IBoundedDequeBasedMessageQueueSemantics">
            <summary>
            Semantics for message queues that are Double-Ended and bounded
            </summary>
        </member>
        <member name="T:Akka.Dispatch.MessageQueues.UnboundedPriorityMessageQueue">
            <summary> 
            Base class message queue that uses a priority generator for messages 
            </summary>
        </member>
        <member name="T:Akka.Dispatch.MessageQueues.UnboundedMessageQueue">
            <summary> An unbounded mailbox message queue. </summary>
        </member>
        <member name="T:Akka.Dispatch.FutureActor">
            <summary>
                Class FutureActor.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.FutureActor.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.FutureActor"/> class.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.FutureActor.#ctor(System.Threading.Tasks.TaskCompletionSource{System.Object},Akka.Actor.IActorRef)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.FutureActor"/> class.
            </summary>
            <param name="completionSource">The completion source.</param>
            <param name="respondTo">The respond to.</param>
        </member>
        <member name="M:Akka.Dispatch.FutureActor.Receive(System.Object)">
            <summary>
                Processor for user defined messages.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="T:Akka.Actor.Props">
            <summary>
                Props is a configuration object used in creating an [[Actor]]; it is
                immutable, so it is thread-safe and fully shareable.
                Examples on C# API:
            <code>
              private Props props = Props.Empty();
              private Props props = Props.Create(() => new MyActor(arg1, arg2));
            
              private Props otherProps = props.WithDispatcher("dispatcher-id");
              private Props otherProps = props.WithDeploy(deployment info);
             </code>
            </summary>
        </member>
        <member name="F:Akka.Actor.Props.defaultDeploy">
            <summary>
                The default deploy
            </summary>
        </member>
        <member name="F:Akka.Actor.Props.noArgs">
            <summary>
                No args
            </summary>
        </member>
        <member name="F:Akka.Actor.Props.empty">
            <summary>
                A Props instance whose creator will create an actor that doesn't respond to any message
            </summary>
        </member>
        <member name="F:Akka.Actor.Props.None">
            <summary>
                The none
            </summary>
        </member>
        <member name="F:Akka.Actor.Props.defaultProducer">
            <summary>
                The default producer
            </summary>
        </member>
        <member name="F:Akka.Actor.Props.inputType">
            <summary>
                The intern type of the actor or the producer
            </summary>
        </member>
        <member name="F:Akka.Actor.Props.outputType">
            <summary>
                The extern type of the actor
            </summary>
        </member>
        <member name="F:Akka.Actor.Props.producer">
            <summary>
                The producer of the actor
            </summary>
        </member>
        <member name="M:Akka.Actor.Props.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.Props"/> class.
            </summary>
        </member>
        <member name="M:Akka.Actor.Props.#ctor(Akka.Actor.Props)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.Props"/> class from a copy.
            </summary>
        </member>
        <member name="M:Akka.Actor.Props.#ctor(System.Type,System.Object[])">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.Props"/> class.
            </summary>
            <param name="type">The type.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Akka.Actor.Props.#ctor(System.Type)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.Props"/> class.
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="M:Akka.Actor.Props.#ctor(System.Type,Akka.Actor.SupervisorStrategy,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.Props"/> class.
            </summary>
            <param name="type">The type.</param>
            <param name="supervisorStrategy">The supervisor strategy.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Akka.Actor.Props.#ctor(System.Type,Akka.Actor.SupervisorStrategy,System.Object[])">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.Props"/> class.
            </summary>
            <param name="type">The type.</param>
            <param name="supervisorStrategy">The supervisor strategy.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Akka.Actor.Props.#ctor(Akka.Actor.Deploy,System.Type,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.Props"/> class.
            </summary>
            <param name="deploy">The deploy.</param>
            <param name="type">The type.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Akka.Actor.Props.#ctor(Akka.Actor.Deploy,System.Type,System.Object[])">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.Props"/> class.
            </summary>
            <param name="deploy">The deploy.</param>
            <param name="type">The type.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Akka.Actor.Props.Create``1(System.Linq.Expressions.Expression{System.Func{``0}},Akka.Actor.SupervisorStrategy)">
            <summary>
                Creates the specified factory.
            </summary>
            <typeparam name="TActor">The type of the actor.</typeparam>
            <param name="factory">The factory.</param>
            <param name="supervisorStrategy">Optional: Supervisor strategy</param>
            <returns>Props.</returns>
            <exception cref="T:System.ArgumentException">The create function must be a 'new T (args)' expression</exception>
        </member>
        <member name="M:Akka.Actor.Props.Create``1(System.Object[])">
            <summary>
                Creates this instance.
            </summary>
            <typeparam name="TActor">The type of the actor.</typeparam>
            <returns>Props.</returns>
        </member>
        <member name="M:Akka.Actor.Props.CreateBy``1(System.Object[])">
            <summary>
                Creates an actor by an actor producer
            </summary>
            <typeparam name="TProducer">The type of the actor producer</typeparam>
            <param name="args">The arguments</param>
            <returns>Props</returns>
        </member>
        <member name="M:Akka.Actor.Props.Create``1(Akka.Actor.SupervisorStrategy)">
            <summary>
                Creates this instance.
            </summary>
            <typeparam name="TActor">The type of the actor.</typeparam>
            <returns>Props.</returns>
        </member>
        <member name="M:Akka.Actor.Props.Create(System.Type,System.Object[])">
            <summary>
                Creates the specified type.
            </summary>
            <param name="type">The type.</param>
            <param name="args"></param>
            <returns>Props.</returns>
        </member>
        <member name="M:Akka.Actor.Props.WithMailbox(System.String)">
            <summary>
                Returns a new Props with the specified mailbox set.
            </summary>
            <param name="path">The path.</param>
            <returns>Props.</returns>
        </member>
        <member name="M:Akka.Actor.Props.WithDispatcher(System.String)">
            <summary>
                Returns a new Props with the specified dispatcher set.
            </summary>
            <param name="path">The path.</param>
            <returns>Props.</returns>
        </member>
        <member name="M:Akka.Actor.Props.WithRouter(Akka.Routing.RouterConfig)">
            <summary>
                Returns a new Props with the specified router config set.
            </summary>
            <param name="routerConfig">The router configuration.</param>
            <returns>Props.</returns>
        </member>
        <member name="M:Akka.Actor.Props.WithDeploy(Akka.Actor.Deploy)">
            <summary>
                Returns a new Props with the specified deployment configuration.
            </summary>
            <param name="deploy">The deploy.</param>
            <returns>Props.</returns>
        </member>
        <member name="M:Akka.Actor.Props.WithSupervisorStrategy(Akka.Actor.SupervisorStrategy)">
            <summary>
                Returns a new Props with the specified supervisor strategy set.
            </summary>
            <param name="strategy">The strategy.</param>
            <returns>Props.</returns>
        </member>
        <member name="M:Akka.Actor.Props.NewActor">
            <summary>
                Create a new actor instance. This method is only useful when called during
                actor creation by the ActorSystem.
            </summary>
            <returns>ActorBase.</returns>
        </member>
        <member name="M:Akka.Actor.Props.Copy">
            <summary>
                Copies this instance.
            </summary>
            <returns>Props.</returns>
        </member>
        <member name="P:Akka.Actor.Props.Type">
            <summary>
                Gets the type.
            </summary>
            <value>The type.</value>
        </member>
        <member name="P:Akka.Actor.Props.Dispatcher">
            <summary>
                Gets or sets the dispatcher.
            </summary>
            <value>The dispatcher.</value>
        </member>
        <member name="P:Akka.Actor.Props.Mailbox">
            <summary>
                Gets or sets the mailbox.
            </summary>
            <value>The mailbox.</value>
        </member>
        <member name="P:Akka.Actor.Props.RouterConfig">
            <summary>
                Gets or sets the router configuration.
            </summary>
            <value>The router configuration.</value>
        </member>
        <member name="P:Akka.Actor.Props.Deploy">
            <summary>
                Gets or sets the deploy.
            </summary>
            <value>The deploy.</value>
        </member>
        <member name="P:Akka.Actor.Props.SupervisorStrategy">
            <summary>
                Gets or sets the supervisor strategy.
            </summary>
            <value>The supervisor strategy.</value>
        </member>
        <member name="P:Akka.Actor.Props.Empty">
            <summary>
                A Props instance whose creator will create an actor that doesn't respond to any message
            </summary>
            <value>The empty.</value>
        </member>
        <member name="P:Akka.Actor.Props.Arguments">
            <summary>
                Gets the arguments.
            </summary>
            <value>The arguments.</value>
        </member>
        <member name="T:Akka.Actor.Props.EmptyActor">
            <summary>
            EmptyActor is used by <see cref="F:Akka.Actor.Props.None"/> in order to create actors that
            don't respond to any messages.
            </summary>
        </member>
        <member name="T:Akka.Actor.IIndirectActorProducer">
            <summary>
                This interface defines a class of actor creation strategies deviating from
                the usual default of just reflectively instantiating the [[Actor]]
                subclass. It can be used to allow a dependency injection framework to
                determine the actual actor class and how it shall be instantiated.
            </summary>
        </member>
        <member name="M:Akka.Actor.IIndirectActorProducer.Produce">
            <summary>
                This factory method must produce a fresh actor instance upon each
                invocation. It is not permitted to return the same instance more than
                once.
            </summary>
            <returns>A fresh actor instance.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Akka.Actor.IIndirectActorProducer.Release(Akka.Actor.ActorBase)" -->
        <member name="P:Akka.Actor.IIndirectActorProducer.ActorType">
            <summary>
                This method is used by [[Props]] to determine the type of actor which will
                be created. The returned type is not used to produce the actor.
            </summary>
        </member>
        <member name="T:Akka.Actor.DynamicProps`1">
            <summary>
                Props instance that uses dynamic invocation to create new Actor instances,
                rather than a traditional Activator.
                Intended to be used in conjunction with Dependency Injection.
            </summary>
            <typeparam name="TActor">The type of the actor.</typeparam>
        </member>
        <member name="F:Akka.Actor.DynamicProps`1.invoker">
            <summary>
                The _invoker
            </summary>
        </member>
        <member name="M:Akka.Actor.DynamicProps`1.#ctor(System.Func{`0})">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.DynamicProps`1"/> class.
            </summary>
            <param name="invoker">The invoker.</param>
        </member>
        <member name="M:Akka.Actor.DynamicProps`1.NewActor">
            <summary>
                News the actor.
            </summary>
            <returns>ActorBase.</returns>
        </member>
        <member name="M:Akka.Actor.DynamicProps`1.#ctor(Akka.Actor.Props,System.Func{`0})">
            <summary>
                Copy constructor
            </summary>
            <param name="copy">The copy.</param>
            <param name="invoker">The invoker.</param>
        </member>
        <member name="M:Akka.Actor.DynamicProps`1.Copy">
            <summary>
                Copies this instance.
            </summary>
            <returns>Props.</returns>
        </member>
        <member name="T:Akka.Actor.SupervisorStrategy">
            <summary>
                Base class for supervision strategies
            </summary>
        </member>
        <member name="M:Akka.Actor.SupervisorStrategy.Handle(Akka.Actor.IActorRef,System.Exception)">
            <summary>
                Handles the specified child.
            </summary>
            <param name="child">The actor that caused the evaluation to occur</param>
            <param name="x">The exception that caused the evaluation to occur.</param>
            <returns>Directive.</returns>
        </member>
        <member name="M:Akka.Actor.SupervisorStrategy.HandleFailure(Akka.Actor.ActorCell,System.Exception,Akka.Actor.Internal.ChildRestartStats,System.Collections.Generic.IReadOnlyCollection{Akka.Actor.Internal.ChildRestartStats})">
            <summary>
                This is the main entry point: in case of a child’s failure, this method
                must try to handle the failure by resuming, restarting or stopping the
                child (and returning `true`), or it returns `false` to escalate the
                failure, which will lead to this actor re-throwing the exception which
                caused the failure. The exception will not be wrapped.
                This method calls <see cref="T:Akka.Actor.SupervisorStrategy"/>, which will
                log the failure unless it is escalated. You can customize the logging by
                setting <see cref="T:Akka.Actor.SupervisorStrategy"/> to `false` and
                do the logging inside the `decider` or override the `LogFailure` method.
            </summary>
            <param name="actorCell">The actor cell.</param>
            <param name="cause">The cause.</param>
            <param name="failedChildStats">The stats for the failed child.</param>
            <param name="allChildren"></param>
            <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Actor.SupervisorStrategy.DefaultDecider(System.Exception)">
            <summary>
                When supervisorStrategy is not specified for an actor this
                Decider is used by default in the supervisor strategy.
                The child will be stopped when <see cref="T:Akka.Actor.ActorInitializationException"/>,
                <see cref="T:Akka.Actor.ActorKilledException"/>, or <see cref="T:Akka.Actor.DeathPactException"/> is
                thrown. It will be restarted for other `Exception` types.
                The error is escalated if it's a `Exception`, i.e. `Error`.
            </summary>
            <param name="exception">The exception.</param>
            <returns>Directive.</returns>
        </member>
        <member name="M:Akka.Actor.SupervisorStrategy.RestartChild(Akka.Actor.IActorRef,System.Exception,System.Boolean)">
            <summary>
                Restarts the child.
            </summary>
            <param name="child">The child.</param>
            <param name="cause">The cause.</param>
            <param name="suspendFirst">if set to <c>true</c> [suspend first].</param>
        </member>
        <member name="M:Akka.Actor.SupervisorStrategy.ProcessFailure(Akka.Actor.IActorContext,System.Boolean,System.Exception,Akka.Actor.Internal.ChildRestartStats,System.Collections.Generic.IReadOnlyCollection{Akka.Actor.Internal.ChildRestartStats})">
            <summary>
            This method is called to act on the failure of a child: restart if the flag is true, stop otherwise.
            </summary>
            <param name="context">The actor context.</param>
            <param name="restart">if set to <c>true</c> restart, stop otherwise.</param>
            <param name="cause">The exception that caused the child to fail.</param>
            <param name="failedChildStats">The stats for the child that failed. The ActorRef to the child can be obtained via the <see cref="P:Akka.Actor.Internal.ChildRestartStats.Child"/> property</param>
            <param name="allChildren">The stats for all children</param>
        </member>
        <member name="M:Akka.Actor.SupervisorStrategy.ResumeChild(Akka.Actor.IActorRef,System.Exception)">
            <summary>
             Resume the previously failed child: <b>do never apply this to a child which
             is not the currently failing child</b>. Suspend/resume needs to be done in
             matching pairs, otherwise actors will wake up too soon or never at all.
            </summary>
            <param name="child">The child.</param>
            <param name="exception">The exception.</param>
        </member>
        <member name="M:Akka.Actor.SupervisorStrategy.LogFailure(Akka.Actor.IActorContext,Akka.Actor.IActorRef,System.Exception,Akka.Actor.Directive)">
            <summary>
                Logs the failure.
            </summary>
            <param name="context">The actor cell.</param>
            <param name="child">The child.</param>
            <param name="cause">The cause.</param>
            <param name="directive">The directive.</param>
        </member>
        <member name="F:Akka.Actor.SupervisorStrategy.DefaultStrategy">
            <summary>
                When supervisorStrategy is not specified for an actor this
                is used by default. OneForOneStrategy with decider defined in
                <see cref="M:Akka.Actor.SupervisorStrategy.DefaultDecider(System.Exception)"/>.
            </summary>
            <value>The default.</value>
        </member>
        <member name="M:Akka.Actor.SupervisorStrategy.HandleChildTerminated(Akka.Actor.IActorContext,Akka.Actor.IActorRef,System.Collections.Generic.IEnumerable{Akka.Actor.IInternalActorRef})">
            <summary>
            This method is called after the child has been removed from the set of children.
            It does not need to do anything special. Exceptions thrown from this method
            do NOT make the actor fail if this happens during termination.
            </summary>
        </member>
        <member name="T:Akka.Actor.OneForOneStrategy">
            <summary>
                Class OneForOneStrategy. This class cannot be inherited.
            </summary>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.#ctor(System.Nullable{System.Int32},System.Nullable{System.TimeSpan},System.Func{System.Exception,Akka.Actor.Directive})">
            <summary>
                Applies the fault handling `Directive` (Resume, Restart, Stop) specified in the `Decider`
                to all children when one fails, as opposed to <see cref="T:Akka.Actor.OneForOneStrategy"/> that applies
                it only to the child actor that failed.
            </summary>
            <param name="maxNrOfRetries">
                the number of times a child actor is allowed to be restarted, negative value means no limit,
                if the limit is exceeded the child actor is stopped.
            </param>
            <param name="withinTimeRange">duration of the time window for maxNrOfRetries, Duration.Inf means no window.</param>
            <param name="localOnlyDecider">mapping from Exception to <see cref="T:Akka.Actor.Directive"/></param>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.#ctor(System.Nullable{System.Int32},System.Nullable{System.TimeSpan},Akka.Actor.IDecider)">
            <summary>
                Applies the fault handling `Directive` (Resume, Restart, Stop) specified in the `Decider`
                to all children when one fails, as opposed to <see cref="T:Akka.Actor.OneForOneStrategy"/> that applies
                it only to the child actor that failed.
            </summary>
            <param name="maxNrOfRetries">
                the number of times a child actor is allowed to be restarted, negative value means no limit,
                if the limit is exceeded the child actor is stopped.
            </param>
            <param name="withinTimeRange">duration of the time window for maxNrOfRetries, Duration.Inf means no window.</param>
            <param name="decider">mapping from Exception to <see cref="T:Akka.Actor.Directive"/></param>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.#ctor(System.Int32,System.Int32,System.Func{System.Exception,Akka.Actor.Directive},System.Boolean)">
            <summary>
                Applies the fault handling `Directive` (Resume, Restart, Stop) specified in the `Decider`
                to all children when one fails, as opposed to <see cref="T:Akka.Actor.OneForOneStrategy"/> that applies
                it only to the child actor that failed.
            </summary>
            <param name="maxNrOfRetries">
                the number of times a child actor is allowed to be restarted, negative value means no limit,
                if the limit is exceeded the child actor is stopped.
            </param>
            <param name="withinTimeMilliseconds">duration in milliseconds of the time window for <paramref name="maxNrOfRetries"/>, negative values means no window.</param>
            <param name="localOnlyDecider">Mapping from an <see cref="T:System.Exception"/> to <see cref="T:Akka.Actor.Directive"/></param>
            <param name="loggingEnabled">If <c>true</c> failures will be logged</param>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.#ctor(System.Int32,System.Int32,Akka.Actor.IDecider,System.Boolean)">
            <summary>
                Applies the fault handling `Directive` (Resume, Restart, Stop) specified in the `Decider`
                to all children when one fails, as opposed to <see cref="T:Akka.Actor.OneForOneStrategy"/> that applies
                it only to the child actor that failed.
            </summary>
            <param name="maxNrOfRetries">
                the number of times a child actor is allowed to be restarted, negative value means no limit,
                if the limit is exceeded the child actor is stopped.
            </param>
            <param name="withinTimeMilliseconds">duration in milliseconds of the time window for <paramref name="maxNrOfRetries"/>, negative values means no window.</param>
            <param name="decider">Mapping from an <see cref="T:System.Exception"/> to <see cref="T:Akka.Actor.Directive"/></param>
            <param name="loggingEnabled">If <c>true</c> failures will be logged</param>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.#ctor(System.Func{System.Exception,Akka.Actor.Directive})">
            <summary>
            Constructor that accepts only a decider and uses reasonable defaults for the other settings
            </summary>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.#ctor(Akka.Actor.IDecider)">
            <summary>
            Constructor that accepts only a decider and uses reasonable defaults for the other settings
            </summary>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.#ctor">
            <summary>
            Serialization-friendly constructor
            </summary>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.Handle(Akka.Actor.IActorRef,System.Exception)">
            <summary>
                Handles the specified child.
            </summary>
            <param name="child">The child.</param>
            <param name="x">The x.</param>
            <returns>Directive.</returns>
        </member>
        <member name="T:Akka.Actor.AllForOneStrategy">
            <summary>
                Class AllForOneStrategy. This class cannot be inherited.
            </summary>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.#ctor(System.Nullable{System.Int32},System.Nullable{System.TimeSpan},System.Func{System.Exception,Akka.Actor.Directive})">
            <summary>
                Applies the fault handling `Directive` (Resume, Restart, Stop) specified in the `Decider`
                to all children when one fails, as opposed to <see cref="T:Akka.Actor.AllForOneStrategy"/> that applies
                it only to the child actor that failed.
            </summary>
            <param name="maxNrOfRetries">
                the number of times a child actor is allowed to be restarted, negative value and null means no limit,
                if the limit is exceeded the child actor is stopped.
            </param>
            <param name="withinTimeRange">duration of the time window for maxNrOfRetries, <see cref="F:System.Threading.Timeout.InfiniteTimeSpan"/> means no window.</param>
            <param name="localOnlyDecider">mapping from Exception to <see cref="T:Akka.Actor.Directive"/></param>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.#ctor(System.Nullable{System.Int32},System.Nullable{System.TimeSpan},Akka.Actor.IDecider)">
            <summary>
                Applies the fault handling `Directive` (Resume, Restart, Stop) specified in the `Decider`
                to all children when one fails, as opposed to <see cref="T:Akka.Actor.AllForOneStrategy"/> that applies
                it only to the child actor that failed.
            </summary>
            <param name="maxNrOfRetries">
                the number of times a child actor is allowed to be restarted, negative value and null means no limit,
                if the limit is exceeded the child actor is stopped.
            </param>
            <param name="withinTimeRange">duration of the time window for maxNrOfRetries, <see cref="F:System.Threading.Timeout.InfiniteTimeSpan"/> means no window.</param>
            <param name="decider">mapping from Exception to <see cref="T:Akka.Actor.Directive"/></param>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.#ctor(System.Int32,System.Int32,System.Func{System.Exception,Akka.Actor.Directive},System.Boolean)">
            <summary>
                Applies the fault handling `Directive` (Resume, Restart, Stop) specified in the `Decider`
                to all children when one fails, as opposed to <see cref="T:Akka.Actor.AllForOneStrategy"/> that applies
                it only to the child actor that failed.
            </summary>
            <param name="maxNrOfRetries">
                the number of times a child actor is allowed to be restarted, negative value means no limit,
                if the limit is exceeded the child actor is stopped.
            </param>
            <param name="withinTimeMilliseconds">duration in milliseconds of the time window for <paramref name="maxNrOfRetries"/>, negative values means no window.</param>
            <param name="localOnlyDecider">Mapping from an <see cref="T:System.Exception"/> to <see cref="T:Akka.Actor.Directive"/></param>
            <param name="loggingEnabled">If <c>true</c> failures will be logged</param>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.#ctor(System.Int32,System.Int32,Akka.Actor.IDecider,System.Boolean)">
            <summary>
                Applies the fault handling `Directive` (Resume, Restart, Stop) specified in the `Decider`
                to all children when one fails, as opposed to <see cref="T:Akka.Actor.AllForOneStrategy"/> that applies
                it only to the child actor that failed.
            </summary>
            <param name="maxNrOfRetries">
                the number of times a child actor is allowed to be restarted, negative value means no limit,
                if the limit is exceeded the child actor is stopped.
            </param>
            <param name="withinTimeMilliseconds">duration in milliseconds of the time window for <paramref name="maxNrOfRetries"/>, negative values means no window.</param>
            <param name="decider">Mapping from an <see cref="T:System.Exception"/> to <see cref="T:Akka.Actor.Directive"/></param>
            <param name="loggingEnabled">If <c>true</c> failures will be logged</param>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.#ctor(System.Func{System.Exception,Akka.Actor.Directive})">
            <summary>
            Constructor that accepts only a decider and uses reasonable defaults for the other settings
            </summary>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.#ctor(Akka.Actor.IDecider)">
            <summary>
            Constructor that accepts only a decider and uses reasonable defaults for the other settings
            </summary>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.#ctor">
            <summary>
            Serialization-friendly constructor
            </summary>]
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.Handle(Akka.Actor.IActorRef,System.Exception)">
            <summary>
                Determines what to do with the child when the given exception occurs.
            </summary>
            <param name="child">The child.</param>
            <param name="x">The x.</param>
            <returns>Directive.</returns>
        </member>
        <member name="T:Akka.Actor.Failures">
            <summary>
                Collection of failures, used to keep track of how many times a given actor have failed.
            </summary>
        </member>
        <member name="M:Akka.Actor.Failures.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.Failures"/> class.
            </summary>
        </member>
        <member name="P:Akka.Actor.Failures.Entries">
            <summary>
                Gets the entries.
            </summary>
            <value>The entries.</value>
        </member>
        <member name="T:Akka.Actor.Failure">
            <summary>
                Represents a single failure.
            </summary>
        </member>
        <member name="P:Akka.Actor.Failure.Exception">
            <summary>
                The exception that caused the failure.
            </summary>
            <value>The exception.</value>
        </member>
        <member name="P:Akka.Actor.Failure.Timestamp">
            <summary>
                The timestamp when the failure occurred.
            </summary>
            <value>The timestamp.</value>
        </member>
        <member name="T:Akka.Actor.Directive">
            <summary>
                Enum Directive for supervisor actions
            </summary>
        </member>
        <member name="F:Akka.Actor.Directive.Resume">
            <summary>
                Resumes message processing for the failed Actor
            </summary>
        </member>
        <member name="F:Akka.Actor.Directive.Restart">
            <summary>
                Discards the old Actor instance and replaces it with a new,
                then resumes message processing.
            </summary>
        </member>
        <member name="F:Akka.Actor.Directive.Escalate">
            <summary>
                Escalates the failure to the supervisor of the supervisor,
                by rethrowing the cause of the failure, i.e. the supervisor fails with
                the same exception as the child.
            </summary>
        </member>
        <member name="F:Akka.Actor.Directive.Stop">
            <summary>
                Stops the Actor
            </summary>
        </member>
        <member name="T:Akka.Actor.Envelope">
            <summary>
                Envelope class, represents a message and the sender of the message.    
            </summary>
        </member>
        <member name="P:Akka.Actor.Envelope.Sender">
            <summary>
                Gets or sets the sender.
            </summary>
            <value>The sender.</value>
        </member>
        <member name="P:Akka.Actor.Envelope.Message">
            <summary>
                Gets or sets the message.
            </summary>
            <value>The message.</value>
        </member>
        <member name="T:Akka.Actor.UntypedReceive">
            <summary>
                Delegate UntypedReceive
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="T:Akka.Dispatch.Mailboxes">
            <summary>
                Class Mailboxes.
            </summary>
        </member>
        <member name="F:Akka.Dispatch.Mailboxes._system">
            <summary>
                The system
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailboxes.#ctor(Akka.Actor.ActorSystem)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.Mailboxes"/> class.
            </summary>
            <param name="system">The system.</param>
        </member>
        <member name="M:Akka.Dispatch.Mailboxes.FromConfig(System.String)">
            <summary>
            Creates a mailbox from a configuration path.
            </summary>
            <param name="path">The path.</param>
            <returns>Mailbox.</returns>
        </member>
        <member name="T:Akka.Dispatch.PinnedDispatcherConfigurator">
            <summary>
            Used to create instances of the <see cref="T:Akka.Dispatch.SingleThreadDispatcher"/>. 
            
            Each actor created using the pinned dispatcher gets its own unique thread.
            <remarks>
            Always returns a new instance.
            </remarks>
            </summary>
        </member>
        <member name="T:Akka.Dispatch.SingleThreadDispatcher">
            <summary>
            Used to power the <see cref="T:Akka.Dispatch.PinnedDispatcherConfigurator"/>.
            
            Guaranteed to provide one new thread instance per actor.
            
            Uses <see cref="T:Helios.Concurrency.DedicatedThreadPool"/> with 1 thread in order 
            to take advantage of standard cleanup / teardown / queueing mechanics.
            
            /// Relevant configuration options:
            <code>
                my-forkjoin-dispatcher{
                        type = PinnedDispatcher
                        throughput = 100
                        dedicated-thread-pool{ #settings for Helios.DedicatedThreadPool
            	            #deadlock-timeout = 3s #optional timeout for deadlock detection
            	            threadtype = background #values can be "background" or "foreground"
                        }
                }
            
                my-other-forkjoin-dispatcher{
                        type = PinnedDispatcher
                        # dedicated-thread-pool section is optional
                }
            </code>
            <remarks>
            Worth noting that unlike the <see cref="T:Akka.Dispatch.ForkJoinDispatcher"/>, the <see cref="T:Akka.Dispatch.SingleThreadDispatcher"/>
            does not respect the <c>dedicated-thread-pool.thread-count</c> property in configuration. That value is
            always equal to 1 in the <see cref="T:Akka.Dispatch.SingleThreadDispatcher"/>.
            </remarks>
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SingleThreadDispatcher.Schedule(System.Action)">
            <summary>
                Schedules the specified run.
            </summary>
            <param name="run">The run.</param>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.ISystemMessage">
            <summary>
                Class ISystemMessage.
            </summary>
            **
        </member>
        <member name="T:Akka.Dispatch.SysMsg.NoMessage">
            <summary>
                Class NoMessage.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.DeathWatchNotification">
            <summary>
                Class DeathWatchNotification.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.DeathWatchNotification.#ctor(Akka.Actor.IActorRef,System.Boolean,System.Boolean)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.DeathWatchNotification"/> class.
            </summary>
            <param name="actor">The actor.</param>
            <param name="existenceConfirmed">if set to <c>true</c> [existence confirmed].</param>
            <param name="addressTerminated">if set to <c>true</c> [address terminated].</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.DeathWatchNotification.Actor">
            <summary>
                Gets the actor.
            </summary>
            <value>The actor.</value>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.DeathWatchNotification.ExistenceConfirmed">
            <summary>
                Gets a value indicating whether [existence confirmed].
            </summary>
            <value><c>true</c> if [existence confirmed]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.DeathWatchNotification.AddressTerminated">
            <summary>
                Gets a value indicating whether [address terminated].
            </summary>
            <value><c>true</c> if [address terminated]; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Failed">
            <summary>
                Class Failed.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Failed.#ctor(Akka.Actor.IActorRef,System.Exception,System.Int64)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.Failed"/> class.
            </summary>
            <param name="child">The child.</param>
            <param name="cause">The cause.</param>
            <param name="uid">The uid</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Failed.Child">
            <summary>
                Gets the child.
            </summary>
            <value>The child.</value>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Failed.Cause">
            <summary>
                Gets the cause.
            </summary>
            <value>The cause.</value>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Supervise">
            <summary>
                Class Supervise.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Supervise.#ctor(Akka.Actor.IActorRef,System.Boolean)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.Supervise"/> class.
            </summary>
            <param name="child">The child.</param>
            <param name="async">if set to <c>true</c> [asynchronous].</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Supervise.Async">
            <summary>
                Gets a value indicating whether this <see cref="T:Akka.Dispatch.SysMsg.Supervise"/> is asynchronous.
            </summary>
            <value><c>true</c> if asynchronous; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Supervise.Child">
            <summary>
                Gets the child.
            </summary>
            <value>The child.</value>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Watch">
            <summary>
                Class Watch.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Watch.#ctor(Akka.Actor.IActorRef,Akka.Actor.IActorRef)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.Watch"/> class.
            </summary>
            <param name="watchee">The watchee.</param>
            <param name="watcher">The watcher.</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Watch.Watchee">
            <summary>
                Gets the watchee.
            </summary>
            <value>The watchee.</value>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Watch.Watcher">
            <summary>
                Gets the watcher.
            </summary>
            <value>The watcher.</value>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Unwatch">
            <summary>
                Class Unwatch.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Unwatch.#ctor(Akka.Actor.IActorRef,Akka.Actor.IActorRef)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.Unwatch"/> class.
            </summary>
            <param name="watchee">The watchee.</param>
            <param name="watcher">The watcher.</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Unwatch.Watchee">
            <summary>
                Gets the watchee.
            </summary>
            <value>The watchee.</value>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Unwatch.Watcher">
            <summary>
                Gets the watcher.
            </summary>
            <value>The watcher.</value>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.ActorTask">
            <summary>
                Class ActorTask.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.ActorTask.#ctor(System.Threading.Tasks.Task)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.ActorTask"/> class.
            </summary>
            <param name="task">The task.</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.ActorTask.Task">
            <summary>
                Gets the task.
            </summary>
            <value>The task.</value>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.CompleteTask.#ctor(Akka.Dispatch.AmbientState,System.Action)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.CompleteTask"/> class.
            </summary>
            <param name="state"></param>
            <param name="action">The action.</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.CompleteTask.SetResult">
            <summary>
                Gets the set result.
            </summary>
            <value>The set result.</value>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Restart">
            <summary>
                Class Restart.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Recreate">
            <summary>
                Class Recreate.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Recreate.#ctor(System.Exception)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.Recreate"/> class.
            </summary>
            <param name="cause">The cause.</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Recreate.Cause">
            <summary>
                Gets the cause.
            </summary>
            <value>The cause.</value>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Resume">
            <summary>
                Class Resume.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Resume.#ctor(System.Exception)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.Resume"/> class.
            </summary>
            <param name="causedByFailure">The caused by failure.</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Resume.CausedByFailure">
            <summary>
                Gets or sets the caused by failure.
            </summary>
            <value>The caused by failure.</value>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Suspend">
            <summary>
                Class Suspend.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.SuspendReentrancy">
            <summary>
                Class SuspendReentrancy.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.ResumeReentrancy">
            <summary>
                Class ResumeReentrancy.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Stop">
            <summary>
                Class Stop.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.StopChild">
            <summary>
                INTERNAL
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.StopChild.#ctor(Akka.Actor.IActorRef)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.StopChild"/> class.
            </summary>
            <param name="child">The child.</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.StopChild.Child">
            <summary>
                Gets the child.
            </summary>
            <value>The child.</value>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Escalate">
            <summary>
                Class Escalate.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Escalate.#ctor(System.Exception)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.Escalate"/> class.
            </summary>
            <param name="reason">The reason.</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Escalate.Reason">
            <summary>
                Gets the reason.
            </summary>
            <value>The reason.</value>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Terminate">
            <summary>
                Class Terminate.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.TerminationHookDone">
            <summary>
                Class Terminate.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.TaskDispatcher">
            <summary>
            Task based dispatcher
            </summary>
        </member>
        <member name="M:Akka.Dispatch.TaskDispatcher.#ctor(Akka.Dispatch.MessageDispatcherConfigurator)">
            <summary>
            Takes a <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/>
            </summary>
        </member>
        <member name="T:Akka.Dispatch.DedicatedThreadPoolConfigHelpers">
            <summary>
            <see cref="T:Akka.Configuration.Config"/> helper class for configuring <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/>
            instances who depend on the Helios <see cref="T:Helios.Concurrency.DedicatedThreadPool"/>.
            </summary>
        </member>
        <member name="F:Akka.Dispatch.DedicatedThreadPoolConfigHelpers.DefaultSingleThreadPoolSettings">
            <summary>
            Default settings for <see cref="T:Akka.Dispatch.SingleThreadDispatcher"/> instances.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.ThreadPoolConfig">
            <summary>
            Used inside Akka.Remote for constructing the low-level Helios threadpool, but inside
            vanilla Akka it's also used for constructing custom fixed-size-threadpool dispatchers.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.UnboundedDequeBasedMailbox">
            <summary>
            Mailbox with support for EnqueueFirst. Used primarily for <see cref="T:Akka.Actor.IStash"/> support.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.UnboundedDequeBasedMailbox.CreateSystemMessagesQueue">
            <summary>
            Intended for system messages, creates an <see cref="T:Akka.Dispatch.MessageQueues.UnboundedMessageQueue"/> to be used 
            inside the <see cref="T:Akka.Dispatch.Mailbox"/>.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.UnboundedDequeBasedMailbox.CreateUserMessagesQueue">
            <summary>
            Used for user-defined messages within a <see cref="T:Akka.Dispatch.Mailbox"/>; creates a new <see cref="T:Akka.Dispatch.MessageQueues.UnboundedDequeMessageQueue"/>
            which means that any actor with a <see cref="T:Akka.Actor.IStash"/> can unstash messages to the front of the queue.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Akka.Dispatch.UnboundedMailbox">
            <summary>
            Alias for concurrent queue mailbox
            </summary>
        </member>
        <member name="T:Akka.Event.ActorEventBus`2">
            <summary>
            Class ActorEventBus.
            </summary>
            <typeparam name="TEvent">The type of the t event.</typeparam>
            <typeparam name="TClassifier">The type of the t classifier.</typeparam>
        </member>
        <member name="T:Akka.Event.EventBus`3">
            <summary>
            Class EventBus.
            </summary>
            <typeparam name="TEvent">The type of the t event.</typeparam>
            <typeparam name="TClassifier">The type of the t classifier.</typeparam>
            <typeparam name="TSubscriber">The type of the t subscriber.</typeparam>
        </member>
        <member name="F:Akka.Event.EventBus`3.classifiers">
            <summary>
            The classifiers
            </summary>
        </member>
        <member name="F:Akka.Event.EventBus`3.cache">
            <summary>
            The cache
            </summary>
        </member>
        <member name="M:Akka.Event.EventBus`3.SimpleName(System.Object)">
            <summary>
            Simples the name.
            </summary>
            <param name="source">The source.</param>
            <returns>System.String.</returns>
        </member>
        <member name="M:Akka.Event.EventBus`3.SimpleName(System.Type)">
            <summary>
            Simples the name.
            </summary>
            <param name="source">The source.</param>
            <returns>System.String.</returns>
        </member>
        <member name="M:Akka.Event.EventBus`3.Subscribe(`2,`1)">
            <summary>
            Subscribes the specified subscriber.
            </summary>
            <param name="subscriber">The subscriber.</param>
            <param name="classifier">The classifier.</param>
            <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Event.EventBus`3.Unsubscribe(`2)">
            <summary>
            Unsubscribes the specified subscriber.
            </summary>
            <param name="subscriber">The subscriber.</param>
            <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Event.EventBus`3.Unsubscribe(`2,`1)">
            <summary>
            Unsubscribes the specified subscriber.
            </summary>
            <param name="subscriber">The subscriber.</param>
            <param name="classifier">The classifier.</param>
            <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Event.EventBus`3.ClearCache">
            <summary>
            Clears the cache.
            </summary>
        </member>
        <member name="M:Akka.Event.EventBus`3.IsSubClassification(`1,`1)">
            <summary>
            Determines whether [is sub classification] [the specified parent].
            </summary>
            <param name="parent">The parent.</param>
            <param name="child">The child.</param>
            <returns><c>true</c> if [is sub classification] [the specified parent]; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Event.EventBus`3.Publish(`0,`2)">
            <summary>
            Publishes the specified event.
            </summary>
            <param name="event">The event.</param>
            <param name="subscriber">The subscriber.</param>
        </member>
        <member name="M:Akka.Event.EventBus`3.Classify(`0,`1)">
            <summary>
            Classifies the specified event.
            </summary>
            <param name="event">The event.</param>
            <param name="classifier">The classifier.</param>
            <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Event.EventBus`3.GetClassifier(`0)">
            <summary>
            Gets the classifier.
            </summary>
            <param name="event">The event.</param>
            <returns>`1.</returns>
        </member>
        <member name="M:Akka.Event.EventBus`3.Publish(`0)">
            <summary>
            Publishes the specified event.
            </summary>
            <param name="event">The event.</param>
        </member>
        <member name="M:Akka.Event.EventBus`3.PublishToSubscribers(`0,System.Collections.Generic.List{`2})">
            <summary>
            Publishes to subscribers.
            </summary>
            <param name="event">The event.</param>
            <param name="cachedSubscribers">The cached subscribers.</param>
        </member>
        <member name="M:Akka.Event.EventBus`3.UpdateCacheForEventClassifier(`0,`1)">
            <summary>
            Updates the cache for event classifier.
            </summary>
            <param name="event">The event.</param>
            <param name="eventClass">The event class.</param>
            <returns>List{`2}.</returns>
        </member>
        <member name="T:Akka.Event.AddressTerminatedTopic">
            <summary>
            INTERNAL API.
            
            Watchers of remote actor references register themselves as subscribers of
            <see cref="T:Akka.Actor.AddressTerminated"/> notifications. Remote and cluster death watchers
            publish <see cref="T:Akka.Actor.AddressTerminated"/> when a remote system is deemed dead.
            </summary>
        </member>
        <member name="T:Akka.Event.BusLogging">
            <summary>
                Class BusLogging.
            </summary>
        </member>
        <member name="T:Akka.Event.ILoggingAdapter">
            <summary>
            Capable of logging 
            </summary>
        </member>
        <member name="M:Akka.Event.ILoggingAdapter.IsEnabled(Akka.Event.LogLevel)">
            <summary>Returns <c>true</c> if the specified level is enabled.</summary>
        </member>
        <member name="M:Akka.Event.ILoggingAdapter.Debug(System.String,System.Object[])">
            <summary>Logs a message with the Debug level.</summary>
            <param name="format">The format.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Akka.Event.ILoggingAdapter.Info(System.String,System.Object[])">
            <summary>Logs a message with the Info level.</summary>
            <param name="format">The format.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Akka.Event.ILoggingAdapter.Warning(System.String,System.Object[])">
            <summary>Logs a message with the Warning level.</summary>
            <param name="format">The format.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Akka.Event.ILoggingAdapter.Error(System.String,System.Object[])">
            <summary>Logs a message with the Error level.</summary>
            <param name="format">The format.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Akka.Event.ILoggingAdapter.Error(System.Exception,System.String,System.Object[])">
            <summary>Logs a message with the Error level.</summary>
            <param name="cause">The cause.</param>
            <param name="format">The format.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Akka.Event.ILoggingAdapter.Log(Akka.Event.LogLevel,System.String,System.Object[])">
            <summary>Logs a message with the specified level.</summary>
            <param name="logLevel">The log level.</param>
            <param name="format">The format.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="P:Akka.Event.ILoggingAdapter.IsDebugEnabled">
            <summary>Returns <c>true</c> if Debug level is enabled.</summary>
        </member>
        <member name="P:Akka.Event.ILoggingAdapter.IsInfoEnabled">
            <summary>Returns <c>true</c> if Info level is enabled.</summary>
        </member>
        <member name="P:Akka.Event.ILoggingAdapter.IsWarningEnabled">
            <summary>Returns <c>true</c> if Warning level is enabled.</summary>
        </member>
        <member name="P:Akka.Event.ILoggingAdapter.IsErrorEnabled">
            <summary>Returns <c>true</c> if Error level is enabled.</summary>
        </member>
        <member name="F:Akka.Event.BusLogging.bus">
            <summary>
                The bus
            </summary>
        </member>
        <member name="F:Akka.Event.BusLogging.logClass">
            <summary>
                The log class
            </summary>
        </member>
        <member name="F:Akka.Event.BusLogging.logSource">
            <summary>
                The log source
            </summary>
        </member>
        <member name="M:Akka.Event.BusLogging.#ctor(Akka.Event.LoggingBus,System.String,System.Type,Akka.Event.ILogMessageFormatter)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Event.BusLogging"/> class.
            </summary>
            <param name="bus">The bus.</param>
            <param name="logSource">The log source.</param>
            <param name="logClass">The log class.</param>
            <param name="logMessageFormatter">The log message formatter.</param>
        </member>
        <member name="M:Akka.Event.BusLogging.NotifyError(System.Object)">
            <summary>
                Notifies the error.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Akka.Event.BusLogging.NotifyError(System.Exception,System.Object)">
            <summary>
                Notifies the error.
            </summary>
            <param name="cause">The cause.</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:Akka.Event.BusLogging.NotifyWarning(System.Object)">
            <summary>
                Notifies the warning.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Akka.Event.BusLogging.NotifyInfo(System.Object)">
            <summary>
                Notifies the information.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Akka.Event.BusLogging.NotifyDebug(System.Object)">
            <summary>
                Notifies the debug.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="T:Akka.Event.DeadLetter">
            <summary>
            Class DeadLetter.
            </summary>
        </member>
        <member name="M:Akka.Event.DeadLetter.#ctor(System.Object,Akka.Actor.IActorRef,Akka.Actor.IActorRef)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.DeadLetter"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <param name="recipient">The recipient.</param>
        </member>
        <member name="P:Akka.Event.DeadLetter.Message">
            <summary>
            Gets the message.
            </summary>
            <value>The message.</value>
        </member>
        <member name="P:Akka.Event.DeadLetter.Recipient">
            <summary>
            Gets the recipient.
            </summary>
            <value>The recipient.</value>
        </member>
        <member name="P:Akka.Event.DeadLetter.Sender">
            <summary>
            Gets the sender.
            </summary>
            <value>The sender.</value>
        </member>
        <member name="T:Akka.Event.DeadLetterListener">
            <summary>
                Class DeadLetterListener.
            </summary>
        </member>
        <member name="F:Akka.Event.DeadLetterListener._eventStream">
            <summary>
                The event stream
            </summary>
        </member>
        <member name="F:Akka.Event.DeadLetterListener._maxCount">
            <summary>
                The maximum count
            </summary>
        </member>
        <member name="F:Akka.Event.DeadLetterListener._count">
            <summary>
                The count
            </summary>
        </member>
        <member name="M:Akka.Event.DeadLetterListener.Receive(System.Object)">
            <summary>
                Processor for user defined messages.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="T:Akka.Event.Debug">
            <summary>
                Class Debug.
            </summary>
        </member>
        <member name="T:Akka.Event.LogEvent">
            <summary>
                Class LogEvent.
            </summary>
        </member>
        <member name="M:Akka.Event.LogEvent.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Event.LogEvent"/> class.
            </summary>
        </member>
        <member name="M:Akka.Event.LogEvent.LogLevel">
            <summary>
                Logs the level.
            </summary>
            <returns>LogLevel.</returns>
        </member>
        <member name="M:Akka.Event.LogEvent.ToString">
            <summary>
                Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>A <see cref="T:System.String"/> that represents this instance.</returns>
        </member>
        <member name="P:Akka.Event.LogEvent.Timestamp">
            <summary>
                Gets the timestamp.
            </summary>
            <value>The timestamp.</value>
        </member>
        <member name="P:Akka.Event.LogEvent.Thread">
            <summary>
                Gets the thread.
            </summary>
            <value>The thread.</value>
        </member>
        <member name="P:Akka.Event.LogEvent.LogSource">
            <summary>
                Gets or sets the log source.
            </summary>
            <value>The log source.</value>
        </member>
        <member name="P:Akka.Event.LogEvent.LogClass">
            <summary>
                Gets or sets the log class.
            </summary>
            <value>The log class.</value>
        </member>
        <member name="P:Akka.Event.LogEvent.Message">
            <summary>
                Gets or sets the message.
            </summary>
            <value>The message.</value>
        </member>
        <member name="M:Akka.Event.Debug.#ctor(System.String,System.Type,System.Object)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Event.Debug"/> class.
            </summary>
            <param name="logSource">The log source.</param>
            <param name="logClass">The log class.</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:Akka.Event.Debug.LogLevel">
            <summary>
                Logs the level.
            </summary>
            <returns>LogLevel.</returns>
        </member>
        <member name="T:Akka.Event.DefaultLogger">
            <summary>
                Class DefaultLogger.
            </summary>
        </member>
        <member name="M:Akka.Event.DefaultLogger.Receive(System.Object)">
            <summary>
                Processor for user defined messages.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="T:Akka.Event.Error">
            <summary>
                Class Error.
            </summary>
        </member>
        <member name="M:Akka.Event.Error.#ctor(System.Exception,System.String,System.Type,System.Object)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Event.Error"/> class.
            </summary>
            <param name="cause">The cause.</param>
            <param name="logSource">The log source.</param>
            <param name="logClass">The log class.</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:Akka.Event.Error.LogLevel">
            <summary>
                Logs the level.
            </summary>
            <returns>LogLevel.</returns>
        </member>
        <member name="M:Akka.Event.Error.ToString">
            <summary>
            Modifies the <see cref="T:Akka.Event.LogEvent"/> printable error stream to also include
            the details of the <see cref="P:Akka.Event.Error.Cause"/> object itself.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Akka.Event.Error.Cause">
            <summary>
                Gets the cause.
            </summary>
            <value>The cause.</value>
        </member>
        <member name="T:Akka.Event.EventStream">
            <summary>
            Class EventStream.
            </summary>
        </member>
        <member name="T:Akka.Event.LoggingBus">
            <summary>
                Class LoggingBus.
            </summary>
        </member>
        <member name="M:Akka.Event.LoggingBus.IsSubClassification(System.Type,System.Type)">
            <summary>
                Determines whether [is sub classification] [the specified parent].
            </summary>
            <param name="parent">The parent.</param>
            <param name="child">The child.</param>
            <returns><c>true</c> if [is sub classification] [the specified parent]; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Event.LoggingBus.Publish(System.Object,Akka.Actor.IActorRef)">
            <summary>
                Publishes the specified event.
            </summary>
            <param name="event">The event.</param>
            <param name="subscriber">The subscriber.</param>
        </member>
        <member name="M:Akka.Event.LoggingBus.Classify(System.Object,System.Type)">
            <summary>
                Classifies the specified event.
            </summary>
            <param name="event">The event.</param>
            <param name="classifier">The classifier.</param>
            <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Event.LoggingBus.GetClassifier(System.Object)">
            <summary>
                Gets the classifier.
            </summary>
            <param name="event">The event.</param>
            <returns>Type.</returns>
        </member>
        <member name="M:Akka.Event.LoggingBus.StartDefaultLoggers(Akka.Actor.Internals.ActorSystemImpl)">
            <summary>
                Starts the default loggers.
            </summary>
            <param name="system">The system.</param>
            <exception cref="T:System.Exception">Can not use logger of type: + loggerType</exception>
        </member>
        <member name="M:Akka.Event.LoggingBus.StartStdoutLogger(Akka.Actor.Settings)">
            <summary>
                Starts the stdout logger.
            </summary>
            <param name="config">The configuration.</param>
        </member>
        <member name="M:Akka.Event.LoggingBus.SetUpStdoutLogger(Akka.Actor.Settings)">
            <summary>
                Sets up stdout logger.
            </summary>
            <param name="config">The configuration.</param>
        </member>
        <member name="M:Akka.Event.LoggingBus.SetLogLevel(Akka.Event.LogLevel)">
            <summary>
                Sets the log level.
            </summary>
            <param name="logLevel">The log level.</param>
        </member>
        <member name="P:Akka.Event.LoggingBus.LogLevel">
            <summary>
                Gets the log level.
            </summary>
            <value>The log level.</value>
        </member>
        <member name="F:Akka.Event.EventStream.debug">
            <summary>
            Determines if subscription logging is enabled
            </summary>
        </member>
        <member name="M:Akka.Event.EventStream.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.EventStream"/> class.
            </summary>
            <param name="debug">if set to <c>true</c> [debug].</param>
        </member>
        <member name="M:Akka.Event.EventStream.Subscribe(Akka.Actor.IActorRef,System.Type)">
            <summary>
            Subscribes the specified subscriber.
            </summary>
            <param name="subscriber">The subscriber.</param>
            <param name="channel">The channel.</param>
            <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
            <exception cref="T:System.ArgumentNullException">subscriber</exception>
        </member>
        <member name="M:Akka.Event.EventStream.Unsubscribe(Akka.Actor.IActorRef,System.Type)">
            <summary>
            Unsubscribes the specified subscriber.
            </summary>
            <param name="subscriber">The subscriber.</param>
            <param name="channel">The channel.</param>
            <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
            <exception cref="T:System.ArgumentNullException">subscriber</exception>
        </member>
        <member name="M:Akka.Event.EventStream.Unsubscribe(Akka.Actor.IActorRef)">
            <summary>
            Unsubscribes the specified subscriber.
            </summary>
            <param name="subscriber">The subscriber.</param>
            <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
            <exception cref="T:System.ArgumentNullException">subscriber</exception>
        </member>
        <member name="T:Akka.Event.Info">
            <summary>
                Class Info.
            </summary>
        </member>
        <member name="M:Akka.Event.Info.#ctor(System.String,System.Type,System.Object)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Event.Info"/> class.
            </summary>
            <param name="logSource">The log source.</param>
            <param name="logClass">The log class.</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:Akka.Event.Info.LogLevel">
            <summary>
                Logs the level.
            </summary>
            <returns>LogLevel.</returns>
        </member>
        <member name="T:Akka.Event.InitializeLogger">
            <summary>
                Class InitializeLogger.
            </summary> 
        </member>
        <member name="M:Akka.Event.InitializeLogger.#ctor(Akka.Event.LoggingBus)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Event.InitializeLogger"/> class.
            </summary>
            <param name="loggingBus">The logging bus.</param>
        </member>
        <member name="P:Akka.Event.InitializeLogger.LoggingBus">
            <summary>
                Gets the logging bus.
            </summary>
            <value>The logging bus.</value>
        </member>
        <member name="T:Akka.Event.LoggerInitialized">
            <summary>
                Class LoggerInitialized.
            </summary>
        </member>
        <member name="T:Akka.Event.DummyClassForStringSources">
            <summary>
            This is a “marker” class which is inserted as originator class into
            <see cref="T:Akka.Event.LogEvent"/> when the string representation was supplied directly.
            </summary>
        </member>
        <member name="T:Akka.Event.Logging">
            <summary>
                Class Logging.
            </summary>
        </member>
        <member name="F:Akka.Event.Logging.StandardOutLogger">
            <summary>
                The standard out logger
            </summary>
        </member>
        <member name="M:Akka.Event.Logging.ClassFor(Akka.Event.LogLevel)">
            <summary>
                Classes for.
            </summary>
            <param name="logLevel">The log level.</param>
            <returns>Type.</returns>
            <exception cref="T:System.ArgumentException">Unknown LogLevel;logLevel</exception>
        </member>
        <member name="M:Akka.Event.Logging.GetLogger(Akka.Actor.IActorContext,Akka.Event.ILogMessageFormatter)">
            <summary>
                Gets the logger.
            </summary>
            <param name="context">The cell.</param>
            <param name="logMessageFormatter">The log message formatter.</param>
            <returns>ILoggingAdapter.</returns>
        </member>
        <member name="M:Akka.Event.Logging.GetLogger(Akka.Actor.ActorSystem,System.Object,Akka.Event.ILogMessageFormatter)">
            <summary>
                Gets the logger.
            </summary>
            <param name="system">The system.</param>
            <param name="logSourceObj">The log source object.</param>
            <param name="logMessageFormatter">The log message formatter.</param>
            <returns>ILoggingAdapter.</returns>
        </member>
        <member name="M:Akka.Event.Logging.LogLevelFor(System.String)">
            <summary>
                Logs the level for.
            </summary>
            <param name="logLevel">The log level.</param>
            <returns>LogLevel.</returns>
            <exception cref="T:System.ArgumentException">Unknown LogLevel;logLevel</exception>
        </member>
        <member name="M:Akka.Event.Logging.LogLevelFor``1">
            <summary>
            Given the type of <see cref="T:Akka.Event.LogEvent"/> returns the corresponding <see cref="T:Akka.Event.LogLevel"/>
            </summary>
            <typeparam name="T"></typeparam>
            <returns>The <see cref="T:Akka.Event.LogLevel"/> that corresponds to the specified type.</returns>
            <exception cref="T:System.ArgumentException">Thrown for unknown types, i.e. when <typeparamref name="T"/> is not
            <see cref="T:Akka.Event.Debug"/>, <see cref="T:Akka.Event.Info"/>, <see cref="T:Akka.Event.Warning"/> or<see cref="T:Akka.Event.Error"/></exception>
        </member>
        <member name="T:Akka.Event.LogLevel">
            <summary>
                Enum LogLevel
            </summary>
        </member>
        <member name="F:Akka.Event.LogLevel.DebugLevel">
            <summary>
                The debug level
            </summary>
        </member>
        <member name="F:Akka.Event.LogLevel.InfoLevel">
            <summary>
                The information level
            </summary>
        </member>
        <member name="F:Akka.Event.LogLevel.WarningLevel">
            <summary>
                The warning level
            </summary>
        </member>
        <member name="F:Akka.Event.LogLevel.ErrorLevel">
            <summary>
                The error level
            </summary>
        </member>
        <member name="T:Akka.Event.StandardOutLogger">
            <summary>
                Class StandardOutLogger.
            </summary>
        </member>
        <member name="M:Akka.Event.StandardOutLogger.TellInternal(System.Object,Akka.Actor.IActorRef)">
            <summary>
                Tells the internal.
            </summary>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <exception cref="T:System.ArgumentNullException">message</exception>
        </member>
        <member name="P:Akka.Event.StandardOutLogger.Provider">
            <summary>
                Gets the provider.
            </summary>
            <value>The provider.</value>
            <exception cref="T:System.Exception">StandardOutLogged does not provide</exception>
        </member>
        <member name="T:Helios.Concurrency.ThreadType">
            <summary>
            The type of threads to use - either foreground or background threads.
            </summary>
        </member>
        <member name="T:Helios.Concurrency.DedicatedThreadPoolSettings">
            <summary>
            Provides settings for a dedicated thread pool
            </summary>
        </member>
        <member name="F:Helios.Concurrency.DedicatedThreadPoolSettings.DefaultThreadType">
            <summary>
            Background threads are the default thread type
            </summary>
        </member>
        <member name="P:Helios.Concurrency.DedicatedThreadPoolSettings.NumThreads">
            <summary>
            The total number of threads to run in this thread pool.
            </summary>
        </member>
        <member name="P:Helios.Concurrency.DedicatedThreadPoolSettings.ThreadType">
            <summary>
            The type of threads to run in this thread pool.
            </summary>
        </member>
        <member name="P:Helios.Concurrency.DedicatedThreadPoolSettings.DeadlockTimeout">
            <summary>
            Interval to check for thread deadlocks.
            
            If a thread takes longer than <see cref="P:Helios.Concurrency.DedicatedThreadPoolSettings.DeadlockTimeout"/> it will be aborted
            and replaced.
            </summary>
        </member>
        <member name="T:Helios.Concurrency.DedicatedThreadPoolTaskScheduler">
            <summary>
            TaskScheduler for working with a <see cref="T:Helios.Concurrency.DedicatedThreadPool"/> instance
            </summary>
        </member>
        <member name="F:Helios.Concurrency.DedicatedThreadPoolTaskScheduler._parallelWorkers">
            <summary>
            Number of tasks currently running
            </summary>
        </member>
        <member name="P:Helios.Concurrency.DedicatedThreadPoolTaskScheduler.MaximumConcurrencyLevel">
            <summary>
            Level of concurrency is directly equal to the number of threads
            in the <see cref="T:Helios.Concurrency.DedicatedThreadPool"/>.
            </summary>
        </member>
        <member name="T:Helios.Concurrency.DedicatedThreadPool">
            <summary>
            An instanced, dedicated thread pool.
            </summary>
        </member>
        <member name="F:Helios.Concurrency.DedicatedThreadPool._index">
            <summary>
            index for round-robin load-balancing across worker threads
            </summary>
        </member>
        <member name="T:Akka.Routing.ConsistentHashingRouter">
            <summary>
            Static class for assisting with <see cref="T:Akka.Routing.ConsistentHashMapping"/> instances
            </summary>
        </member>
        <member name="F:Akka.Routing.ConsistentHashingRouter.EmptyConsistentHashMapping">
            <summary>
            Default empty <see cref="T:Akka.Routing.ConsistentHashMapping"/> implementation
            </summary>
        </member>
        <member name="T:Akka.Routing.IConsistentHashable">
            <summary>
            Marks a given class as consistently hashable, for use with <see cref="T:Akka.Routing.ConsistentHashingGroup"/>
            or <see cref="T:Akka.Routing.ConsistentHashingPool"/> routers.
            </summary>
        </member>
        <member name="T:Akka.Routing.ConsistentHashableEnvelope">
            <summary>
            Envelope you can wrap around a message in order to make it hashable for use with <see cref="T:Akka.Routing.ConsistentHashingGroup"/>
            or <see cref="T:Akka.Routing.ConsistentHashingPool"/> routers.
            </summary>
        </member>
        <member name="T:Akka.Routing.ConsistentHashMapping">
            <summary>
            Delegate for computing the hashkey from any given
            type of message. Extracts the property / data that is going
            to be used for a given hash, but doesn't actually return
            the hash values themselves.
            
            If returning an byte[] or string it will be used as is,
            otherwise the configured <see cref="T:Akka.Serialization.Serializer"/> will be applied
            to the returned data."/&gt;
            </summary>
        </member>
        <member name="T:Akka.Routing.ConsistentHashingRoutingLogic">
            <summary>
            Uses consistent hashing to select a <see cref="T:Akka.Routing.Routee"/> based on the sent message.
            
            There are 3 ways to define what data to use for the consistent hash key.
            
            1. You can define a <see cref="T:Akka.Routing.ConsistentHashMapping"/> or use <see cref="!:WithHashMapper"/>
            of the router to map incoming messages to their consistent hash key.
            This makes the decision transparent for the sender.
            
            2. Messages may implement <see cref="T:Akka.Routing.IConsistentHashable"/>. The hash key is part
            of the message and it's convenient to define it together with the message
            definition.
            
            3. The message can be wrapped in a <see cref="T:Akka.Routing.ConsistentHashableEnvelope"/> to
            define what data to use for the consistent hash key. The sender knows what key
            to use.
            
            These ways to define the consistent hash key can be used together and at the
            same time for one router. The <see cref="T:Akka.Routing.ConsistentHashMapping"/> is tried first.
            </summary>
        </member>
        <member name="T:Akka.Routing.ConsistentRoutee">
            <summary>
            INTERNAL API
            
            Important to use ActorRef with full address, with host and port, in the hash ring,
            so that same ring is produced on different nodes.
            The ConsistentHash uses toString of the ring nodes, and the ActorRef itself
            isn't a good representation, because LocalActorRef doesn't include the
            host and port.
            </summary>
        </member>
        <member name="T:Akka.Routing.ConsistentHashingGroup">
            <summary>
            <see cref="T:Akka.Routing.Group"/> implementation of the consistent hashing router.
            </summary>
        </member>
        <member name="T:Akka.Routing.Group">
            <summary>
            Base class for defining Group routers.
            </summary>
        </member>
        <member name="T:Akka.Routing.RouterConfig">
            <summary>
            Configuration for router actors
            </summary>
        </member>
        <member name="M:Akka.Routing.Group.RouteeFor(System.String,Akka.Actor.IActorContext)">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Routing.Group.WithDispatcher(System.String)">
            <summary>
            Returns a new instance of the <see cref="T:Akka.Routing.Group"/> router with a new dispatcher id.
            
            NOTE: this method is immutable and returns a new instance of the <see cref="T:Akka.Routing.Group"/>.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingGroup.WithVirtualNodesFactor(System.Int32)">
            <summary>
            Apply a <see cref="P:Akka.Routing.ConsistentHashingGroup.VirtualNodesFactor"/> to the <see cref="T:Akka.Routing.ConsistentHashingGroup"/>
            
            Note: this method is immutable and will return a new instance.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingGroup.WithHashMapping(Akka.Routing.ConsistentHashMapping)">
            <summary>
            Apply a <see cref="T:Akka.Routing.ConsistentHashMapping"/> to the <see cref="T:Akka.Routing.ConsistentHashingGroup"/>.
            
            Note: this method is immutable and will return a new instance.
            </summary>
        </member>
        <member name="P:Akka.Routing.ConsistentHashingGroup.VirtualNodesFactor">
            <summary>
            Virtual nodes used in the <see cref="T:Akka.Routing.ConsistentHash`1"/>.
            </summary>
        </member>
        <member name="T:Akka.Routing.ConsistentHashingPool">
            <summary>
            <see cref="T:Akka.Routing.Pool"/> implementation of a consistent hash router.
            
            NOTE: Using <see cref="T:Akka.Routing.Resizer"/> with <see cref="T:Akka.Routing.ConsistentHashingPool"/> is potentially harmful, as hash ranges
            might change radically during live message processing. This router works best with fixed-sized pools or fixed
            number of routees per node in the event of clustered deployments.
            </summary>
        </member>
        <member name="T:Akka.Routing.Pool">
            <summary>
            Base class for defining Pool routers
            </summary>
        </member>
        <member name="M:Akka.Routing.Pool.GetNrOfInstances(Akka.Actor.ActorSystem)">
            <summary>
            Used by the <see cref="T:Akka.Routing.RoutedActorCell"/> to determine the initial number of routees.
            
            Needs to be connected to an <see cref="T:Akka.Actor.ActorSystem"/> for clustered deployment scenarios.
            </summary>
        </member>
        <member name="M:Akka.Routing.Pool.WithSupervisorStrategy(Akka.Actor.SupervisorStrategy)">
            <summary>
            Returns a new instance of the <see cref="T:Akka.Routing.Pool"/> router with a new <see cref="P:Akka.Routing.Pool.SupervisorStrategy"/>.
            
            NOTE: this method is immutable and returns a new instance of the <see cref="T:Akka.Routing.Pool"/>.
            </summary>
        </member>
        <member name="M:Akka.Routing.Pool.WithResizer(Akka.Routing.Resizer)">
            <summary>
            Returns a new instance of the <see cref="T:Akka.Routing.Pool"/> router with a new <see cref="P:Akka.Routing.Pool.Resizer"/>.
            
            NOTE: this method is immutable and returns a new instance of the <see cref="T:Akka.Routing.Pool"/>.
            </summary>
        </member>
        <member name="M:Akka.Routing.Pool.WithDispatcher(System.String)">
            <summary>
            Returns a new instance of the <see cref="T:Akka.Routing.Pool"/> router with a new dispatcher id.
            
            NOTE: this method is immutable and returns a new instance of the <see cref="T:Akka.Routing.Pool"/>.
            </summary>
        </member>
        <member name="P:Akka.Routing.Pool.NrOfInstances">
            <summary>
            The number of instances in the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.Pool.UsePoolDispatcher">
            <summary>
            Whether or not to use the pool dispatcher.
            </summary>
        </member>
        <member name="P:Akka.Routing.Pool.Resizer">
            <summary>
            An instance of the resizer for this pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.Pool.SupervisorStrategy">
            <summary>
            An instance of the supervisor strategy for this pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.Pool.DefaultStrategy">
            <summary>
                When supervisorStrategy is not specified for an actor this
                is used by default. OneForOneStrategy with a decider which escalates by default.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ConsistentHashingPool"/> class.
            </summary>
            <param name="config">The configuration.</param>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.#ctor(System.Int32,Akka.Routing.Resizer,Akka.Actor.SupervisorStrategy,System.String,System.Boolean,System.Int32,Akka.Routing.ConsistentHashMapping)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ConsistentHashingPool"/> class.
            </summary>
            <param name="nrOfInstances">The nr of instances.</param>
            <param name="resizer">The resizer.</param>
            <param name="supervisorStrategy">The supervisor strategy.</param>
            <param name="routerDispatcher">The router dispatcher.</param>
            <param name="usePoolDispatcher">if set to <c>true</c> [use pool dispatcher].</param>
            <param name="virtualNodesFactor">The number of virtual nodes to use on the hash ring</param>
            <param name="hashMapping">The consistent hash mapping function to use on incoming messages</param>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.WithVirtualNodesFactor(System.Int32)">
            <summary>
            Apply a <see cref="P:Akka.Routing.ConsistentHashingPool.VirtualNodesFactor"/> to the <see cref="T:Akka.Routing.ConsistentHashingPool"/>
            
            Note: this method is immutable and will return a new instance.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.WithHashMapping(Akka.Routing.ConsistentHashMapping)">
            <summary>
            Apply a <see cref="T:Akka.Routing.ConsistentHashMapping"/> to the <see cref="T:Akka.Routing.ConsistentHashingPool"/>.
            
            Note: this method is immutable and will return a new instance.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.#ctor(System.Int32)">
            <summary>
            Simple form of ConsistentHashingPool constructor
            </summary>
            <param name="nrOfInstances">The nr of instances.</param>
        </member>
        <member name="P:Akka.Routing.ConsistentHashingPool.VirtualNodesFactor">
            <summary>
            Virtual nodes used in the <see cref="T:Akka.Routing.ConsistentHash`1"/>.
            </summary>
        </member>
        <member name="T:Akka.Util.ContinuousEnumerator`1">
            <summary>
            Implements a circular <see cref="T:System.Collections.Generic.IEnumerator`1"/> around an existing <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            
            This allows for continuous read-only iteration over a set.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Akka.Util.ContinuousEnumerator`1._internalEnumerator">
            <summary>
            The raw iterator from some <see cref="T:System.Collections.Generic.IEnumerable`1"/> object
            </summary>
        </member>
        <member name="T:Akka.Util.ContinuousEnumeratorExtensions">
            <summary>
            Extension method class for adding <see cref="T:Akka.Util.ContinuousEnumerator`1"/> support to any <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            instance within Akka.NET
            </summary>
        </member>
        <member name="M:Akka.Util.ContinuousEnumeratorExtensions.GetContinuousEnumerator``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Provides a <see cref="T:Akka.Util.ContinuousEnumerator`1"/> instance for <see cref="!:collection"/>.
            
            Internally, it just wraps <see cref="!:collection"/>'s internal iterator with circular iteration behavior.
            </summary>
        </member>
        <member name="T:Akka.Util.Internal.ImmutabilityUtils">
            <summary>
            Utility class for adding some basic immutable behaviors
            to specific types of collections without having to reference
            the entire BCL.Immutability NuGet package.
            
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Util.Internal.InterlockedSpin">
            <summary>INTERNAL!
            Implements helpers for performing Compare-and-swap operations using <see cref="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)"/>
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.InterlockedSpin.Swap``1(``0@,System.Func{``0,``0})">
            <summary>INTERNAL!
            Atomically updates the object <paramref name="reference"/> by calling <paramref name="updater"/> to get the new value.
            Note that <paramref name="updater"/> may be called many times so it should be idempotent.
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
            <returns>The updated value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.InterlockedSpin.ConditionallySwap``2(``0@,System.Func{``0,System.Tuple{System.Boolean,``0,``1}})">
            <summary>INTERNAL!
            Atomically updates the int <paramref name="reference"/> by calling <paramref name="updateIfTrue"/> to get the new value.
            <paramref name="updateIfTrue"/> returns a Tuple&lt;should update, the new int value, the return value&gt;
            If the first item in the tuple is true, the value is updated, and the third value of the tuple is returned.
            Note that <paramref name="updateIfTrue"/> may be called many times so it should be idempotent.
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
            <returns>The third value from the tuple return by <paramref name="updateIfTrue"/>.</returns>
        </member>
        <member name="T:Akka.Util.Internal.Collections.ImmutableAvlTree`2">
            <summary>
            An immutable AVL tree.
            Originally from http://justinmchase.com/2011/12/13/immutable-avl-tree-in-c/
            </summary>
            <typeparam name="TKey">The type of the keys.</typeparam>
            <typeparam name="TValue">The type of the values.</typeparam>
        </member>
        <member name="T:Akka.Util.Internal.Collections.ImmutableAvlTreeBase`2">
            <summary>
            An immutable AVL tree.
            Originally from http://justinmchase.com/2011/12/13/immutable-avl-tree-in-c/
            </summary>
            <typeparam name="TKey">The type of the keys.</typeparam>
            <typeparam name="TValue">The type of the values.</typeparam>
        </member>
        <member name="T:Akka.Util.Internal.StringBuilderExtensions">
            <summary>
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Util.StandardOutWriter">
            <summary>
            This class contains methods for thread safe writing to the standard output stream.
             </summary>
        </member>
        <member name="M:Akka.Util.StandardOutWriter.Write(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Writes the specified <see cref="T:System.String"/> value to the standard output stream. Optionally 
            you may specify which colors should be used.
            </summary>
            <param name="message">The <see cref="T:System.String"/> value to write</param>
            <param name="foregroundColor">Optional: The foreground color</param>
            <param name="backgroundColor">Optional: The background color</param>
        </member>
        <member name="M:Akka.Util.StandardOutWriter.WriteLine(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Writes the specified <see cref="T:System.String"/> value, followed by the current line terminator,
            to the standard output stream. Optionally you may specify which colors should be used.
            </summary>
            <param name="message">The <see cref="T:System.String"/> value to write</param>
            <param name="foregroundColor">Optional: The foreground color</param>
            <param name="backgroundColor">Optional: The background color</param>
        </member>
        <member name="T:Akka.Event.Subscription`2">
            <summary>
            Class Subscription.
            </summary>
            <typeparam name="TSubscriber">The type of the t subscriber.</typeparam>
            <typeparam name="TClassifier">The type of the t classifier.</typeparam>
        </member>
        <member name="M:Akka.Event.Subscription`2.#ctor(`0,System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.Subscription`2"/> class.
            </summary>
            <param name="subscriber">The subscriber.</param>
            <param name="unsubscriptions">The unsubscriptions.</param>
        </member>
        <member name="M:Akka.Event.Subscription`2.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.Subscription`2"/> class.
            </summary>
            <param name="subscriber">The subscriber.</param>
        </member>
        <member name="P:Akka.Event.Subscription`2.Subscriber">
            <summary>
            Gets the subscriber.
            </summary>
            <value>The subscriber.</value>
        </member>
        <member name="P:Akka.Event.Subscription`2.Unsubscriptions">
            <summary>
            Gets the unsubscriptions.
            </summary>
            <value>The unsubscriptions.</value>
        </member>
        <member name="T:Akka.Event.TraceLogger">
            <summary>
            TraceLogger - writes to System.Trace; useful for systems that use trace listeners.
            
            To activate the TraceLogger, add loggers = [""Akka.Event.TraceLogger, Akka""] to your config
            </summary>
        </member>
        <member name="T:Akka.Event.UnhandledMessage">
            <summary>
                Class UnhandledMessage.
            </summary>
        </member>
        <member name="M:Akka.Event.UnhandledMessage.#ctor(System.Object,Akka.Actor.IActorRef,Akka.Actor.IActorRef)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Event.UnhandledMessage"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <param name="recipient">The recipient.</param>
        </member>
        <member name="P:Akka.Event.UnhandledMessage.Message">
            <summary>
                Gets the message.
            </summary>
            <value>The message.</value>
        </member>
        <member name="P:Akka.Event.UnhandledMessage.Sender">
            <summary>
                Gets the sender.
            </summary>
            <value>The sender.</value>
        </member>
        <member name="P:Akka.Event.UnhandledMessage.Recipient">
            <summary>
                Gets the recipient.
            </summary>
            <value>The recipient.</value>
        </member>
        <member name="T:Akka.Event.Warning">
            <summary>
                Class Warning.
            </summary>
        </member>
        <member name="M:Akka.Event.Warning.#ctor(System.String,System.Type,System.Object)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Event.Warning"/> class.
            </summary>
            <param name="logSource">The log source.</param>
            <param name="logClass">The log class.</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:Akka.Event.Warning.LogLevel">
            <summary>
                Logs the level.
            </summary>
            <returns>LogLevel.</returns>
        </member>
        <member name="M:Akka.Util.Internal.Extensions.Drop``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Scala alias for Skip
            </summary>
            <typeparam name="T"></typeparam>
            <param name="self"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Akka.Util.Internal.Extensions.Head``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Scala alias for FirstOrDefault
            </summary>
            <typeparam name="T"></typeparam>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:Akka.Util.Internal.Extensions.AddOrSet``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            Dictionary helper that allows for idempotent updates. You don't need to care whether or not
            this item is already in the collection in order to update it.
            </summary>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxRoutingLogic.SelectNext(Akka.Routing.Routee[])">
            <summary>
            Select a next best route to handle a message, based on priority of interests:
            1. Actors without any messages.
            2. Actors of known messages count, lower is better.
            4. Actors of unknown message count.
            For the case, when all routees are of unpredictable size, it falls back to round robin.
            </summary>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxPool.#ctor(System.Int32,Akka.Routing.Resizer,Akka.Actor.SupervisorStrategy,System.String,System.Boolean)">
            <summary>
            </summary>
            <param name="nrOfInstances">The nr of instances.</param>
            <param name="resizer">The resizer.</param>
            <param name="supervisorStrategy">The supervisor strategy.</param>
            <param name="routerDispatcher">The router dispatcher.</param>
            <param name="usePoolDispatcher">if set to <c>true</c> [use pool dispatcher].</param>
        </member>
        <member name="T:Akka.Routing.TailChoppingRoutingLogic">
            <summary>
            The routing logic for the TailChoppingRouter. This router will send a message to a randomly chosen
            routee, and after a delay, send to a different randomly chosen routee. The first response is forwarded,
            and all other responses are discarded.
            </summary>
        </member>
        <member name="F:Akka.Routing.TailChoppingRoutingLogic._within">
            <summary>
            The amount of time to wait for a response.
            </summary>
        </member>
        <member name="F:Akka.Routing.TailChoppingRoutingLogic._interval">
            <summary>
            The interval to delay between choosing a new random routee.
            </summary>
        </member>
        <member name="F:Akka.Routing.TailChoppingRoutingLogic._scheduler">
            <summary>
            An instance of the actor system scheduler.
            </summary>
        </member>
        <member name="M:Akka.Routing.TailChoppingRoutingLogic.#ctor(System.TimeSpan,System.TimeSpan,Akka.Actor.IScheduler)">
            <summary>
            Creates an instance of the TailChoppingRoutingLogic.
            </summary>
            <param name="within">The time within which at least one response is expected.</param>
            <param name="interval">The duration after which the next routee will be picked.</param>
            <param name="scheduler">The scheduler to use</param>
        </member>
        <member name="M:Akka.Routing.TailChoppingRoutingLogic.Select(System.Object,Akka.Routing.Routee[])">
            <summary>
            Selects all routees and creates a TailChoppingRoutee.
            </summary>
            <param name="message">The message to use.</param>
            <param name="routees">The routees to select from.</param>
            <returns>A TailChoppingRoutee to handle the tail chopping routing.</returns>
        </member>
        <member name="T:Akka.Routing.TailChoppingRoutee">
            <summary>
            A single point routee that routes to randomly chosen routees at a given interval. Accepts the first response.
            </summary>
        </member>
        <member name="F:Akka.Routing.TailChoppingRoutee._routees">
            <summary>
            The collection of possible routees to send messages to.
            </summary>
        </member>
        <member name="F:Akka.Routing.TailChoppingRoutee._within">
            <summary>
            The amount of time to wait for a response.
            </summary>
        </member>
        <member name="F:Akka.Routing.TailChoppingRoutee._interval">
            <summary>
            The interval to wait before sending to the next routee.
            </summary>
        </member>
        <member name="F:Akka.Routing.TailChoppingRoutee._scheduler">
            <summary>
            An instance of the actor system scheduler.
            </summary>
        </member>
        <member name="M:Akka.Routing.TailChoppingRoutee.#ctor(Akka.Routing.Routee[],System.TimeSpan,System.TimeSpan,Akka.Actor.IScheduler)">
            <summary>
            Creates an instance of the TailChoppingRoutee.
            </summary>
            <param name="routees">The routees to route to.</param>
            <param name="within">The time within which at least one response is expected.</param>
            <param name="interval">The duration after which the next routee will be picked.</param>
            <param name="scheduler">Access to a <see cref="!:Scheduler"/> instance, used to force deadlines.</param>
        </member>
        <member name="M:Akka.Routing.TailChoppingRoutee.Send(System.Object,Akka.Actor.IActorRef)">
            <summary>
            Sends a message to the tail chopping router's collection of routees.
            </summary>
            <param name="message">The message to send.</param>
            <param name="sender">The sender of the message.</param>
        </member>
        <member name="T:Akka.Routing.TailChoppingPool">
            <summary>
            A router pool that selects a random routee, then waits an interval before sending to a
            different routee. The first response is used and the remaining discarded.
            </summary>
        </member>
        <member name="F:Akka.Routing.TailChoppingPool._within">
            <summary>
            The amount of time to wait for a response.
            </summary>
        </member>
        <member name="F:Akka.Routing.TailChoppingPool._interval">
            <summary>
            The interval to wait before sending to the next routee.
            </summary>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.#ctor(System.Int32,Akka.Routing.Resizer,Akka.Actor.SupervisorStrategy,System.String,System.TimeSpan,System.TimeSpan,System.Boolean)">
            <summary>
            Creates an instance of the TailChoppingPool.
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
            <param name="resizer">The resizer to use with this instance.</param>
            <param name="supervisorStrategy">The supervision strategy to use with this pool.</param>
            <param name="routerDispatcher">The router dispatcher to use with this instance.</param>
            <param name="within">The amount of time to wait for a response.</param>
            <param name="interval">The interval to wait before sending to the next routee.</param>
            <param name="usePoolDispatcher">Whether or not to use the pool dispatcher.</param>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.#ctor(Akka.Configuration.Config)">
            <summary>
            Creates an instance of the TailChoppingPool.
            </summary>
            <param name="config">The configuration to use with this instance.</param>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.#ctor(System.Int32,System.TimeSpan,System.TimeSpan)">
            <summary>
            Creates an instance of the TailChoppingPool.
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
            <param name="within">The amount of time to wait for a response.</param>
            <param name="interval">The interval to wait before sending to the next routee.</param>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.WithSupervisorStrategy(Akka.Actor.SupervisorStrategy)">
            <summary>
            Sets the supervisor strategy to use for the pool.
            </summary>
            <param name="strategy">The strategy to use.</param>
            <returns>The tail chopping pool.</returns>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.WithResizer(Akka.Routing.Resizer)">
            <summary>
            Sets the resizer to use for the pool.
            </summary>
            <param name="resizer">The resizer to use.</param>
            <returns>The tail chopping pool.</returns>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.WithDispatcher(System.String)">
            <summary>
            Sets the router dispatcher to use for the pool.
            </summary>
            <param name="routerDispatcher">The router dispatcher to use.</param>
            <returns>The tail chopping pool.</returns>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a tail chopping router.
            </summary>
            <param name="system">The actor system to use to create this router.</param>
            <returns>The created router.</returns>
        </member>
        <member name="T:Akka.Routing.TailChoppingGroup">
            <summary>
            A router group that selects a random routee, then waits an interval before sending to a
            different routee. The first response is used and the remaining discarded.
            </summary>
        </member>
        <member name="F:Akka.Routing.TailChoppingGroup._within">
            <summary>
            The amount of time to wait for a response.
            </summary>
        </member>
        <member name="F:Akka.Routing.TailChoppingGroup._interval">
            <summary>
            The interval to wait before sending to the next routee.
            </summary>
        </member>
        <member name="M:Akka.Routing.TailChoppingGroup.#ctor(Akka.Configuration.Config)">
            <summary>
            Creates an instance of the TailChoppingGroup.
            </summary>
            <param name="config">The configuration to use with this instance.</param>
        </member>
        <member name="M:Akka.Routing.TailChoppingGroup.#ctor(System.String[],System.TimeSpan,System.TimeSpan)">
            <summary>
            Creates an instance of the TailChoppingGroup.
            </summary>
            <param name="routeePaths">The configured routee paths to use with this instance.</param>
            <param name="within">The amount of time to wait for a response.</param>
            <param name="interval">The interval to wait before sending to the next routee.</param>
        </member>
        <member name="M:Akka.Routing.TailChoppingGroup.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a tail chopping router.
            </summary>
            <param name="system">The actor system to use to create this router.</param>
            <returns>The created router.</returns>
        </member>
        <member name="T:Akka.Serialization.ByteArraySerializer">
            <summary>
            Class ByteArraySerializer.
            </summary>
        </member>
        <member name="T:Akka.Serialization.Serializer">
            <summary>
                Class Serializer.
            </summary>
        </member>
        <member name="F:Akka.Serialization.Serializer.system">
            <summary>
                The system
            </summary>
        </member>
        <member name="M:Akka.Serialization.Serializer.#ctor(Akka.Actor.ExtendedActorSystem)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Serialization.Serializer"/> class.
            </summary>
            <param name="system">The system.</param>
        </member>
        <member name="M:Akka.Serialization.Serializer.ToBinary(System.Object)">
            <summary>
                To the binary.
            </summary>
            <param name="obj">The object.</param>
            <returns>System.Byte[][].</returns>
        </member>
        <member name="M:Akka.Serialization.Serializer.FromBinary(System.Byte[],System.Type)">
            <summary>
                Froms the binary.
            </summary>
            <param name="bytes">The bytes.</param>
            <param name="type">The type.</param>
            <returns>System.Object.</returns>
        </member>
        <member name="P:Akka.Serialization.Serializer.Identifier">
            <summary>
                Gets the identifier.
            </summary>
            <value>The identifier.</value>
        </member>
        <member name="P:Akka.Serialization.Serializer.IncludeManifest">
            <summary>
                Gets a value indicating whether [include manifest].
            </summary>
            <value><c>true</c> if [include manifest]; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Akka.Serialization.ByteArraySerializer.#ctor(Akka.Actor.ExtendedActorSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Serialization.ByteArraySerializer"/> class.
            </summary>
            <param name="system"> The system. </param>
        </member>
        <member name="M:Akka.Serialization.ByteArraySerializer.ToBinary(System.Object)">
            <summary>
            To the binary.
            </summary>
            <param name="obj"> The object. </param>
            <returns> System.Byte[][]. </returns>
            <exception cref="T:System.NotSupportedException"> </exception>
            Serializes the given object into an Array of Byte
        </member>
        <member name="M:Akka.Serialization.ByteArraySerializer.FromBinary(System.Byte[],System.Type)">
            <summary>
            Froms the binary.
            </summary>
            <param name="bytes"> The bytes. </param>
            <param name="type"> The type. </param>
            <returns> System.Object. </returns>
            Produces an object from an array of bytes, with an optional type;
        </member>
        <member name="P:Akka.Serialization.ByteArraySerializer.Identifier">
            <summary>
            Gets the identifier.
            </summary>
            <value> The identifier. </value>
            Completely unique value to identify this implementation of Serializer, used to optimize network traffic
            Values from 0 to 16 is reserved for Akka internal usage
        </member>
        <member name="P:Akka.Serialization.ByteArraySerializer.IncludeManifest">
            <summary>
            Gets a value indicating whether [include manifest].
            </summary>
            <value> <c> true </c> if [include manifest]; otherwise, <c> false </c>. </value>
            Returns whether this serializer needs a manifest in the fromBinary method
        </member>
        <member name="T:Akka.Serialization.NewtonSoftJsonSerializer">
            <summary>
                Class NewtonSoftJsonSerializer.
            </summary>
        </member>
        <member name="M:Akka.Serialization.NewtonSoftJsonSerializer.#ctor(Akka.Actor.ExtendedActorSystem)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Serialization.NewtonSoftJsonSerializer"/> class.
            </summary>
            <param name="system">The system.</param>
        </member>
        <member name="M:Akka.Serialization.NewtonSoftJsonSerializer.ToBinary(System.Object)">
            <summary>
                To the binary.
            </summary>
            <param name="obj">The object.</param>
            <returns>System.Byte[][].</returns>
            Serializes the given object into an Array of Byte
        </member>
        <member name="M:Akka.Serialization.NewtonSoftJsonSerializer.FromBinary(System.Byte[],System.Type)">
            <summary>
                Froms the binary.
            </summary>
            <param name="bytes">The bytes.</param>
            <param name="type">The type.</param>
            <returns>System.Object.</returns>
            Produces an object from an array of bytes, with an optional type;
        </member>
        <member name="P:Akka.Serialization.NewtonSoftJsonSerializer.Identifier">
            <summary>
                Gets the identifier.
            </summary>
            <value>The identifier.</value>
            Completely unique value to identify this implementation of Serializer, used to optimize network traffic
            Values from 0 to 16 is reserved for Akka internal usage
        </member>
        <member name="P:Akka.Serialization.NewtonSoftJsonSerializer.IncludeManifest">
            <summary>
                Gets a value indicating whether [include manifest].
            </summary>
            <value><c>true</c> if [include manifest]; otherwise, <c>false</c>.</value>
            Returns whether this serializer needs a manifest in the fromBinary method
        </member>
        <member name="M:Akka.Serialization.NewtonSoftJsonSerializer.SurrogateConverter.CanConvert(System.Type)">
            <summary>
                Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns><c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Serialization.NewtonSoftJsonSerializer.SurrogateConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
                Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="M:Akka.Serialization.NewtonSoftJsonSerializer.SurrogateConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
                Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="T:Akka.Serialization.NullSerializer">
            <summary>
            Class NullSerializer.
            </summary>
        </member>
        <member name="M:Akka.Serialization.NullSerializer.#ctor(Akka.Actor.ExtendedActorSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Serialization.NullSerializer"/> class.
            </summary>
            <param name="system">The system.</param>
        </member>
        <member name="M:Akka.Serialization.NullSerializer.ToBinary(System.Object)">
            <summary>
            Serializes an object to binary.
            </summary>
            <param name="obj">The object.</param>
            <returns>System.Byte[][].</returns>
            Serializes the given object into an Array of Byte
        </member>
        <member name="M:Akka.Serialization.NullSerializer.FromBinary(System.Byte[],System.Type)">
            <summary>
            Deserializes a binary representation to an object.
            </summary>
            <param name="bytes">The bytes.</param>
            <param name="type">The type.</param>
            <returns>System.Object.</returns>
            Produces an object from an array of bytes, with an optional type;
        </member>
        <member name="P:Akka.Serialization.NullSerializer.Identifier">
            <summary>
            Gets the Serializer identifier.
            This is used for remote messaging envelopes.
            </summary>
            <value>The identifier.</value>
            Completely unique value to identify this implementation of Serializer, used to optimize network traffic
            Values from 0 to 16 is reserved for Akka internal usage
        </member>
        <member name="P:Akka.Serialization.NullSerializer.IncludeManifest">
            <summary>
            Gets a value indicating whether a manifest should be included in remote messages.
            </summary>
            <value><c>true</c> if [include manifest]; otherwise, <c>false</c>.</value>
            Returns whether this serializer needs a manifest in the fromBinary method
        </member>
        <member name="T:Akka.Util.Internal.ArrayExtensions">
            <summary>
            Provides extension utilities to arrays.
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.ArrayExtensions.IsNullOrEmpty(System.Array)">
            <summary>
            Determines if an array is null or empty.
            </summary>
            <param name="obj">The array to check.</param>
            <returns>True if null or empty, false otherwise.</returns>
        </member>
        <member name="M:Akka.Util.Internal.ArrayExtensions.Shuffle``1(``0[])">
            <summary>
            Shuffles an array of objects.
            </summary>
            <typeparam name="T">The type of the array to sort.</typeparam>
            <param name="array">The array to sort.</param>
        </member>
        <member name="M:Akka.Util.Internal.ArrayExtensions.ZipWithIndex``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Implementation of Scala's ZipWithIndex method.
            
            Folds a collection into a Dictionary where the original value (of type T) acts as the key
            and the index of the item in the array acts as the value.
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.ArrayExtensions.Slice``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary>
            Grabs a subset of an IEnumerable based on a starting index and position
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">The array of items to slice</param>
            <param name="startIndex">The starting position to begin the slice</param>
            <param name="count">The number of items to take</param>
            <returns>A slice of size <see cref="!:count"/> beginning from position <see cref="!:startIndex"/> in <see cref="!:items"/>.</returns>
        </member>
        <member name="M:Akka.Util.Internal.ArrayExtensions.From``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Select all the items in this array beginning with <see cref="!:startingItem"/> and up until the end of the array.
            
            If <see cref="!:startingItem"/> is not found in the array, From will return an empty set.
            If <see cref="!:startingItem"/> is found at the end of the array, From will return the entire original array.
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.ArrayExtensions.Until``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Select all the items in this array from the beginning until (but not including) <see cref="!:startingItem"/>
            
            If <see cref="!:startingItem"/> is not found in the array, Until will select all items.
            If <see cref="!:startingItem"/> is the first item in the array, an empty array will be returned.
            </summary>
        </member>
        <member name="T:Akka.Util.Internal.AtomicCounter">
            <summary>
            An atomic 32 bit integer counter.
            </summary>
        </member>
        <member name="T:Akka.Util.Internal.IAtomicCounter`1">
            <summary>
            An interface that describes a numeric counter.
            </summary>
            <typeparam name="T">The type of the numeric.</typeparam>
        </member>
        <member name="M:Akka.Util.Internal.IAtomicCounter`1.Next">
            <summary>
            Increments the counter and gets the next value. This is exactly the same as calling <see cref="M:Akka.Util.Internal.IAtomicCounter`1.IncrementAndGet"/>.
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.IAtomicCounter`1.GetAndIncrement">
            <summary>
            Atomically increments the counter by one.
            </summary>
            <returns>The original value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.IAtomicCounter`1.IncrementAndGet">
            <summary>
            Atomically increments the counter by one.
            </summary>
            <returns>The new value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.IAtomicCounter`1.GetAndAdd(`0)">
            <summary>
            Returns the current value and adds the specified value to the counter.
            </summary>
            <param name="amount">The amount to add to the counter.</param>
            <returns>The original value before additions.</returns>
        </member>
        <member name="M:Akka.Util.Internal.IAtomicCounter`1.AddAndGet(`0)">
            <summary>
            Adds the specified value to the counter and returns the new value.
            </summary>
            <param name="amount">The amount to add to the counter.</param>
            <returns>The new value after additions.</returns>
        </member>
        <member name="M:Akka.Util.Internal.IAtomicCounter`1.Reset">
            <summary>
            Resets the counter to zero.
            </summary>
        </member>
        <member name="P:Akka.Util.Internal.IAtomicCounter`1.Current">
            <summary>
            The current value of this counter.
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.#ctor(System.Int32)">
            <summary>
            Creates an instance of an AtomicCounter.
            </summary>
            <param name="initialValue">The initial value of this counter.</param>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.#ctor">
            <summary>
            Creates an instance of an AtomicCounter with a starting value of -1.
            </summary>
        </member>
        <member name="F:Akka.Util.Internal.AtomicCounter._value">
            <summary>
            The current value of the atomic counter.
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.Next">
            <summary>
            Increments the counter and returns the next value
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.GetAndIncrement">
            <summary>
            Atomically increments the counter by one.
            </summary>
            <returns>The original value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.IncrementAndGet">
            <summary>
            Atomically increments the counter by one.
            </summary>
            <returns>The new value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.GetAndAdd(System.Int32)">
            <summary>
            Returns the current value and adds the specified value to the counter.
            </summary>
            <param name="amount">The amount to add to the counter.</param>
            <returns>The original value before additions.</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.AddAndGet(System.Int32)">
            <summary>
            Adds the specified value to the counter and returns the new value.
            </summary>
            <param name="amount">The amount to add to the counter.</param>
            <returns>The new value after additions.</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.Reset">
            <summary>
            Resets the counter to zero.
            </summary>
        </member>
        <member name="P:Akka.Util.Internal.AtomicCounter.Current">
            <summary>
            Retrieves the current value of the counter
            </summary>
        </member>
        <member name="T:Akka.Util.Internal.AtomicCounterLong">
            <summary>
            An atomic 64 bit integer counter.
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.#ctor(System.Int64)">
            <summary>
            Creates an instance of an AtomicCounterLong.
            </summary>
            <param name="value">The initial value of this counter.</param>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.#ctor">
            <summary>
            Creates an instance of an AtomicCounterLong with a starting value of -1.
            </summary>
        </member>
        <member name="F:Akka.Util.Internal.AtomicCounterLong._value">
            <summary>
            The current value for this counter.
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.Next">
            <summary>
            Increments the counter and returns the next value.
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.GetAndIncrement">
            <summary>
            Atomically increments the counter by one.
            </summary>
            <returns>The original value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.IncrementAndGet">
            <summary>
            Atomically increments the counter by one.
            </summary>
            <returns>The new value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.GetAndAdd(System.Int64)">
            <summary>
            Gets the current value of the counter and adds an amount to it.
            </summary>
            <remarks>This uses a CAS loop as Interlocked.Increment is not atomic for longs on 32bit systems.</remarks>
            <param name="amount">The amount to add to the counter.</param>
            <returns>The original value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.AddAndGet(System.Int64)">
            <summary>
            Adds an amount to the counter and returns the new value.
            </summary>
            <remarks>This uses a CAS loop as Interlocked.Increment is not atomic for longs on 32bit systems.</remarks>
            <param name="amount">The amount to add to the counter.</param>
            <returns>The new counter value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.Reset">
            <summary>
            Resets the counter to zero.
            </summary>
        </member>
        <member name="P:Akka.Util.Internal.AtomicCounterLong.Current">
            <summary>
            Retrieves the current value of the counter
            </summary>
        </member>
        <member name="T:Akka.Actor.IHandle`1">
            <summary>
                Interface IHandle
            </summary>
            <typeparam name="TMessage">The type of the t message.</typeparam>
        </member>
        <member name="M:Akka.Actor.IHandle`1.Handle(`0)">
            <summary>
                Handles the specified message.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="T:Akka.Actor.TypedActor">
            <summary>
                Class TypedActor.
            </summary>
        </member>
        <member name="M:Akka.Actor.TypedActor.Receive(System.Object)">
            <summary>
                Processor for user defined messages.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="T:Akka.Routing.BroadcastPool">
            <summary>
            Class BroadcastPool.
            </summary>
        </member>
        <member name="M:Akka.Routing.BroadcastPool.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.BroadcastPool"/> class.
            </summary>
            <param name="config">The configuration.</param>
        </member>
        <member name="M:Akka.Routing.BroadcastPool.#ctor(System.Int32,Akka.Routing.Resizer,Akka.Actor.SupervisorStrategy,System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.BroadcastPool"/> class.
            </summary>
            <param name="nrOfInstances">The nr of instances.</param>
            <param name="resizer">The resizer.</param>
            <param name="supervisorStrategy">The supervisor strategy.</param>
            <param name="routerDispatcher">The router dispatcher.</param>
            <param name="usePoolDispatcher">if set to <c>true</c> [use pool dispatcher].</param>
        </member>
        <member name="M:Akka.Routing.BroadcastPool.#ctor(System.Int32)">
            <summary>
            Simple form of BroadcastPool constructor
            </summary>
            <param name="nrOfInstances">The nr of instances.</param>
        </member>
        <member name="M:Akka.Routing.BroadcastPool.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates the router.
            </summary>
            <param name="system">The system.</param>
            <returns>Router.</returns>
        </member>
        <member name="M:Akka.Routing.BroadcastGroup.#ctor(Akka.Configuration.Config)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Routing.BroadcastGroup"/> class.
            </summary>
            <param name="config">The configuration.</param>
        </member>
        <member name="M:Akka.Routing.BroadcastGroup.#ctor(System.String[])">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Routing.BroadcastGroup"/> class.
            </summary>
            <param name="paths">The paths.</param>
        </member>
        <member name="M:Akka.Routing.BroadcastGroup.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Routing.BroadcastGroup"/> class.
            </summary>
            <param name="paths">The paths.</param>
        </member>
        <member name="M:Akka.Routing.BroadcastGroup.#ctor(System.Collections.Generic.IEnumerable{Akka.Actor.IActorRef})">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Routing.BroadcastGroup"/> class.
            </summary>
            <param name="routees">The routees.</param>
        </member>
        <member name="M:Akka.Routing.BroadcastGroup.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
                Creates the router.
            </summary>
            <returns>Router.</returns>
        </member>
        <member name="T:Akka.Routing.ConsistentHash`1">
            <summary>
            Consistent Hashing node ring implementation.
            
             A good explanation of Consistent Hashing:
            http://weblogs.java.net/blog/tomwhite/archive/2007/11/consistent_hash.html
            
            Note that toString of the ring nodes are used for the node
            hash, i.e. make sure it is different for different nodes.
            </summary>
        </member>
        <member name="F:Akka.Routing.ConsistentHash`1._ring">
            <summary>
            arrays for fast binary search access
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHash`1.Add(`0)">
            <summary>
            Add a node to the hash ring.
            
            Note that <see cref="T:Akka.Routing.ConsistentHash`1"/> is immutable and
            this operation returns a new instance.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHash`1.Remove(`0)">
            <summary>
            Removes a node from the hash ring.
            
            Note that <see cref="T:Akka.Routing.ConsistentHash`1"/> is immutable and
            this operation returns a new instance.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHash`1.Idx(System.Int32)">
            <summary>
            Converts the result of <see cref="M:System.Array.BinarySearch``1(``0[],``0)"/> into an index in the 
            <see cref="P:Akka.Routing.ConsistentHash`1.RingTuple"/> array.
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHash`1.NodeFor(System.Byte[])">
            <summary>
            Get the node responsible for the data key.
            Can only be used if nodes exist in the node ring.
            Otherwise throws <see cref="T:System.ArgumentException"/>.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHash`1.NodeFor(System.String)">
            <summary>
            Get the node responsible for the data key.
            Can only be used if nodes exist in the node ring.
            Otherwise throws <see cref="T:System.ArgumentException"/>.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHash`1.op_Addition(Akka.Routing.ConsistentHash{`0},`0)">
            <summary>
            Add a node to the hash ring.
            
            Note that <see cref="T:Akka.Routing.ConsistentHash`1"/> is immutable and
            this operation returns a new instance.
            </summary>s
        </member>
        <member name="M:Akka.Routing.ConsistentHash`1.op_Subtraction(Akka.Routing.ConsistentHash{`0},`0)">
            <summary>
            Removes a node from the hash ring.
            
            Note that <see cref="T:Akka.Routing.ConsistentHash`1"/> is immutable and
            this operation returns a new instance.
            </summary>
        </member>
        <member name="P:Akka.Routing.ConsistentHash`1.NodeHashRing">
            <summary>
            Sorted hash values of the nodes
            </summary>
        </member>
        <member name="P:Akka.Routing.ConsistentHash`1.NodeRing">
            <summary>
            NodeRing is the nodes sorted in the same order as <see cref="P:Akka.Routing.ConsistentHash`1.NodeHashRing"/>, i.e. same index
            </summary>
        </member>
        <member name="P:Akka.Routing.ConsistentHash`1.IsEmpty">
            <summary>
            Is the node ring empty? i.e. no nodes added or all removed
            </summary>
        </member>
        <member name="T:Akka.Routing.ConsistentHash">
            <summary>
            Static helper class for creating <see cref="T:Akka.Routing.ConsistentHash`1"/> instances.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHash.Create``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Factory method to create a <see cref="T:Akka.Routing.ConsistentHash`1"/> instance.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHash.ToBytesOrObject(System.Object)">
            <summary>
            Translate the offered object into a byte array, or returns the original object
            if it needs to be serialized first.
            </summary>
            <param name="obj">An arbitrary .NET object</param>
            <returns>The object encoded into bytes - in the case of custom classes, the hashcode may be used.</returns>
        </member>
        <member name="T:Akka.Routing.ListenerSupport">
            <summary>
            Adds <see cref="T:Akka.Routing.IListeners"/> capabilities to a class, but has to be wired int manually into
            the <see cref="!:ActorBase.OnReceive"/> method.
            </summary>
        </member>
        <member name="M:Akka.Routing.ListenerSupport.Gossip(System.Object)">
            <summary>
            Send the supplied message to all listeners
            </summary>
        </member>
        <member name="M:Akka.Routing.ListenerSupport.Gossip(System.Object,Akka.Actor.IActorRef)">
            <summary>
            Send the supplied message to all listeners
            </summary>
        </member>
        <member name="P:Akka.Routing.ListenerSupport.ListenerReceive">
            <summary>
            Chain this into the <see cref="!:ActorBase.OnReceive"/> function.
            </summary>
        </member>
        <member name="T:Akka.Routing.RandomLogic">
            <summary>
                Class RandomLogic.
            </summary>
        </member>
        <member name="M:Akka.Routing.RandomLogic.Select(System.Object,Akka.Routing.Routee[])">
            <summary>
                Selects the routee for the given message.
            </summary>
            <param name="message">The message.</param>
            <param name="routees">The routees.</param>
            <returns>Routee.</returns>
        </member>
        <member name="T:Akka.Routing.RandomGroup">
            <summary>
                Class RandomGroup.
            </summary>
        </member>
        <member name="M:Akka.Routing.RandomGroup.#ctor(Akka.Configuration.Config)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Routing.RandomGroup"/> class.
            </summary>
            <param name="config">The configuration.</param>
        </member>
        <member name="M:Akka.Routing.RandomGroup.#ctor(System.String[])">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Routing.RandomGroup"/> class.
            </summary>
            <param name="paths">The paths.</param>
        </member>
        <member name="M:Akka.Routing.RandomGroup.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Routing.RandomGroup"/> class.
            </summary>
            <param name="paths">The paths.</param>
        </member>
        <member name="M:Akka.Routing.RandomGroup.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
                Creates the router.
            </summary>
            <returns>Router.</returns>
        </member>
        <member name="M:Akka.Routing.RandomPool.#ctor(System.Int32,Akka.Routing.Resizer,Akka.Actor.SupervisorStrategy,System.String,System.Boolean)">
            <summary>
            </summary>
            <param name="nrOfInstances">The nr of instances.</param>
            <param name="resizer">The resizer.</param>
            <param name="supervisorStrategy">The supervisor strategy.</param>
            <param name="routerDispatcher">The router dispatcher.</param>
            <param name="usePoolDispatcher">if set to <c>true</c> [use pool dispatcher].</param>
        </member>
        <member name="M:Akka.Routing.RandomPool.#ctor(System.Int32)">
            <summary>
                Simple form of RandomPool constructor
            </summary>
            <param name="nrOfInstances">The nr of instances.</param>
        </member>
        <member name="M:Akka.Routing.RandomPool.#ctor(System.Int32,Akka.Routing.Resizer)">
            <summary>
                Simple form of RandomPool constructor
            </summary>
            <param name="nrOfInstances">The nr of instances.</param>
            <param name="resizer">
                A <see cref="T:Akka.Routing.Resizer"/> for specifying how to grow the pool of underlying routees based on
                pressure
            </param>
        </member>
        <member name="M:Akka.Routing.RandomPool.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
                Creates the router.
            </summary>
            <returns>Router.</returns>
        </member>
        <member name="T:Akka.Routing.ResizablePoolActor">
            <summary>
            INTERNAL API.
            
            Defines <see cref="T:Akka.Routing.Pool"/> routers who can resize the number of routees
            they use based on a defined <see cref="T:Akka.Routing.Resizer"/>
            </summary>
        </member>
        <member name="T:Akka.Routing.RouterPoolActor">
            <summary>
            INTERNAL API
            
            Actor implementation for <see cref="P:Akka.Routing.RouterPoolActor.Pool"/> routers.
            </summary>
        </member>
        <member name="T:Akka.Routing.RouterActor">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Routing.RouterPoolActor.#ctor(Akka.Actor.SupervisorStrategy)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RouterPoolActor"/> class.
            </summary>
            <param name="supervisorStrategy">The supervisor strategy.</param>
        </member>
        <member name="M:Akka.Routing.RouterPoolActor.OnReceive(System.Object)">
            <summary>
            Called when [receive].
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="T:Akka.Routing.Resize">
            <summary>
            Command used to resize a <see cref="T:Akka.Routing.ResizablePoolActor"/>
            </summary>
        </member>
        <member name="T:Akka.Routing.RouterManagementMessage">
            <summary>
            Class RouterManagementMessage.
            </summary>
        </member>
        <member name="T:Akka.Routing.ResizablePoolCell">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Routing.RoutedActorCell">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Routing.RoutedActorCell.RemoveRoutees(System.Collections.Generic.IEnumerable{Akka.Routing.Routee},System.Boolean)">
            <summary>
            Remove routees from <see cref="P:Akka.Routing.RoutedActorCell.Router"/>. Messages in flight may still
            be routed to the old <see cref="P:Akka.Routing.RoutedActorCell.Router"/> instance containing the old routees.
            </summary>
            <param name="affectedRoutees"></param>
            <param name="stopChild"></param>
        </member>
        <member name="M:Akka.Routing.RoutedActorCell.StopIfChild(Akka.Routing.Routee)">
            <summary>
            Used to stop child routees - typically used in resizable <see cref="T:Akka.Routing.Pool"/> routers
            </summary>
            <param name="routee"></param>
        </member>
        <member name="M:Akka.Routing.RoutedActorCell.PreSuperStart">
            <summary>
            Called when <see cref="P:Akka.Routing.RoutedActorCell.Router"/> is initialized but before the base class' <see cref="M:Akka.Routing.RoutedActorCell.Start"/> to
            be able to do extra initialization in a subclass.
            </summary>
        </member>
        <member name="F:Akka.Routing.ResizablePoolCell._resizeInProgress">
            <summary>
            must always use ResizeInProgressState static class to compare or assign values
            </summary>
        </member>
        <member name="T:Akka.Routing.Resizer">
            <summary>
            [[Pool]] routers with dynamically resizable number of routees are implemented by providing a Resizer
            implementation in the [[akka.routing.Pool]] configuration
            </summary>
        </member>
        <member name="M:Akka.Routing.Resizer.IsTimeForResize(System.Int64)">
            <summary>
            Is it time for resizing. Typically implemented with modulo of nth message, but
            could be based on elapsed time or something else. The messageCounter starts with 0
            for the initial resize and continues with 1 for the first message. Make sure to perform
            initial resize before first message (messageCounter == 0), because there is no guarantee
            that resize will be done when concurrent messages are in play.
            
            CAUTION: this method is invoked from the thread which tries to send a
            message to the pool, i.e. the ActorRef.!() method, hence it may be called
            concurrently.
            </summary>
            <param name="messageCounter"></param>
            <returns></returns>
        </member>
        <member name="M:Akka.Routing.Resizer.Resize(System.Collections.Generic.IEnumerable{Akka.Routing.Routee})">
             <summary>
             Decide if the capacity of the router need to be changed. Will be invoked when `isTimeForResize`
             returns true and no other resize is in progress.
            
             Return the number of routees to add or remove. Negative value will remove that number of routees.
             Positive value will add that number of routess. 0 will not change the routees.
            
             This method is invoked only in the context of the Router actor.
             </summary>
             <param name="currentRoutees"></param>
             <returns></returns>
        </member>
        <member name="T:Akka.Routing.DefaultResizer">
            <summary>
            Implementation of [[Resizer]] that adjust the [[Pool]] based on specified thresholds.
            </summary>
        </member>
        <member name="M:Akka.Routing.DefaultResizer.#ctor(Akka.Configuration.Config)">
            <summary>
            Creates a new DefaultResizer from the given configuration
            </summary>
            <param name="resizerConfig"></param>
        </member>
        <member name="M:Akka.Routing.DefaultResizer.Capacity(System.Collections.Generic.IEnumerable{Akka.Routing.Routee})">
            <summary>
            Returns the overall desired change in resizer capacity. Positive value will
            add routees to the resizer. Negative value will remove routees from the
            resizer
            </summary>
            <param name="currentRoutees">The current actor in the resizer</param>
            <returns>the number of routees by which the resizer should be adjusted (positive, negative or zero)</returns>
        </member>
        <member name="M:Akka.Routing.DefaultResizer.Filter(System.Int32,System.Int32)">
            <summary>
            This method can be used to smooth the capacity delta by considering
            the current pressure and current capacity.
            </summary>
            <param name="pressure">pressure current number of busy routees</param>
            <param name="capacity">capacity current number of routees</param>
            <returns>proposed change in the capacity</returns>
        </member>
        <member name="M:Akka.Routing.DefaultResizer.Backoff(System.Int32,System.Int32)">
            <summary>
            Computes a proposed negative (or zero) capacity delta using
            the configured `backoffThreshold` and `backoffRate`
            </summary>
            <param name="pressure">pressure current number of busy routees</param>
            <param name="capacity">capacity current number of routees</param>
            <returns>proposed decrease in capacity (as a negative number)</returns>
        </member>
        <member name="M:Akka.Routing.DefaultResizer.Rampup(System.Int32,System.Int32)">
            <summary>
            Computes a proposed positive (or zero) capacity delta using
            the configured `rampupRate`.
            </summary>
            <param name="pressure">the current number of busy routees</param>
            <param name="capacity">the current number of total routees</param>
            <returns>proposed increase in capacity</returns>
        </member>
        <member name="M:Akka.Routing.DefaultResizer.Pressure(System.Collections.Generic.IEnumerable{Akka.Routing.Routee})">
             <summary>
             Number of routees considered busy, or above 'pressure level'.
            
             Implementation depends on the value of `pressureThreshold`
             (default is 1).
             <ul>
             <li> 0:   number of routees currently processing a message.</li>
             <li> 1:   number of routees currently processing a message has
                       some messages in mailbox.</li>
             <li> > 1: number of routees with at least the configured `pressureThreshold`
                       messages in their mailbox. Note that estimating mailbox size of
                       default UnboundedMailbox is O(N) operation.</li>
             </ul>
             </summary>
             <param name="currentRoutees"></param>
             <returns></returns>
        </member>
        <member name="P:Akka.Routing.DefaultResizer.LowerBound">
            <summary>
            The fewest number of routees the router should ever have.
            </summary>
        </member>
        <member name="P:Akka.Routing.DefaultResizer.UpperBound">
            <summary>
            The most number of routees the router should ever have. 
            Must be greater than or equal to `lowerBound`.
            </summary>
        </member>
        <member name="P:Akka.Routing.DefaultResizer.PressureThreshold">
            <summary>
            * Threshold to evaluate if routee is considered to be busy (under pressure).
            Implementation depends on this value (default is 1).
            <ul>
            <li> 0:   number of routees currently processing a message.</li>
            <li> 1:   number of routees currently processing a message has
                      some messages in mailbox.</li>
            <li> > 1: number of routees with at least the configured `pressureThreshold`
                      messages in their mailbox. Note that estimating mailbox size of
                      default UnboundedMailbox is O(N) operation.</li>
            </ul>
            </summary>
        </member>
        <member name="P:Akka.Routing.DefaultResizer.RampupRate">
            <summary>
            Percentage to increase capacity whenever all routees are busy.
            For example, 0.2 would increase 20% (rounded up), i.e. if current
            capacity is 6 it will request an increase of 2 more routees.
            </summary>
        </member>
        <member name="P:Akka.Routing.DefaultResizer.BackoffThreshold">
             <summary>
             Minimum fraction of busy routees before backing off.
             For example, if this is 0.3, then we'll remove some routees only when
             less than 30% of routees are busy, i.e. if current capacity is 10 and
             3 are busy then the capacity is unchanged, but if 2 or less are busy
             the capacity is decreased.
            
             Use 0.0 or negative to avoid removal of routees.
             </summary>
        </member>
        <member name="P:Akka.Routing.DefaultResizer.BackoffRate">
            <summary>
            Fraction of routees to be removed when the resizer reaches the
            backoffThreshold.
            For example, 0.1 would decrease 10% (rounded up), i.e. if current
            capacity is 9 it will request an decrease of 1 routee.
            </summary>
        </member>
        <member name="P:Akka.Routing.DefaultResizer.MessagesPerResize">
            <summary>
            Number of messages between resize operation.
            Use 1 to resize before each message.
            </summary>
        </member>
        <member name="T:Akka.Routing.RoundRobinRoutingLogic">
            <summary>
                Class RoundRobinRoutingLogic.
            </summary>
        </member>
        <member name="F:Akka.Routing.RoundRobinRoutingLogic._next">
            <summary>
                The next
            </summary>
        </member>
        <member name="M:Akka.Routing.RoundRobinRoutingLogic.Select(System.Object,Akka.Routing.Routee[])">
            <summary>
                Selects the specified message.
            </summary>
            <param name="message">The message.</param>
            <param name="routees">The routees.</param>
            <returns>Routee.</returns>
        </member>
        <member name="T:Akka.Routing.RoundRobinGroup">
             <summary>
             A router group that uses round-robin to select a routee. For concurrent calls,
             round robin is just a best effort.
            
             The configuration parameter trumps the constructor arguments. This means that
             if you provide `paths` during instantiation they will be ignored if
             the router is defined in the configuration file for the actor being used.
             </summary>
        </member>
        <member name="M:Akka.Routing.RoundRobinGroup.#ctor(Akka.Configuration.Config)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Routing.RoundRobinGroup"/> class.
            </summary>
            <param name="config">The configuration.</param>
        </member>
        <member name="M:Akka.Routing.RoundRobinGroup.#ctor(System.String[])">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Routing.RoundRobinGroup"/> class.
            </summary>
            <param name="paths">The paths.</param>
        </member>
        <member name="M:Akka.Routing.RoundRobinGroup.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Routing.RoundRobinGroup"/> class.
            </summary>
            <param name="paths">The paths.</param>
        </member>
        <member name="M:Akka.Routing.RoundRobinGroup.#ctor(System.Collections.Generic.IEnumerable{Akka.Actor.IActorRef})">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Routing.RoundRobinGroup"/> class.
            </summary>
            <param name="routees">The routees.</param>
        </member>
        <member name="M:Akka.Routing.RoundRobinGroup.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
                Creates the router.
            </summary>
            <returns>Router.</returns>
        </member>
        <member name="T:Akka.Routing.RoundRobinPool">
            <summary>
                Class RoundRobinPool.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Akka.Routing.RoundRobinPool.#ctor(System.Int32,Akka.Routing.Resizer,Akka.Actor.SupervisorStrategy,System.String,System.Boolean)" -->
        <member name="M:Akka.Routing.RoundRobinPool.#ctor(System.Int32)">
            <summary>
            Simple form of RoundRobin constructor
            </summary>
            <param name="nrOfInstances">The nr of instances.</param>
        </member>
        <member name="M:Akka.Routing.RoundRobinPool.#ctor(System.Int32,Akka.Routing.Resizer)">
            <summary>
            Simple form of RoundRobin constructor
            </summary>
            <param name="nrOfInstances">The nr of instances.</param>
            <param name="resizer">A <see cref="T:Akka.Routing.Resizer"/> for specifying how to grow the pool of underlying routees based on pressure</param>
        </member>
        <member name="M:Akka.Routing.RoundRobinPool.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
                Creates the router.
            </summary>
            <returns>Router.</returns>
        </member>
        <member name="M:Akka.Routing.Router.WithRoutees(Akka.Routing.Routee[])">
            <summary>
            Create a new instance with the specified routees and the same <see cref="P:Akka.Routing.Router.RoutingLogic"/>.
            </summary>
        </member>
        <member name="M:Akka.Routing.Router.AddRoutee(Akka.Routing.Routee)">
            <summary>
            Create a new instance with one more routee and the same <see cref="P:Akka.Routing.Router.RoutingLogic"/>.
            </summary>
        </member>
        <member name="M:Akka.Routing.Router.AddRoutee(Akka.Actor.IActorRef)">
            <summary>
            Create a new instance with one more routee and the same <see cref="P:Akka.Routing.Router.RoutingLogic"/>.
            </summary>
        </member>
        <member name="M:Akka.Routing.Router.AddRoutee(Akka.Actor.ActorSelection)">
            <summary>
            Create a new instance with one more routee and the same <see cref="P:Akka.Routing.Router.RoutingLogic"/>.
            </summary>  
        </member>
        <member name="M:Akka.Routing.Router.RemoveRoutee(Akka.Routing.Routee)">
            <summary>
            Create a new instance without the specified routee.
            </summary>
        </member>
        <member name="M:Akka.Routing.Router.RemoveRoutee(Akka.Actor.IActorRef)">
            <summary>
            Create a new instance without the specified routee.
            </summary>
        </member>
        <member name="M:Akka.Routing.Router.RemoveRoutee(Akka.Actor.ActorSelection)">
            <summary>
            Create a new instance without the specified routee.
            </summary>
        </member>
        <member name="T:Akka.Routing.NoRouter">
            <summary>
            Signals that no Router is to be used with a given <see cref="T:Akka.Actor.Props"/>
            </summary>
        </member>
        <member name="T:Akka.Routing.FromConfig">
            <summary>
            Used to tell <see cref="T:Akka.Actor.IActorRefProvider"/> to create router based on what's stored in configuration.
            
            For example:
            <code>
                 ActorRef router1 = Sys.ActorOf(Props.Create{Echo}().WithRouter(FromConfig.Instance), "router1");
            </code>
            </summary>
        </member>
        <member name="T:Akka.Routing.RouterMessage">
            <summary>
            Class RouterMessage.
            </summary>
        </member>
        <member name="F:Akka.Routing.RouterMessage.GetRoutees">
            <summary>
            The get routees
            </summary>
        </member>
        <member name="T:Akka.Routing.GetRoutees">
            <summary>
            Class GetRoutees. This class cannot be inherited.
            </summary>
        </member>
        <member name="T:Akka.Routing.Routees">
            <summary>
            Class Routees. This class cannot be inherited.
            </summary>
        </member>
        <member name="M:Akka.Routing.Routees.#ctor(System.Collections.Generic.IEnumerable{Akka.Routing.Routee})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.Routees"/> class.
            </summary>
            <param name="routees">The routees.</param>
        </member>
        <member name="P:Akka.Routing.Routees.Members">
            <summary>
            Gets the members.
            </summary>
            <value>The members.</value>
        </member>
        <member name="T:Akka.Routing.RemoveRoutee">
            <summary>
            Remove a specific routee by sending this message to the <see cref="T:Akka.Routing.Router"/>.
            It may be handled after other messages.
            
            For a pool with child routees the routee is stopped by sending a <see cref="T:Akka.Actor.PoisonPill"/>
            to the routee. Precautions are taken to reduce the risk of dropping messages that are concurrently
            being routed to the remove routee, but there are no guarantees. 
            </summary>
        </member>
        <member name="T:Akka.Routing.AddRoutee">
            <summary>
            Add a routee by sending this message to the router.
            It may be handled after other messages.
            </summary>
        </member>
        <member name="T:Akka.Routing.AdjustPoolSize">
            <summary>
            Increase or decrease the number of routees in a <see cref="T:Akka.Routing.Pool"/>.
            It may be handled after other messages.
            
            Positive <see cref="P:Akka.Routing.AdjustPoolSize.Change"/> will add that number of routees to the <see cref="T:Akka.Routing.Pool"/>.
            Negative <see cref="P:Akka.Routing.AdjustPoolSize.Change"/> will remove that number of routees from the <see cref="T:Akka.Routing.Pool"/>.
            Routees are stopped by sending a <see cref="T:Akka.Actor.PoisonPill"/> to the routee.
            Precautions are taken to reduce the risk of dropping messages that are concurrently
            being routed to the remove routee, but there are no guarantees. 
            </summary>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedGroup.#ctor(Akka.Configuration.Config)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Routing.ScatterGatherFirstCompletedGroup"/> class.
            </summary>
            <param name="config">The configuration.</param>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedGroup.#ctor(System.TimeSpan,System.String[])">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Routing.ScatterGatherFirstCompletedGroup"/> class.
            </summary>
            <param name="within">Expect a response within the given timespan</param>
            <param name="paths">The paths.</param>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedGroup.#ctor(System.Collections.Generic.IEnumerable{System.String},System.TimeSpan)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Routing.ScatterGatherFirstCompletedGroup"/> class.
            </summary>
            <param name="paths">The paths.</param>
            <param name="within">Expect a response within the given timespan</param>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedGroup.#ctor(System.Collections.Generic.IEnumerable{Akka.Actor.IActorRef},System.TimeSpan)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Routing.ScatterGatherFirstCompletedGroup"/> class.
            </summary>
            <param name="routees">The routees.</param>
            <param name="within">Expect a response within the given timespan</param>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedGroup.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
                Creates the router.
            </summary>
            <returns>Router.</returns>
        </member>
        <member name="T:Akka.Routing.ScatterGatherFirstCompletedPool">
            <summary>
                Class RoundRobinPool.
            </summary>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedPool.#ctor(System.Int32,Akka.Routing.Resizer,Akka.Actor.SupervisorStrategy,System.String,System.TimeSpan,System.Boolean)">
            <summary>
            </summary>
            <param name="nrOfInstances">The nr of instances.</param>
            <param name="resizer">The resizer.</param>
            <param name="supervisorStrategy">The supervisor strategy.</param>
            <param name="routerDispatcher">The router dispatcher.</param>
            <param name="within">Expect a response within the given timespan</param>
            <param name="usePoolDispatcher">if set to <c>true</c> [use pool dispatcher].</param>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedPool.#ctor(System.Int32)">
            <summary>
            Simple form of RoundRobin constructor
            </summary>
            <param name="nrOfInstances">The nr of instances.</param>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedPool.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
                Creates the router.
            </summary>
            <returns>Router.</returns>
        </member>
        <member name="T:Akka.Serialization.JavaSerializer">
            <summary>
                Class JavaSerializer.
            </summary>
        </member>
        <member name="M:Akka.Serialization.JavaSerializer.#ctor(Akka.Actor.ExtendedActorSystem)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Serialization.JavaSerializer"/> class.
            </summary>
            <param name="system">The system.</param>
        </member>
        <member name="M:Akka.Serialization.JavaSerializer.ToBinary(System.Object)">
            <summary>
                To the binary.
            </summary>
            <param name="obj">The object.</param>
            <returns>System.Byte[][].</returns>
            <exception cref="T:System.NotSupportedException"></exception>
            Serializes the given object into an Array of Byte
        </member>
        <member name="M:Akka.Serialization.JavaSerializer.FromBinary(System.Byte[],System.Type)">
            <summary>
                Froms the binary.
            </summary>
            <param name="bytes">The bytes.</param>
            <param name="type">The type.</param>
            <returns>System.Object.</returns>
            <exception cref="T:System.NotSupportedException"></exception>
            Produces an object from an array of bytes, with an optional type;
        </member>
        <member name="P:Akka.Serialization.JavaSerializer.Identifier">
            <summary>
                Gets the identifier.
            </summary>
            <value>The identifier.</value>
            Completely unique value to identify this implementation of Serializer, used to optimize network traffic
            Values from 0 to 16 is reserved for Akka internal usage
        </member>
        <member name="P:Akka.Serialization.JavaSerializer.IncludeManifest">
            <summary>
                Gets a value indicating whether [include manifest].
            </summary>
            <value><c>true</c> if [include manifest]; otherwise, <c>false</c>.</value>
            <exception cref="T:System.NotSupportedException"></exception>
            Returns whether this serializer needs a manifest in the fromBinary method
        </member>
        <member name="T:Akka.Util.AtomicReference`1">
            <summary>
            Implementation of the java.concurrent.util AtomicReference type.
            
            Uses <see cref="M:System.Threading.Interlocked.MemoryBarrier"/> internally to enforce ordering of writes
            without any explicit locking. .NET's strong memory on write guarantees might already enforce
            this ordering, but the addition of the MemoryBarrier guarantees it.
            </summary>
        </member>
        <member name="M:Akka.Util.AtomicReference`1.#ctor(`0)">
            <summary>
            Sets the initial value of this <see cref="T:Akka.Util.AtomicReference`1"/> to <see cref="!:originalValue"/>.
            </summary>
        </member>
        <member name="M:Akka.Util.AtomicReference`1.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Akka.Util.AtomicReference`1.CompareAndSet(`0,`0)">
            <summary>
            If <see cref="P:Akka.Util.AtomicReference`1.Value"/> equals <see cref="!:expected"/>, then set the Value to
            <see cref="!:newValue"/>.
            </summary>
            <returns><c>true</c> if <see cref="!:newValue"/> was set</returns>
        </member>
        <member name="M:Akka.Util.AtomicReference`1.op_Implicit(Akka.Util.AtomicReference{`0})~`0">
            <summary>
            Implicit conversion operator = automatically casts the <see cref="T:Akka.Util.AtomicReference`1"/> to an instance of <typeparam name="T"></typeparam>
            </summary>
        </member>
        <member name="M:Akka.Util.AtomicReference`1.op_Implicit(`0)~Akka.Util.AtomicReference{`0}">
            <summary>
            Implicit conversion operator = allows us to cast any type directly into a <see cref="T:Akka.Util.AtomicReference`1"/> instance.
            </summary>
            <param name="newValue"></param>
            <returns></returns>
        </member>
        <member name="P:Akka.Util.AtomicReference`1.Value">
            <summary>
            The current value of this <see cref="T:Akka.Util.AtomicReference`1"/>
            </summary>
        </member>
        <member name="T:Akka.Util.AtomicBoolean">
            <summary>
            Implementation of the java.concurrent.util.AtomicBoolean type.
            
            Uses <see cref="M:System.Threading.Interlocked.MemoryBarrier"/> internally to enforce ordering of writes
            without any explicit locking. .NET's strong memory on write guarantees might already enforce
            this ordering, but the addition of the MemoryBarrier guarantees it.
            </summary>
        </member>
        <member name="M:Akka.Util.AtomicBoolean.#ctor(System.Boolean)">
            <summary>
            Sets the initial value of this <see cref="T:Akka.Util.AtomicBoolean"/> to <see cref="!:initialValue"/>.
            </summary>
        </member>
        <member name="M:Akka.Util.AtomicBoolean.CompareAndSet(System.Boolean,System.Boolean)">
            <summary>
            If <see cref="P:Akka.Util.AtomicBoolean.Value"/> equals <see cref="!:expected"/>, then set the Value to
            <see cref="!:newValue"/>.
            </summary>
            <returns><c>true</c> if <see cref="!:newValue"/> was set</returns>
        </member>
        <member name="M:Akka.Util.AtomicBoolean.op_Implicit(Akka.Util.AtomicBoolean)~System.Boolean">
            <summary>
            Implicit conversion operator = automatically casts the <see cref="T:Akka.Util.AtomicBoolean"/> to a <see cref="T:System.Boolean"/>
            </summary>
        </member>
        <member name="M:Akka.Util.AtomicBoolean.op_Implicit(System.Boolean)~Akka.Util.AtomicBoolean">
            <summary>
            Implicit conversion operator = allows us to cast any bool directly into a <see cref="T:Akka.Util.AtomicBoolean"/> instance.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:Akka.Util.AtomicBoolean.Value">
            <summary>
            The current value of this <see cref="T:Akka.Util.AtomicReference`1"/>
            </summary>
        </member>
        <member name="T:Akka.Util.ListPriorityQueue">
            <summary>
            Priority queue implemented using a simple list with binary search for inserts.
            This specific implementation is cheap in terms of memory but weak in terms of performance.
            See http://visualstudiomagazine.com/articles/2012/11/01/priority-queues-with-c.aspx for original implementation
            This specific version is adapted for Envelopes only and calculates a priority of envelope.Message
            </summary>
        </member>
        <member name="T:Akka.Util.MurmurHash">
            <summary>
            Murmur3 Hash implementation
            </summary>
        </member>
        <member name="F:Akka.Util.MurmurHash.StartMagicA">
            <summary>
            The initial magic integer in the first stream.
            </summary>
        </member>
        <member name="F:Akka.Util.MurmurHash.StartMagicB">
            <summary>
            The initial magic integer in the second stream.
            </summary>
        </member>
        <member name="F:Akka.Util.MurmurHash.StoredMagicA">
            The first 23 magic integers from the first stream are stored here 
        </member>
        <member name="F:Akka.Util.MurmurHash.StoredMagicB">
            The first 23 magic integers from the second stream are stored here 
        </member>
        <member name="M:Akka.Util.MurmurHash.StartHash(System.UInt32)">
            <summary>
            Begin a new hash with a seed value.
            </summary>
        </member>
        <member name="M:Akka.Util.MurmurHash.NextMagicA(System.UInt32)">
            <summary>
            Given a magic integer from the first stream, compute the next
            </summary>
        </member>
        <member name="M:Akka.Util.MurmurHash.NextMagicB(System.UInt32)">
            <summary>
            Given a magic integer from the second stream, compute the next
            </summary>
        </member>
        <member name="M:Akka.Util.MurmurHash.ExtendHash(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Incorporates a new value into an existing hash
            </summary>
            <param name="hash">The prior hash value</param>
            <param name="value">The new value to incorporate</param>
            <param name="magicA">A magic integer from the left of the stream</param>
            <param name="magicB">A magic integer from a different stream</param>
            <returns>The updated hash value</returns>
        </member>
        <member name="M:Akka.Util.MurmurHash.FinalizeHash(System.UInt32)">
            <summary>
            Once all hashes have been incorporated, this performs a final mixing.
            </summary>
        </member>
        <member name="M:Akka.Util.MurmurHash.RotateLeft32(System.UInt32,System.Int32)">
            <summary>
            Rotate a 32-bit unsigned integer to the left by <see cref="!:shift"/> bits
            </summary>
            <param name="original">Original value</param>
            <param name="shift">The shift value</param>
            <returns>The rotated 32-bit integer</returns>
        </member>
        <member name="M:Akka.Util.MurmurHash.RotateLeft64(System.UInt64,System.Int32)">
            <summary>
            Rotate a 64-bit unsigned integer to the left by <see cref="!:shift"/> bits
            </summary>
            <param name="original">Original value</param>
            <param name="shift">The shift value</param>
            <returns>The rotated 64-bit integer</returns>
        </member>
        <member name="M:Akka.Util.MurmurHash.ByteHash(System.Byte[])">
            <summary>
            Compute a high-quality hash of a byte array
            </summary>
        </member>
        <member name="M:Akka.Util.MurmurHash.ArrayHash``1(``0[])">
            <summary>
            Compute a high-quality hash of an array
            </summary>
        </member>
        <member name="M:Akka.Util.MurmurHash.StringHash(System.String)">
            <summary>
            Compute high-quality hash of a string
            </summary>
        </member>
        <member name="M:Akka.Util.MurmurHash.SymmetricHash``1(System.Collections.Generic.IEnumerable{``0},System.UInt32)">
            <summary>
            Compute a hash that is symmetric in its arguments--that is,
            where the order of appearance of elements does not matter.
            This is useful for hashing sets, for example.
            </summary>
        </member>
        <member name="T:Akka.Util.BitArrayHelpers">
            <summary>
            Extension method class to make it easier to work with <see cref="T:System.Collections.BitArray"/> instances
            </summary>
        </member>
        <member name="M:Akka.Util.BitArrayHelpers.ToBytes(System.Collections.BitArray)">
            <summary>
            Converts a <see cref="T:System.Collections.BitArray"/> into an array of <see cref="T:System.Byte"/>
            </summary>
        </member>
        <member name="T:Akka.PatternMatch">
            <summary>
            Class PatternMatch.
            </summary>
        </member>
        <member name="M:Akka.PatternMatch.Match(System.Object)">
            <summary>
            Matches the specified target.
            </summary>
            <param name="target">The target.</param>
            <returns>Case.</returns>
        </member>
        <member name="T:Akka.IMatchResult">
            <summary>
            Interface IMatchResult
            </summary>
        </member>
        <member name="P:Akka.IMatchResult.WasHandled">
            <summary>
            Gets a value indicating whether [was handled].
            </summary>
            <value><c>true</c> if [was handled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:Akka.Case">
            <summary>
            Class Case.
            </summary>
        </member>
        <member name="F:Akka.Case._message">
            <summary>
            The _message
            </summary>
        </member>
        <member name="F:Akka.Case._handled">
            <summary>
            The _handled
            </summary>
        </member>
        <member name="M:Akka.Case.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Case"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Akka.Case.With``1(System.Action)">
            <summary>
            Withes the specified action.
            </summary>
            <typeparam name="TMessage">The type of the t message.</typeparam>
            <param name="action">The action.</param>
            <returns>Case.</returns>
        </member>
        <member name="M:Akka.Case.With``1(System.Action{``0})">
            <summary>
            Withes the specified action.
            </summary>
            <typeparam name="TMessage">The type of the t message.</typeparam>
            <param name="action">The action.</param>
            <returns>Case.</returns>
        </member>
        <member name="M:Akka.Case.Default(System.Action{System.Object})">
            <summary>
            Defaults the specified action.
            </summary>
            <param name="action">The action.</param>
            <returns>IMatchResult.</returns>
        </member>
        <member name="P:Akka.Case.WasHandled">
            <summary>
            Gets a value indicating whether [was handled].
            </summary>
            <value><c>true</c> if [was handled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:Akka.Case.AlwaysHandled">
            <summary>
            Class AlwaysHandled.
            </summary>
        </member>
        <member name="F:Akka.Case.AlwaysHandled.Instance">
            <summary>
            The instance
            </summary>
        </member>
        <member name="M:Akka.Case.AlwaysHandled.#ctor">
            <summary>
            Prevents a default instance of the <see cref="T:Akka.Case.AlwaysHandled"/> class from being created.
            </summary>
        </member>
        <member name="P:Akka.Case.AlwaysHandled.WasHandled">
            <summary>
            Gets a value indicating whether [was handled].
            </summary>
            <value><c>true</c> if [was handled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:Akka.Util.ThreadLocalRandom">
            <summary>
            Create random numbers with Thread-specific seeds.
            
            Borrowed form Jon Skeet's brilliant C# in Depth: http://csharpindepth.com/Articles/Chapter12/Random.aspx
            </summary>
        </member>
        <member name="P:Akka.Util.ThreadLocalRandom.Current">
            <summary>
            The current random number seed available to this thread
            </summary>
        </member>
        <member name="T:Akka.Util.WildcardTree`1">
            <summary>
            A searchable nested dictionary, represents a searchable tree structure underneath
            </summary>
        </member>
        <member name="M:Akka.Tools.MatchHandler.ILambdaExpressionCompiler.Compile(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Produces a delegate that represents the lambda expression.
            </summary>
            <param name="expression">The expression to compile</param>
            <returns>A delegate containing the compiled version of the lambda.</returns>
        </member>
        <member name="M:Akka.Tools.MatchHandler.ILambdaExpressionCompiler.CompileToMethod(System.Linq.Expressions.LambdaExpression,System.Reflection.Emit.MethodBuilder)">
            <summary>
            Compiles the lambda into a method definition.
            </summary>
            <param name="expression">The expression to compile</param>
            <param name="method">A <see cref="T:System.Reflection.Emit.MethodBuilder"/> which will be used to hold the lambda's IL.</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.IPartialActionBuilder.Build``1(Akka.Tools.MatchHandler.CompiledMatchHandlerWithArguments)">
            <summary>
            Builds the specified delegate and arguments to a <see cref="T:Akka.Tools.MatchHandler.PartialAction`1">PartialAction&lt;<typeparamref name="T"/>&gt;</see>
            <para>If the number of arguments are 0, the delegate should be a <see cref="T:System.Func`1">Func&lt;<typeparamref name="T"/>,bool&gt;</see></para>
            <para>If the number of arguments are 1, the delegate should be a <see cref="T:System.Func`2">Func&lt;<typeparamref name="T"/>,T1,bool&gt;</see></para>
            <para>...</para>
            <para>If the number of arguments are n, the delegate should be a Func&lt;<typeparamref name="T"/>,T1,...,Tn,bool&gt;</para>
            <para>The maximum number of arguments i.e. n in the above example is therefore <see cref="F:Akka.Tools.MatchHandler.PartialActionBuilder.MaxNumberOfArguments"/>=14</para>
            <para>Given a delegate deleg of type Func&lt;<typeparamref name="T"/>,T1,...,Tn,bool&gt; and args [a_1,...a_n] then 
            the delegate corresponding to this code is returned:
            <example>(value) =&gt; deleg(value,a_1, ..., a_n)</example>
            </para>
            </summary>
            <typeparam name="T">The type of the value parameter in to the returned <see cref="T:Akka.Tools.MatchHandler.PartialAction`1"/></typeparam>
            <param name="handlerAndArgs">The handler, i.e. a Func&lt;<typeparamref name="T"/>,T1,...,Tn,bool&gt; and arguments [a_1,...a_n].</param>
            <returns>Returns a <see cref="T:Akka.Tools.MatchHandler.PartialAction`1"/> that calls the delegate with the arguments.</returns>
        </member>
        <member name="F:Akka.Tools.MatchHandler.PartialActionBuilder.MaxNumberOfArguments">
            <summary>
            The maximum number of arguments=15 not including the obligatory first value argument in a partial action. 
            16 is the maximum number of args in a Func, see <see cref="T:System.Func`17"/>
            </summary>
        </member>
        <member name="F:Akka.Tools.MatchHandler.HandlerKind.Action">
            <summary>The handler is a Action&lt;T&gt;</summary>
        </member>
        <member name="F:Akka.Tools.MatchHandler.HandlerKind.ActionWithPredicate">
            <summary>The handler is a Action&lt;T&gt; and a Predicate&lt;T&gt; is specified</summary>
        </member>
        <member name="F:Akka.Tools.MatchHandler.HandlerKind.Func">
            <summary>The handler is a Func&lt;T, bool&gt;</summary>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchBuilder`1.Match``1(System.Action{``0},System.Predicate{``0})">
            <summary>
            Adds a handler that is called if the item being matched is of type <typeparamref name="T"/>
            and <paramref name="shouldHandle"/>, if it has been specified, returns <c>true</c>.
            <remarks>Note that if a previous added handler handled the item, this <paramref name="handler"/> will not be invoked.</remarks>
            </summary>
            <typeparam name="T">The type that it must match in order for <paramref name="handler"/> to be called.</typeparam>
            <param name="handler">The handler that is invoked when everything matches.</param>
            <param name="shouldHandle">An optional predicate to test if the item matches. If it returns <c>true</c> the <paramref name="handler"/> is invoked.</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchBuilder`1.Match(System.Type,System.Action{`0},System.Predicate{`0})">
            <summary>
            Adds a handler that is called if the item being matched is of type <paramref name="handlesType"/>
            and <paramref name="shouldHandle"/>, if it has been specified, returns <c>true</c>.
            <remarks>Note that if a previous added handler handled the item, this <paramref name="handler"/> will not be invoked.</remarks>
            </summary>
            <param name="handlesType">The type that it must match in order for <paramref name="handler"/> to be called.</param>
            <param name="handler">The handler that is invoked when everything matches.</param>
            <param name="shouldHandle">An optional predicate to test if the item matches. If it returns <c>true</c> the <paramref name="handler"/> is invoked.</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchBuilder`1.Match``1(System.Func{``0,System.Boolean})">
            <summary>
            Adds a handler that is called if the item being matched is of type <typeparamref name="T"/>.
            The handler should return <c>true</c> if the item sent in matched and was handled.
            <remarks>Note that if a previous added handler handled the item, this <paramref name="handler"/> will not be invoked.</remarks>
            </summary>
            <typeparam name="T">The type that it must match in order for <paramref name="handler"/> to be called.</typeparam>
            <param name="handler">The handler that is invoked. It should return <c>true</c> if the item sent in matched and was handled.</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchBuilder`1.Match(System.Type,System.Func{`0,System.Boolean})">
            <summary>
            Adds a handler that is called if the item being matched is of type <paramref name="handlesType"/>.
            The handler should return <c>true</c> if the item sent in matched and was handled.
            <remarks>Note that if a previous added handler handled the item, this <paramref name="handler"/> will not be invoked.</remarks>
            </summary>
            <param name="handlesType">The type that it must match in order for <paramref name="handler"/> to be called.</param>
            <param name="handler">The handler that is invoked. It should return <c>true</c> if the item sent in matched and was handled.</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchBuilder`1.MatchAny(System.Action{`0})">
            <summary>
            Adds a handler that is invoked no matter the type the item being matched is.
            <remarks>Note that since this matches all items, no more handlers may be added after this one.</remarks>
            <remarks>Note that if a previous added handler handled the item, this <paramref name="handler"/> will not be invoked.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchBuilder`1.Build">
            <summary>
            Builds all added handlers and returns a <see cref="T:Akka.Tools.MatchHandler.PartialAction`1">PartialAction&lt;object&gt;</see>.
            </summary>
            <returns>Returns a <see cref="T:Akka.Tools.MatchHandler.PartialAction`1">PartialAction&lt;object&gt;</see></returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.MatchBuilderSignature">
            <summary>
            This class contains the handled <see cref="T:System.Type">Types</see> and <see cref="T:Akka.Tools.MatchHandler.HandlerKind">HandlerKinds</see> 
            that has been added to a <see cref="T:Akka.Tools.MatchHandler.MatchBuilder"/>.
            Two signatures are equal if they contain the same <see cref="T:System.Type">Types</see> and <see cref="T:Akka.Tools.MatchHandler.HandlerKind">HandlerKinds</see>
            in the same order.
            </summary>
        </member>
        <member name="T:Akka.Tools.MatchHandler.PartialAction`1">
            <summary>
            An action that returns <c>true</c> if the <param name="item"/> was handled.
            </summary>
            <typeparam name="T">The type of the argument</typeparam>
            <param name="item">The argument.</param>
            <returns>Returns <c>true</c> if the <param name="item"/> was handled</returns>
        </member>
        <member name="M:Akka.Util.StringFormat.SafeJoin(System.String,System.Object[])">
            <summary>
            Concatenates the values, using the specified separator between the elements.
            This method is similar to <see cref="M:System.String.Join(System.String,System.Object[])"/> except it
            formats null values as &lt;null&gt;
            </summary>
            <param name="separator">The separator.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="T:Akka.Util.Switch">
            <summary>
            An atomic switch that can be either on or off
            </summary>
        </member>
        <member name="M:Akka.Util.Switch.SwitchOff(System.Action)">
            <summary>
            Executes the provided action if the lock is on. This is done under a lock so be _very_ careful with longrunning/blocking operations in it.
            Only executes the action if the switch is on, and switches it off immediately after obtaining the lock.
            Will switch it back on if the provided action throws an exception.
            </summary>
            <returns>Returns <c>true</c> if the switch was switched off</returns>
        </member>
        <member name="M:Akka.Util.Switch.SwitchOn(System.Action)">
            <summary>
            Executes the provided action if the lock is off. This is done under a lock so be _very_ careful with longrunning/blocking operations in it.
            Only executes the action if the switch is off, and switches it on immediately after obtaining the lock.
            Will switch it back off if the provided action throws an exception.
            </summary>
            <returns>Returns <c>true</c> if the switch was switched on</returns>
        </member>
        <member name="M:Akka.Util.Switch.SwitchOff">
            <summary>
            Switches the switch off (if on). Uses locking.
            </summary>
            <returns>Returns <c>true</c> if the switch was switched off</returns>
        </member>
        <member name="M:Akka.Util.Switch.SwitchOn">
            <summary>
            Switches the switch on (if off). Uses locking.
            </summary>
            <returns>Returns <c>true</c> if the switch was switched on</returns>
        </member>
        <member name="M:Akka.Util.Switch.IfOn(System.Action)">
            <summary>
            Executes the provided action and returns if the action was executed or not, if the switch is IMMEDIATELY on (i.e. no lock involved)
            </summary>
            <param name="action">The action.</param>
            <returns>Return <c>true</c> if the switch was on</returns>
        </member>
        <member name="M:Akka.Util.Switch.IfOff(System.Action)">
            <summary>
            Executes the provided action and returns if the action was executed or not, if the switch is IMMEDIATELY off (i.e. no lock involved)
            </summary>
            <param name="action">The action.</param>
            <returns>Return <c>true</c> if the switch was off</returns>
        </member>
        <member name="M:Akka.Util.Switch.WhileOn(System.Action)">
            <summary>
            Executes the provided action and returns if the action was executed or not, if the switch is on, waiting for any pending changes to happen before (locking)
            Be careful of longrunning or blocking within the provided action as it can lead to deadlocks or bad performance
            </summary>
        </member>
        <member name="M:Akka.Util.Switch.WhileOff(System.Action)">
            <summary>
            Executes the provided action and returns if the action was executed or not, if the switch is off, waiting for any pending changes to happen before (locking)
            Be careful of longrunning or blocking within the provided action as it can lead to deadlocks or bad performance
            </summary>
        </member>
        <member name="P:Akka.Util.Switch.IsOn">
            <summary>
            Gets a value indicating whether this switch is on. No locking.
            </summary>
            <value>
              <c>true</c> if this instance is on; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Akka.Util.Switch.IsOff">
            <summary>
            Gets a value indicating whether this switch is off. No locking.
            </summary>
            <value>
              <c>true</c> if this instance is off; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:Akka.Util.TypeExtensions">
            <summary>
            Class TypeExtensions.
            </summary>
        </member>
        <member name="M:Akka.Util.TypeExtensions.Implements``1(System.Type)">
            <summary>
            Returns true if <paramref name="type" /> implements/inherits <typeparamref name="T" />.
            <example><para>typeof(object[]).Implements&lt;IEnumerable&gt;() --&gt; true</para></example>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="type">The type.</param>
            <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Util.TypeExtensions.Implements(System.Type,System.Type)">
            <summary>
            Returns true if <paramref name="type" /> implements/inherits <paramref name="moreGeneralType" />.
            <example><para>typeof(object[]).Implements(typeof(IEnumerable)) --&gt; true</para></example>
            </summary>
            <param name="type">The type.</param>
            <param name="moreGeneralType">Type of the more general.</param>
            <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        </member>
    </members>
</doc>
